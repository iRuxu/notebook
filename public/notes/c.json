{"version":1581858934969,"name":"c","data":[{"column":[{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"int","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nint|\t4 个字节|\t-2147483648 到 2147483647\nunsigned int|\t4 个字节|\t0 到 4294967295\nsigned int|\t4 个字节|\t-2147483648 到 2147483647\nshort int|\t2 个字节|\t-32768 到 32767\nunsigned short int|\t2 个字节|\t0 到 65,535\nsigned short int|\t2 个字节\t|-32768 到 32767\nlong int|\t8 个字节|\t-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\nsigned long int|\t8 个字节|\t-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\nunsigned long int|\t8 个字节|\t0 到 18,446,744,073,709,551,615","reference":"","dot":"","title":"数学"},{"prefix":"","tag":"浮点型 ","suffix":"float / double","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nfloat|\t4 个字节|\t精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)\ndouble|\t8 个字节|\t双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)\nlong double|\t16 个字节|\t长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":"bool","desc":"值：true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符型 ","suffix":"char / wchar_t","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nchar|\t1 个字节|\t-128 到 127 或者 0 到 255\nunsigned char|\t1 个字节|\t0 到 255\nsigned char|\t1 个字节|\t-128 到 127\nwchar_t|\t2 或 4 个字节|\t1 个宽字符","reference":"","dot":""},{"prefix":"","tag":"无类型 ","suffix":"void","desc":"函数返回为空，函数参数为空，指针指向 void","url":"","summary":"void 类型指定没有可用的值。它通常用于以下三种情况下：\n1. 函数返回为空。C中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);\n2. 函数参数为空。C中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);\n3. 指针指向 void。类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。","reference":"","dot":""},{"prefix":"","tag":"字符串","suffix":"","desc":"char $str[] = \"string\" 一串字符串 ","url":"","summary":"字符串实际上是使用 null 字符 '\\0' 终止的一维字符数组\n由于在数组的末尾存储了空字符，所以字符数组(非字符串)的大小比字符串的字符数多一个","reference":"","dot":""},{"prefix":"","tag":"数组 ","suffix":"","desc":"<table>\n    <tr>\n        <th>数组</th>\n        <th>表示</th>\n    </tr>\n    <tr>\n        <td>一维数组 $arr[i]</td>\n        <td>$type $arr[len] = {,..}</td>\n    </tr>\n    <tr>\n        <td>二维数组 $arr[i][j]</td>\n        <td>$type $arr[len][len] = { {..},{..}..}</td>\n    </tr>\n</table>","url":"","summary":"<table>\n    <caption>const与指针</caption>\n    <tr>\n        <th>形式</th>\n        <th>说明</th>\n        <th>*号位置</th>\n    </tr>\n    <tr>\n        <td>int const* ptr</td>\n        <td>变量仅仅只作为指针，不能通过指针改变原地址的值(参数传值用)</td>\n        <td>*在const之后</td>\n    </tr>\n    <tr>\n        <td>int *const ptr</td>\n        <td>一个地址不能改变的指针，无法修改指针的值(存的内存地址)</td>\n        <td>*在const之前</td>\n    </tr>\n</table>\n\n1.数组变量是一个*const指针，固定指向了某个数组（存的是第一个元素的地址），故不可被赋值，故也不能够数组变量交换赋值（需要复制数组时必须遍历）。 <br>\n2.故当一个指针变量被数组变量或字符串变量赋值时，无需添加&取地址符，对其的求值，也无需使用*间接访问运算符 <br>\n3.故*和[]即可对指针做运算，也可对数组变量做运算\n\n<hr>\n\n1.函数参数表中的数组参数实际上也只是指针，故无法通过sizeof获取长度，必须手动传入数组长度。<br>\n2.当传入函数参数禁止该指针对原数据进行修改时，则使用const*指针","reference":"","dot":""},{"prefix":"","tag":"枚举 ","suffix":"enum","desc":"enum color { red, green, blue } ;\n默认第一个值为0，依次+1","url":"","summary":"如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n```\nenum 枚举名{ \n     标识符[=整型常数], \n     标识符[=整型常数], \n... \n    标识符[=整型常数]\n} 枚举变量;\n```\n```\nenum color { red, green, blue } ;\ncolor c = blue;\ncout << c << endl;\n//c的值为2\n```","reference":"","dot":""},{"prefix":"","tag":"指针 ","suffix":"*ptr","desc":"int  var = 20; 实际变量的声明\nint  *ip; 指针变量的声明\nip = &var; 在指针变量中存储","url":"","summary":"在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。\nNULL 指针是一个定义在标准库中的值为零的常量。\n<table>\n    <tbody>\n        <tr>\n            <th>大小</th>\n            <th>位数</th>\n            <th>16进制地址</th>\n        </tr>\n        <tr>\n            <td>4字节</td>\n            <td>32位</td>\n            <td>0x0062fe44</td>\n        </tr>\n        <tr>\n            <td>8字节</td>\n            <td>64位</td>\n            <td></td>\n        </tr>\n    </tbody>\n</table>","reference":"","dot":""},{"prefix":"","tag":"结构体 ","suffix":"struct","desc":"struct $obj {$type $var;..} [$_var]; \nstruct Book {char title[10];..} book1; \n结构名并不是地址，必须通过&取","url":"","summary":"**.** 结构体成员访问运算符\n定义结构体： struct Books {...}\n声明变量Book1，类型为结构体Books： struct Books Book1\n访问Book1成员：Book1.prop\n\n-----------\n\n**->** 指针访问结构的成员\n定义结构体： struct Books {...}\n声明变量Book1，类型为结构体Books： struct Books Book1 \n定义指向结构的指针： struct Books *ptr\n赋值指针地址： ptr = &Book1\n访问指针指向地址结构体的成员：ptr->prop\n\n-----------\n\n位域\nstruct 位域结构名 {类型说明符 位域名:位域长度;..} [变量名];\nstruct Book {int page:8;..} book1;","reference":"","dot":""},{"prefix":"","tag":"共用体 ","suffix":"union","desc":"union 共用体标识符 {类型说明符 成员名;..}[变量名]; \n共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型\n共用体占用的内存应足够存储共用体中最大的成员","url":"","summary":"","reference":"","dot":""}]},{"title":"类型检测","fold":false,"list":[{"prefix":"","tag":"typeid(var).name()","suffix":"","desc":"返回变量的类型\n\\#include \\<typeinfo>  （后面无分号）","url":"","summary":"","reference":"","dot":""}]},{"title":"类型方法","fold":false,"list":[{"prefix":"","tag":"typedef ","suffix":"old new","desc":"为一个已有的类型取一个新的名字\ntypedef int feet;\nfeet distance;","url":"","summary":"typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。\ntypedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。","reference":"","dot":""},{"prefix":"","tag":"$type","suffix":"(var)","desc":"强制类型转换","url":"","summary":"var3 = (double) var2 / var1\n这里要注意的是强制类型转换运算符的优先级大于除法\n如果一个运算符两边的运算数类型不同，先要将其转换为相同的类型，即较低类型转换为较高类型，然后再参加运算","reference":"","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"type ","suffix":"x = val","desc":"定义一个变量，建立了存储空间\nint zero = 0 定义变量并初始化","url":"","summary":"当局部变量被定义时，系统不会对其初始化，须自行对其初始化。\n定义全局变量时，系统会自动对其初始化。\n<table>\n    <tr>\n        <th>类型</th>\n        <th>初始化默认值</th>\n    </tr>\n    <tr>\n        <td>int</td>\n        <td>0</td>\n    </tr>\n    <tr>\n        <td>char</td>\n        <td>'\\0'</td>\n    </tr>\n    <tr>\n        <td>float</td>\n        <td>0</td>\n    </tr>\n    <tr>\n        <td>double</td>\n        <td>0</td>\n    </tr>\n    <tr>\n        <td>pointer</td>\n        <td>NULL</td>\n    </tr>\n</table>","reference":"","dot":""},{"prefix":"","tag":"const ","suffix":"type x = val","desc":"定义一个常量","url":"","summary":"","reference":"#define与const区别|https://blog.csdn.net/qq_26685237/article/details/79587445","dot":""},{"prefix":"type ","tag":"*ptr = ","suffix":"&var","desc":"*ptr在声明语句中为声明，在执行语句中返回该指针变量所指向的对象的值","url":"","summary":"*：\n1.声明语句中，用于指针变量声明： \n*ptr = NULL/0 \n\\*ptr = &var\n需要被赋值一个内存地址\n2.执行语句中，作为间接访问运算符：\nprint(\"%d\",*ptr) \n**要求运算对象是地址量(指针变量),返回值是该指针变量所指向的对象的值**\n\n------------\n\n&：\n取地址运算符，返回变量的地址\n&变量名 或 &数组元素名\n&运算符的操作数必须是一个变量，不能把地址运算符用于常量、表达式或存储类别为register型的变量上","reference":"","dot":""},{"prefix":"","tag":"type& x ","suffix":"= var","desc":"c++:引用就是另一个变量的别名\nint i = 17;\nint& r = i;","url":"","summary":"引用很容易与指针混淆，它们之间有三个主要的不同：\n1. 不存在空引用。引用必须连接到一块合法的内存。\n2. 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n3. 引用必须在创建时被初始化。指针可以在任何时间被初始化。","reference":"","dot":""}]},{"title":"修饰符","fold":true,"list":[{"prefix":"","tag":"volatile ","suffix":"var","desc":"不需要优化volatile声明的变量，让程序可以直接从内存中读取变量","url":"","summary":"修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。","reference":"","dot":""},{"prefix":"","tag":"restrict ","suffix":"*ptr","desc":"由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式","url":"","summary":"","reference":"","dot":""}]},{"title":"存储类","fold":true,"list":[{"prefix":"","tag":"extern ","suffix":"var","desc":"定义外部变量，不指定存储类别。\n存储在全局数据区，全局生存期，全局作用域。","url":"","summary":"extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n\n当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。\n\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候","reference":"","dot":""},{"prefix":"","tag":"register ","suffix":"var","desc":"只对内部变量有效，存储在寄存器，自动生存期、局部作用域。","url":"","summary":"register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。","reference":"","dot":""},{"prefix":"","tag":"static ","suffix":"var","desc":"static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。","url":"","summary":"1.定义局部变量时\n存储在全局数据区，全局生存期，全局作用域\n2.定义在函数外面时\n存储在全局数据区，全局生存期，但为文件作用域，即作用域限制在声明它的文件内，外部无法使用extern引用。","reference":"","dot":""},{"prefix":"","tag":"thread_local ","suffix":"var","desc":"","url":"","summary":"使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\nthread_local 说明符可以与 static 或 extern 合并。\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\n","reference":"","dot":""},{"prefix":"","tag":"auto ","suffix":"var","desc":"只对内部变量有效，存在在内存栈区，自动生存期，局部作用域。\n","url":"","summary":"声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\n从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符","reference":"","dot":""}]},{"title":"运算符","fold":true,"list":[{"prefix":"","tag":"算术运算符","suffix":"","desc":"加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n除法运算符：x / y\n余数运算符：x % y\n自增运算符：++x 或者 x++\n自减运算符：--x 或者 x--","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"关系运算符","suffix":"","desc":"\\> 大于运算符\n\\< 小于运算符\n>= 大于或等于运算符\n<= 小于或等于运算符\n== 相等运算符\n!= 不相等运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逻辑运算符","suffix":"","desc":"取反运算符：!\n且运算符：&&\n或运算符：||\n三元运算符：?:","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"位运算符","suffix":"","desc":"| 按位或\n& 按位与\n~ 按位取反\n^ 按位异或\n\\<< 左移运算符 \n\n>> 右移运算符\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"赋值运算符","suffix":"","desc":"+= -= *= **= /= %= &= |= ^= <<= >>=","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逗号运算符","suffix":"","desc":"会顺序执行一系列运算。\n整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。","url":"","summary":"","reference":"","dot":""}]},{"title":"预处理器","fold":true,"list":[{"prefix":"","tag":"#define ","suffix":"x val","desc":"定义一个常量或参数宏\n\\#define PI 3.14\n\\#define MIN(a,b) (a<b ? a : b)","url":"","summary":"1.带参数的宏，参数与整体都应加括号\n2.宏定义不应加分号\n3.宏定义没有类型检查\n4.由宏定义函数会被反复展开，以空间换区效率","reference":"","dot":""},{"prefix":"","tag":"#ifdef","suffix":"","desc":"","url":"","summary":"\\#ifdef | \\#ifndef\n如果宏已经定义，则返回真\n如果宏没有定义，则返回真\n------------\n\\#if | \\#else | \\#elif\n如果给定条件为真，则编译下面代码\n#if 的替代方案\n如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码\n------------\n\\#endif\n结束一个带if的条件编译块\n------------\n\\#undef\n取消已定义的宏","reference":"","dot":""},{"prefix":"","tag":"#error","suffix":"","desc":"当遇到标准错误时，输出错误消息","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"#pragma","suffix":"","desc":"使用标准化方法，向编译器发布特殊的命令到编译器中","url":"","summary":"","reference":"","dot":""}]},{"title":"流程控制","fold":false,"list":[{"prefix":"","tag":"if..else..","suffix":"","desc":"if(exp){...} //仅有一个语句时，可省略{}\nif(exp){...}else{...}\nif(exp){...}else if(exp){...}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"switch","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"x?y:z","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"循环语句","fold":false,"list":[{"prefix":"","tag":"while","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"do..while","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for","suffix":"","desc":"for(init;condition;increment){..}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"break","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"continue","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"label:","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"goto ","suffix":"label","desc":"将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句","url":"","summary":"","reference":"","dot":""}]}]},{"title":"全局","barcolor":"","fold":false,"box":[{"title":"方法/语句","fold":false,"list":[{"prefix":"","tag":"sizeof","suffix":"(var)","desc":"返回变量的大小，静态运算符，不会对表示式做运算","url":"","summary":"例如，sizeof(a) 将返回 4，其中 a 是整数。","reference":"","dot":""}]},{"title":"预定义宏","fold":true,"list":[{"prefix":"","tag":"__DATE__","suffix":"","desc":"当前日期，一个以 \"MMM DD YYYY\" 格式表示的字符常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__TIME__","suffix":"","desc":"当前时间，一个以 \"HH:MM:SS\" 格式表示的字符常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__FILE__","suffix":"","desc":"当前文件名，一个字符串常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__LINE__","suffix":"","desc":"当前行号，一个十进制常量","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"安装与编译","fold":false,"list":[{"prefix":"","tag":"g++ -v","suffix":"","desc":"程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"g++ ","suffix":"file -o outfile","desc":"g++ helloworld.cpp -o helloworld","url":"","summary":"使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件\n\n选项|解释\n---|:--:|\n-ansi|只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。\n-c|只编译并生成目标文件。\n-DMACRO|以字符串\"1\"定义 MACRO 宏。\n-DMACRO=DEFN|以字符串\"DEFN\"定义 MACRO 宏。\n-E\t|只运行 C 预编译器。\n-g\t|生成调试信息。GNU 调试器可利用该信息。\n-IDIRECTORY\t|指定额外的头文件搜索路径DIRECTORY。\n-LDIRECTORY\t|指定额外的函数库搜索路径DIRECTORY。\n-lLIBRARY\t|连接时搜索指定的函数库LIBRARY。\n-m486\t|针对 486 进行代码优化。\n-o\t|FILE 生成指定的输出文件。用在生成可执行文件时。\n-O0\t|不进行优化处理。\n-O\t|或 -O1 优化生成代码。\n-O2\t|进一步优化。\n-O3\t|比 -O2 更进一步优化，包括 inline 函数。\n-shared\t|生成共享目标文件。通常用在建立共享库时。\n-static\t|禁止使用共享连接。\n-UMACRO\t|取消对 MACRO 宏的定义。\n-w\t|不生成任何警告信息。\n-Wall\t|生成所有警告信息。","reference":"","dot":""}]}]}]}]}