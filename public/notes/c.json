{"version":1581057791728,"name":"c","data":[{"column":[{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"int","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nint|\t4 个字节|\t-2147483648 到 2147483647\nunsigned int|\t4 个字节|\t0 到 4294967295\nsigned int|\t4 个字节|\t-2147483648 到 2147483647\nshort int|\t2 个字节|\t-32768 到 32767\nunsigned short int|\t2 个字节|\t0 到 65,535\nsigned short int|\t2 个字节\t|-32768 到 32767\nlong int|\t8 个字节|\t-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\nsigned long int|\t8 个字节|\t-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\nunsigned long int|\t8 个字节|\t0 到 18,446,744,073,709,551,615","reference":"","dot":""},{"prefix":"","tag":"浮点型 ","suffix":"float / double","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nfloat|\t4 个字节|\t精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)\ndouble|\t8 个字节|\t双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)\nlong double|\t16 个字节|\t长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":"bool","desc":"值：true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符型 ","suffix":"char / wchar_t","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nchar|\t1 个字节|\t-128 到 127 或者 0 到 255\nunsigned char|\t1 个字节|\t0 到 255\nsigned char|\t1 个字节|\t-128 到 127\nwchar_t|\t2 或 4 个字节|\t1 个宽字符","reference":"","dot":""},{"prefix":"","tag":"无类型 ","suffix":"void","desc":"函数返回为空，函数参数为空，指针指向 void","url":"","summary":"void 类型指定没有可用的值。它通常用于以下三种情况下：\n1. 函数返回为空。C中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);\n2. 函数参数为空。C中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);\n3. 指针指向 void。类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。","reference":"","dot":""},{"prefix":"","tag":"枚举 ","suffix":"enum","desc":"enum color { red, green, blue } ;\n默认第一个值为0，依次+1","url":"","summary":"如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n```\nenum 枚举名{ \n     标识符[=整型常数], \n     标识符[=整型常数], \n... \n    标识符[=整型常数]\n} 枚举变量;\n```\n```\nenum color { red, green, blue } ;\ncolor c = blue;\ncout << c << endl;\n//c的值为2\n```","reference":"","dot":""}]},{"title":"类型方法","fold":false,"list":[{"prefix":"","tag":"typedef ","suffix":"old new","desc":"为一个已有的类型取一个新的名字\ntypedef int feet;\nfeet distance;","url":"","summary":"typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。\ntypedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。","reference":"","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"type ","suffix":"x = val","desc":"定义一个变量，建立了存储空间\nint zero = 0 定义变量并初始化","url":"","summary":"当局部变量被定义时，系统不会对其初始化，须自行对其初始化。\n定义全局变量时，系统会自动对其初始化。\n<table>\n                            <tr>\n                                <th>类型</th>\n                                <th>初始化默认值</th>\n                            </tr>\n                            <tr>\n                                <td>int</td>\n                                <td>0</td>\n                            </tr>\n                            <tr>\n                                <td>char</td>\n                                <td>'\\0'</td>\n                            </tr>\n                            <tr>\n                                <td>float</td>\n                                <td>0</td>\n                            </tr>\n                            <tr>\n                                <td>double</td>\n                                <td>0</td>\n                            </tr>\n                            <tr>\n                                <td>pointer</td>\n                                <td>NULL</td>\n                            </tr>\n                        </table>","reference":"","dot":""},{"prefix":"","tag":"const ","suffix":"type x = val","desc":"定义一个常量","url":"","summary":"","reference":"#define与const区别|https://blog.csdn.net/qq_26685237/article/details/79587445","dot":""}]},{"title":"修饰符","fold":true,"list":[{"prefix":"","tag":"volatile ","suffix":"var","desc":"不需要优化volatile声明的变量，让程序可以直接从内存中读取变量","url":"","summary":"修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。","reference":"","dot":""},{"prefix":"","tag":"restrict ","suffix":"*ptr","desc":"由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式","url":"","summary":"","reference":"","dot":""}]},{"title":"存储类","fold":true,"list":[{"prefix":"","tag":"extern ","suffix":"var","desc":"定义外部变量，不指定存储类别。\n存储在全局数据区，全局生存期，全局作用域。","url":"","summary":"extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n\n当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。\n\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候","reference":"","dot":""},{"prefix":"","tag":"register ","suffix":"var","desc":"只对内部变量有效，存储在寄存器，自动生存期、局部作用域。","url":"","summary":"register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。","reference":"","dot":""},{"prefix":"","tag":"static ","suffix":"var","desc":"static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。","url":"","summary":"1.定义局部变量时\n存储在全局数据区，全局生存期，全局作用域\n2.定义在函数外面时\n存储在全局数据区，全局生存期，但为文件作用域，即作用域限制在声明它的文件内，外部无法使用extern引用。","reference":"","dot":""},{"prefix":"","tag":"thread_local ","suffix":"var","desc":"","url":"","summary":"使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\nthread_local 说明符可以与 static 或 extern 合并。\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\n","reference":"","dot":""},{"prefix":"","tag":"auto ","suffix":"var","desc":"只对内部变量有效，存在在内存栈区，自动生存期，局部作用域。\n","url":"","summary":"声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\n从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符","reference":"","dot":""}]},{"title":"预处理器","fold":true,"list":[{"prefix":"","tag":"#define ","suffix":"x val","desc":"定义一个常量或参数宏\n\\#define PI 3.14\n\\#define MIN(a,b) (a<b ? a : b)","url":"","summary":"1.带参数的宏，参数与整体都应加括号\n2.宏定义不应加分号\n3.宏定义没有类型检查\n4.由宏定义函数会被反复展开，以空间换区效率","reference":"","dot":""},{"prefix":"","tag":"#ifdef","suffix":"","desc":"","url":"","summary":"\\#ifdef | \\#ifndef\n如果宏已经定义，则返回真\n如果宏没有定义，则返回真\n------------\n\\#if | \\#else | \\#elif\n如果给定条件为真，则编译下面代码\n#if 的替代方案\n如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码\n------------\n\\#endif\n结束一个带if的条件编译块\n------------\n\\#undef\n取消已定义的宏","reference":"","dot":""},{"prefix":"","tag":"#error","suffix":"","desc":"当遇到标准错误时，输出错误消息","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"#pragma","suffix":"","desc":"使用标准化方法，向编译器发布特殊的命令到编译器中","url":"","summary":"","reference":"","dot":""}]},{"title":"预定义宏","fold":true,"list":[{"prefix":"","tag":"__DATE__","suffix":"","desc":"当前日期，一个以 \"MMM DD YYYY\" 格式表示的字符常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__TIME__","suffix":"","desc":"当前时间，一个以 \"HH:MM:SS\" 格式表示的字符常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__FILE__","suffix":"","desc":"当前文件名，一个字符串常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__LINE__","suffix":"","desc":"当前行号，一个十进制常量","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"安装与编译","fold":false,"list":[{"prefix":"","tag":"g++ -v","suffix":"","desc":"程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"g++ ","suffix":"file -o outfile","desc":"g++ helloworld.cpp -o helloworld","url":"","summary":"使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件\n\n选项|解释\n---|:--:|\n-ansi|只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。\n-c|只编译并生成目标文件。\n-DMACRO|以字符串\"1\"定义 MACRO 宏。\n-DMACRO=DEFN|以字符串\"DEFN\"定义 MACRO 宏。\n-E\t|只运行 C 预编译器。\n-g\t|生成调试信息。GNU 调试器可利用该信息。\n-IDIRECTORY\t|指定额外的头文件搜索路径DIRECTORY。\n-LDIRECTORY\t|指定额外的函数库搜索路径DIRECTORY。\n-lLIBRARY\t|连接时搜索指定的函数库LIBRARY。\n-m486\t|针对 486 进行代码优化。\n-o\t|FILE 生成指定的输出文件。用在生成可执行文件时。\n-O0\t|不进行优化处理。\n-O\t|或 -O1 优化生成代码。\n-O2\t|进一步优化。\n-O3\t|比 -O2 更进一步优化，包括 inline 函数。\n-shared\t|生成共享目标文件。通常用在建立共享库时。\n-static\t|禁止使用共享连接。\n-UMACRO\t|取消对 MACRO 宏的定义。\n-w\t|不生成任何警告信息。\n-Wall\t|生成所有警告信息。","reference":"","dot":""}]}]}]}]}