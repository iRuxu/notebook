{"version":1577292216582,"name":"vue","data":[{"column":[{"title":"Vue2基础","barcolor":"","fold":false,"box":[{"title":"应用&实例","fold":false,"list":[{"prefix":"","tag":"new Vue","suffix":"(opt)","desc":"创建实例","url":"","summary":"","reference":"API - 全部选项|https://cn.vuejs.org/v2/api/","dot":""}]},{"title":"DOM","fold":false,"list":[{"prefix":"vm","tag":".$mount","suffix":"(el)","desc":"【挂载】：如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"el","suffix":"","desc":"【挂载】：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。\n可以是 CSS 选择器，也可以是一个 HTMLElement 实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"template","suffix":"","desc":"【渲染】：一个字符串模板作为 Vue 实例的标识使用。模板将会替换挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。\n如果 Vue 选项中包含渲染函数，该模板将被忽略。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"render","suffix":"","desc":"【渲染】：自定义模板（需要修改tag）\n```\nrender: function (createElement) {\n  return createElement('div', this.$slots.default)\n}\n```","url":"","summary":"# 插槽传值\n```\nprops: ['message'],\nrender: function (createElement) {\n  // `<div><slot :text=\"message\"></slot></div>`\n  return createElement('div', [\n    this.$scopedSlots.default({\n      text: this.message\n    })\n  ])\n}\n```","reference":"createElement|https://cn.vuejs.org/v2/guide/render-function.html#createElement-%E5%8F%82%E6%95%B0\n插槽传值|https://cn.vuejs.org/v2/guide/render-function.html#%E6%8F%92%E6%A7%BD","dot":""}]},{"title":"模板语法","fold":false,"list":[{"prefix":"","tag":"v-text","suffix":"{{data}}","desc":"{{data}}文本插值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-once","suffix":"","desc":"一次性文本插值\n只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-html","suffix":"","desc":"输出HTML","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind","suffix":":attr","desc":"`<button v-bind:[key]=\"value\"></button>`动态属性名\n`<div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>`多个attribute","url":"","summary":"# 修饰符\n.prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。\n.camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。\n.sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。","reference":"","dot":""},{"prefix":"","tag":"class","suffix":"","desc":"```\n<div :class=\"{ red: isRed }\"></div>\n<div :class=\"[classA, classB]\"></div>\n<div :class=\"[classA, { classB: isB, classC: isC }]\">\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"style","suffix":"","desc":"```\n<div :style=\"{ fontSize: size + 'px' }\"></div>\n<div :style=\"[styleObjectA, styleObjectB]\"></div>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-if","suffix":"","desc":"v-if/v-else/v-else-if\nv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-show","suffix":"","desc":"v-show 只是简单地切换元素的 CSS property display。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"key","suffix":"","desc":"Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。\n添加key以保证元素是完全独立而不会复用。","url":"","summary":"","reference":"极客时间|https://time.geekbang.org/course/detail/100024601-86448\nAPI文档|https://cn.vuejs.org/v2/api/#key","dot":""},{"prefix":"","tag":"v-for","suffix":"","desc":"```\n<div v-for=\"(item, index) in items\"></div>\n<div v-for=\"(val, key) in object\"></div>\n<div v-for=\"(val, name, index) in object\"></div>\n<div v-for=\"item in 5\">{{item}}</div> 从1-5\n```","url":"","summary":"v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示","reference":"","dot":""},{"prefix":"","tag":"v-pre","suffix":"","desc":"跳过这个元素和它的子元素的编译过程。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-cloak","suffix":"","desc":"这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。","url":"","summary":"","reference":"API文档|https://cn.vuejs.org/v2/api/#v-cloak","dot":""}]},{"title":"生命周期","fold":false,"list":[{"prefix":"lifeCycle","tag":" ","suffix":"","desc":"生命周期钩子的 this 上下文指向调用它的 Vue 实例。","url":"","summary":"","reference":"生命周期图|https://cn.vuejs.org/v2/guide/instance.html","dot":""},{"prefix":"","tag":"beforeCreate","suffix":"","desc":"在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"created","suffix":"","desc":"在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeMount","suffix":"","desc":"在挂载开始之前被调用：相关的 render 函数首次被调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mounted","suffix":"","desc":"实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。\n注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 mounted 内部使用 vm.$nextTick","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUpdate","suffix":"","desc":"在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。\n该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。","url":"","summary":"期间不可更改依赖数据。","reference":"","dot":""},{"prefix":"","tag":"updated","suffix":"","desc":"在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n注意，updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 updated 里使用 vm.$nextTick。","url":"","summary":"期间不可更改依赖数据。","reference":"声明周期应用场景|https://time.geekbang.org/course/detail/100024601-86621","dot":""},{"prefix":"","tag":"activated","suffix":"","desc":"被 keep-alive 缓存的组件激活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"deactivated","suffix":"","desc":"被 keep-alive 缓存的组件失活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeDestroy","suffix":"","desc":"实例销毁之前调用。在这一步，实例仍然完全可用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"","tag":"destroyed","suffix":"","desc":"实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"","tag":"errorCaptured","suffix":"","desc":"在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。","url":"","summary":"","reference":"","dot":""}]},{"title":"插件","fold":false,"list":[{"prefix":"","tag":"Vue.use","suffix":"(plugin,[opt])","desc":"通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成","url":"","summary":"","reference":"","dot":""},{"prefix":"plugin","tag":".install","suffix":"","desc":"Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象\n```\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或 property（可能不作用于实例，this指向Vue）\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法（this指向实例）\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n```","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue3基础","barcolor":"","fold":false,"box":[{"title":"实例","fold":false,"list":[{"prefix":"","tag":"Vue.createApp","suffix":"(opt)","desc":"每个 Vue 应用都是通过用 createApp 函数创建一个新的应用实例开始的。\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。","url":"","summary":"应用实例暴露的大多数方法都会返回该同一实例，允许链式。","reference":"API文档|https://v3.cn.vuejs.org/api/global-api.html#createapp","dot":""}]},{"title":"DOM","fold":false,"list":[{"prefix":"app","tag":".mount","suffix":"(el)","desc":"【挂载】：mount 不返回应用本身。相反，它返回的是根组件实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"template","suffix":"","desc":"【渲染】：一个字符串模板，用作 component 实例的标记。模板将会替换所挂载元素的 innerHTML。挂载元素的任何现有标记都将被忽略，除非模板中存在通过插槽分发的内容。\n如果 Vue 选项中包含渲染函数，模板将被忽略。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"render","suffix":"","desc":"【渲染】\n```\nprops: ['message'],\nrender() {\n  // `<div><slot :text=\"message\"></slot></div>`\n  return h('div', {}, this.$slots.default({\n    text: this.message\n  }))\n}\n```","url":"","summary":"","reference":"官方文档|https://v3.cn.vuejs.org/guide/render-function.html#dom-%E6%A0%91","dot":""}]},{"title":"模板语法","fold":false,"list":[{"prefix":"","tag":"v-text","suffix":"{{data}}","desc":"{{data}}文本插值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-once","suffix":"","desc":"一次性文本插值\n只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-html","suffix":"","desc":"输出HTML","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind","suffix":":attr","desc":"`<button v-bind:[key]=\"value\"></button>`动态属性名\n`<div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>`多个attribute\n\n当在一个元素上设置一个绑定的时候，Vue 会默认通过 in 操作检测该元素是否有一个被定义为 property 的 key。如果该 property 被定义了，Vue 会将这个值设置为一个 DOM property 而不是 attribute。大多数情况下，这样工作是正常的，但你也可以通过 .prop 或 .attr 修饰符显性地覆写这个行为。有的时候这是必要的，尤其是基于自定义元素的工作。","url":"","summary":"# 修饰符\n.camel - 将 kebab-case attribute 名转换为 camelCase。\n.prop - 将一个绑定强制设置为一个 DOM property。\n.attr - 将一个绑定强制设置为一个 DOM attribute。\n\n# 特殊\n属性disabled为空字符串时也保留空，优先转布尔。","reference":"","dot":""},{"prefix":"","tag":"class","suffix":"","desc":"```\n<div :class=\"{ red: isRed }\"></div>\n<div :class=\"[classA, classB]\"></div>\n<div :class=\"[classA, { classB: isB, classC: isC }]\">\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"style","suffix":"","desc":"```\n<div :style=\"{ fontSize: size + 'px' }\"></div>\n<div :style=\"[styleObjectA, styleObjectB]\"></div>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-if","suffix":"","desc":"v-if/v-else/v-else-if\nv-if 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-show","suffix":"","desc":"v-show 只是简单地切换元素的 CSS property display。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"key","suffix":"","desc":"Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。\n添加key以保证元素是完全独立而不会复用。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/special-attributes.html#key","dot":""},{"prefix":"","tag":"v-for","suffix":"","desc":"```\n<div v-for=\"(item, index) in items\"></div>\n<div v-for=\"(value, key) in object\"></div>\n<div v-for=\"(value, name, index) in object\"></div>\n<div v-for=\"item in 5\">{{item}}</div> 从1-5\n```","url":"","summary":"v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示","reference":"","dot":""},{"prefix":"","tag":"v-pre","suffix":"","desc":"跳过这个元素和它的子元素的编译过程。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-cloak","suffix":"","desc":"这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-memo","suffix":"","desc":"记住一个模板的子树。元素和组件上都可以使用。该指令接收一个固定长度的数组作为依赖值进行记忆比对。如果数组中的每个值都和上次渲染的时候相同，则整个该子树的更新会被跳过。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/directives.html#v-memo","dot":""}]},{"title":"生命周期","fold":false,"list":[{"prefix":"lifeCycle","tag":" ","suffix":"","desc":"生命周期钩子的 this 上下文指向调用它的 Vue 实例。","url":"","summary":"","reference":"生命周期图|https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA","dot":""},{"prefix":"","tag":"beforeCreate","suffix":"","desc":"在实例初始化之后、进行数据侦听和事件/侦听器的配置之前同步调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"created","suffix":"","desc":"在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeMount","suffix":"","desc":"在挂载开始之前被调用：相关的 render 函数首次被调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mounted","suffix":"","desc":"在实例挂载完成后被调用，这时候传递给 app.mount 的元素已经被新创建的 vm.$el 替换了。\n注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等待整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUpdate","suffix":"","desc":"在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。\n该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"updated","suffix":"","desc":"在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n注意，updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等待整个视图都渲染完毕，可以在 updated 内部使用 vm.$nextTick。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"activated","suffix":"","desc":"被 keep-alive 缓存的组件激活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"deactivated","suffix":"","desc":"被 keep-alive 缓存的组件失活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUnmount","suffix":"","desc":"在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":"#a6e22e"},{"prefix":"","tag":"unmounted","suffix":"","desc":"卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":"#a6e22e"},{"prefix":"","tag":"errorCaptured","suffix":"","desc":"在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"renderTracked","suffix":"","desc":"跟踪虚拟 DOM 重新渲染时调用。钩子接收 debugger event 作为参数。此事件告诉你哪个操作跟踪了组件以及该操作的目标对象和键。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#rendertracked","dot":""},{"prefix":"","tag":"renderTriggered","suffix":"","desc":"当虚拟 DOM 重新渲染被触发时调用。和 renderTracked 类似，接收 debugger event 作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#rendertriggered","dot":""},{"prefix":"","tag":"on$LifeCycle","suffix":"","desc":"在setup中关联生命周期行为\n其中beforeCreate和created不可用。","url":"","summary":"","reference":"","dot":"#c184ff"}]},{"title":"插件","fold":false,"list":[{"prefix":"","tag":"Vue.use","suffix":"(plugin,[opt])","desc":"通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成","url":"","summary":"","reference":"","dot":""},{"prefix":"plugin","tag":".install","suffix":"","desc":"Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象\n```\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或 property（可能不作用于实例，this指向Vue）\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法（this指向实例）\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n```","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue2扩展","barcolor":"","fold":false,"box":[{"title":"数据","fold":false,"list":[{"prefix":"","tag":"data","suffix":"","desc":"Vue2 不能检测数组和对象的变化。\n组件的 data 选项是一个函数。","url":"","summary":"当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。\n\n这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。\n实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的 property，因此访问 vm.a 等价于访问 vm.$data.a。\n以 _ 或 $ 开头的 property 不会被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些 property。\n\n当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。\n如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(...)) 得到深拷贝的原始数据对象。","reference":"","dot":""},{"prefix":"","tag":"Vue.observable","suffix":"(obj)","desc":"让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。\n```\nconst state = Vue.observable({ count: 0 })\n\nconst Demo = {\n  render(h) {\n    return h('button', {\n      on: { click: () => { state.count++ }}\n    }, `count is: ${state.count}`)\n  }\n}\n```","url":"","summary":"","reference":"API文档|https://cn.vuejs.org/v2/api/#Vue-observable","dot":"#66d9ef"},{"prefix":"vm","tag":".$set","suffix":"(target,prop/i,val)","desc":"响应式更改数组/对象中的值","url":"","summary":"","reference":"","dot":"#ff0000"},{"prefix":"","tag":"computed","suffix":"","desc":"计算属性是基于它们的响应式依赖进行缓存的。\ncomputed绑定this为当前实例，默认的参数即为this，可以解构传入data数据。\n```\ncomputed: {\n    // 仅读取\n    aDouble() {\n      return this.a * 2\n    },\n    // 读取和设置\n    aPlus: {\n      get() {\n        return this.a + 1\n      },\n      set(v) {\n        this.a = v - 1    //v为对computed属性尝试设置的值\n      }\n    }\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"watch","suffix":"","desc":"`a.b.c` 默认为this.a.b.c\n\n# 选项\n+ `immediate:true` 回调将会在侦听开始之后被立即调用\n+ `deep:true` 回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n+ `handler:fn(newValue,oldValue)/[fns,..]` 回调函数或回调函数数组","url":"","summary":"","reference":"watch API|https://cn.vuejs.org/v2/api/#watch\n$watch API|https://cn.vuejs.org/v2/api/#vm-watch\n数据监听简易实现版|https://juejin.cn/post/6844904079450193927","dot":""}]},{"title":"选项","fold":false,"list":[{"prefix":"","tag":"methods","suffix":"","desc":"methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mixins","suffix":"","desc":"# 局部混入 \n`mixins: [myMixin,..]`\n# 全局混入 \n\n`Vue.mixin(myMixin)`\n当组件和混入对象含有同名选项时，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。\n同名钩子函数将合并为一个数组，都将被调用，混入对象的钩子将在组件自身钩子之前调用。","url":"","summary":"","reference":"自定义选项合并策略|https://cn.vuejs.org/v2/guide/mixins.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5","dot":""},{"prefix":"","tag":"filters","suffix":"","desc":"# 使用\n`{{value | filterName}}`\n\n# 局部过滤器\n`filters : { name : fn}`\n\n# 全局过滤器\n`Vue.filter(name,fn)`\n\n当全局过滤器和局部过滤器重名时，会采用局部过滤器。\n过滤器中不能访问实例作用域","url":"","summary":"","reference":"","dot":"#ff0000"}]},{"title":"表单","fold":false,"list":[{"prefix":"","tag":"v-model","suffix":"","desc":"`<input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\">`","url":"","summary":"# select 注意事项\n添加一个初始化为空的禁用项 `<option disabled value=\"\">请选择</option>`","reference":"select注意事项|https://cn.vuejs.org/v2/guide/forms.html#%E9%80%89%E6%8B%A9%E6%A1%86","dot":""},{"prefix":"v-model","tag":".lazy","suffix":"","desc":"在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步","url":"","summary":"","reference":"","dot":""},{"prefix":"v-model","tag":".number","suffix":"","desc":"如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"v-model","tag":".trim","suffix":"","desc":"如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"","tag":"@[event]","suffix":"","desc":"用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。\n```\n<button v-on:click=\"doThis\"></button> //事件event\n<button v-on:click=\"doThat('hello', $event)\"></button> //指定参数\n<button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button> //多个事件\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".once","suffix":"","desc":"只触发一次回调。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".native","suffix":"","desc":"监听组件根元素的原生事件。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"@event","tag":".stop","suffix":"","desc":"阻止冒泡，调用 event.stopPropagation()。\n修饰符可以串联","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".capture","suffix":"","desc":"添加事件侦听器时使用 capture 模式。\n即内部元素触发的事件先在此处理，然后才交由内部元素进行处理","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".self","suffix":"","desc":"只当事件是从侦听器绑定的元素本身触发时才触发回调。\n用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".prevent","suffix":"","desc":"阻止默认事件，调用 event.preventDefault()。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".passive","suffix":"","desc":"以 { passive: true } 模式添加侦听器\n`<div v-on:scroll.passive=\"onScroll\">...</div>`\n滚动事件的默认行为 (即滚动行为) 将会立即触发，而不会等待 `onScroll` 完成。\n这个 .passive 修饰符尤其能够提升移动端的性能。\n不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。","url":"","summary":"","reference":"","dot":""},{"prefix":"@KeyboardEvent","tag":".$key","suffix":"","desc":"`<input v-on:keyup.enter=\"submit\">` 按键事件\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right","url":"","summary":"","reference":"key values|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values","dot":""},{"prefix":"@click","tag":".left/right/middle","suffix":"","desc":"鼠标点击事件修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".ctrl/alt/shift/meta","suffix":"","desc":"系统修饰键，可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。\n\nMac:meta 对应 command 键 (⌘)。\nWin:meta 对应 Windows 徽标键 (⊞)。\n\n`<div v-on:click.ctrl=\"doSomething\">Do something</div>`","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".exact","suffix":"","desc":"```\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button v-on:click.exact=\"onClick\">A</button>\n```","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Vue2指令","barcolor":"","fold":false,"box":[{"title":"注册指令","fold":false,"list":[{"prefix":"","tag":"directives","suffix":"","desc":"调用 `v-$cmd.$modifier:$arg=\"$value\"`\n需要对部分dom元素绑定格式化操作或交互行为。\n\n# 局部注册\n```\ndirectives: {\n  //指令名称\n  $cmd: {\n    //钩子函数\n    $hook: function (el,binding,vnode,oldVnode) {\n       //DOM操作\n    }\n  }\n}\n```\n# 局部注册（简写）\n**默认绑到bind和update钩子上（当依赖于元素dom已渲染时不适用）**\n```\ndirectives: {\n  $cmd: function (el,binding,vnode,oldVnode) {\n     //DOM操作\n  }\n}\n```","url":"","summary":"","reference":"自定义实例|https://segmentfault.com/a/1190000038475001","dot":""},{"prefix":"","tag":"Vue.directive","suffix":"(opt)","desc":"# 全局注册\n`Vue.directive($cmd,opt)`","url":"","summary":"","reference":"","dot":""}]},{"title":"钩子函数","fold":false,"list":[{"prefix":"","tag":"bind","suffix":"","desc":"只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"","tag":"inserted","suffix":"","desc":"被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"update","suffix":"","desc":"所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"","tag":"componentUpdated","suffix":"","desc":"指令所在组件的 VNode 及其子 VNode 全部更新后调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"unbind","suffix":"","desc":"只调用一次，指令与元素解绑时调用。","url":"","summary":"","reference":"","dot":""}]},{"title":"钩子参数","fold":false,"list":[{"prefix":"","tag":"el","suffix":"","desc":"el：指令所绑定的元素，可以用来直接操作 DOM。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"name","suffix":"","desc":"name：指令名，不包括 v- 前缀。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"value","suffix":"","desc":"指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"oldValue","suffix":"","desc":"指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding","tag":".expression","suffix":"","desc":"expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"arg","suffix":"","desc":"传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"modifiers","suffix":"","desc":"modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"vnode","suffix":"","desc":"vnode：Vue 编译生成的虚拟节点。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"oldNode","suffix":"","desc":"oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue3扩展","barcolor":"","fold":false,"box":[{"title":"数据","fold":false,"list":[{"prefix":"","tag":"data","suffix":"","desc":"实例或组件的 data 选项是一个函数。\n以 _ 或 $ 开头的 property 不会被组件实例代理","url":"","summary":"直接将不包含在 data 中的新 property 添加到组件实例是可行的。但由于该 property 不在背后的响应式 $data 对象内，所以 Vue 的响应性系统不会自动跟踪它。","reference":"","dot":""},{"prefix":"","tag":"ref","suffix":"(raw)","desc":"创建基础类型的响应式数据。\n模板默认调用value显示数据，方法中修改需要修改value的值才能修改。\nRef的本质是通过Reactive创建的，`Ref(10)=>Reactive({value:10});`\n```\nimport { ref } from 'vue'\nconst counter = ref(0)\nconsole.log(counter.value) // 0\ncounter.value = 1\n```\n\n# 解包\n当 ref 作为响应式对象的 property 被访问或更改时，为使其行为类似于普通 property，它会自动解包内部值。\nRef 解包仅发生在被响应式 Object 嵌套的时候。当从 Array 或原生集合类型如 Map访问 ref 时，不会进行解包。\n","url":"","summary":"# shallowRef\n`shallowRef(obj)`\n创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的。\n通过shallowRef创建的响应式对象，需要修改整个value才能重新渲染dom\n\n# triggerRef\n手动执行与 shallowRef 关联的任何作用 (effect)。\n如果使用了shallowRef想要只更新某一层的数据可以使用triggerRef，页面就会重新渲染","reference":"参考资料|https://www.yisu.com/zixun/604877.html","dot":"#c184ff"},{"prefix":"","tag":"toRaw","suffix":"(ref)","desc":"返回 reactive 或 readonly 代理的原始对象。\n从proxy中拿到原始数据","url":"","summary":"","reference":"","dot":"#c184ff"},{"prefix":"","tag":"reactive","suffix":"(raw)","desc":"创建引用类型的响应式数据。\n响应式转换是“深层”的——它影响所有嵌套 property。在基于 ES2015 Proxy 的实现中，返回的 proxy 是不等于原始对象的。建议只使用响应式 proxy，避免依赖原始对象。\nReactive的本质是将每一层的数都解析成proxy对象，Reactive 的响应式默认都是递归的，改变某一层的值都会递归的调用一遍，重新渲染dom。\n\n# shallowReactive\n`shallowReactive(val)` 创建一个非深层响应式代理，shallowReactive创建的数据第一层数据改变会重新渲染dom。","url":"","summary":"","reference":"","dot":"#c184ff"},{"prefix":"","tag":"readonly","suffix":"(val)","desc":"接受一个对象 (响应式或纯对象) 或 ref 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。","url":"","summary":"","reference":"","dot":"#c184ff"},{"prefix":"","tag":"toRefs","suffix":"(ref)","desc":"将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。\n当从组合式函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应性的情况下对返回的对象进行解构/展开。\n```javascript\nconst state = reactive({\n  foo: 1,\n  bar: 2\n})\nconst fooRef = toRef(state, 'foo')\nconst fooRef = toRefs(state)\n```","url":"","summary":"","reference":"","dot":"#c184ff"},{"prefix":"","tag":"computed","suffix":"","desc":"# 独立的 computed 属性\n```\nconst count = ref(1)\n//接受一个 getter 函数，并根据 getter 的返回值返回一个不可变的响应式 ref 对象。\nconst plusOne = computed(() => count.value + 1)\n//接受一个具有 get 和 set 函数的对象，用来创建可写的 ref 对象。\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: val => {\n    count.value = val - 1\n  }\n})\n//通过.value获取值\nconsole.log(plusOne.value)\n```\n","url":"","summary":"","reference":"","dot":"#ffa500"},{"prefix":"","tag":"watch","suffix":"","desc":"# setup响应式更改\n就像我们在组件中使用 watch 选项并在 user property 上设置侦听器一样，我们也可以使用从 Vue 导入的 watch 函数执行相同的操作。它接受 3 个参数：\n+ 一个想要侦听的响应式引用或 getter 函数\n+ 一个回调callback(newValue,oldValue)\n+ 可选的配置选项options\n```\nimport { ref, watch } from 'vue'\nconst counter = ref(0)\nwatch(counter, (newValue, oldValue) => {\n  console.log('The new counter value is: ' + counter.value)\n})\n```\n\n# 选项\n新增选项：`flush:'sync'`\n+ 'pre'（默认），指定的回调应该在渲染前被调用。它允许回调在模板运行前更新了其他值。\n+ 'post' 值是可以用来将回调推迟到渲染之后的。如果回调需要通过 $refs 访问更新的 DOM 或子组件，那么则使用该值。\n+ 'sync'，一旦值发生了变化，回调将被同步调用。\n\n对于 'pre' 和 'post'，回调使用队列进行缓冲（默认只会在条件下一次，回调完成前监听不会再触发。）。回调只被添加到队列中一次，即使观察值变化了多次。值的中间变化将被跳过，不会传递给回调。","url":"","summary":"","reference":"API参考文档|https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%88%B7%E6%96%B0%E6%97%B6%E6%9C%BA","dot":"#ffa500"}]},{"title":"选项","fold":false,"list":[{"prefix":"","tag":"methods","suffix":"","desc":"methods 将被混入到组件实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为组件实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mixins","suffix":"","desc":"# 局部混入 \n`mixins: [myMixin,..]`\n# 全局混入 \n\n`Vue.mixin(myMixin)`\n当组件和混入对象含有同名选项时，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。\n同名钩子函数将合并为一个数组，都将被调用，混入对象的钩子将在组件自身钩子之前调用。","url":"","summary":"","reference":"自定义选项合并策略|https://v3.cn.vuejs.org/guide/mixins.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5","dot":""},{"prefix":"","tag":"extends","suffix":"","desc":"允许一个组件扩展到另一个组件，且继承该组件选项。\n```\nconst CompA = { ... }\n\nconst CompB = {\n  extends: CompA,\n  ...\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"setup","suffix":"(props,context)","desc":"返回的内容将在实例中可用。\n因为 props 是响应式的，你不能使用 ES6 解构，它会消除 prop 的响应性。\n\n执行 setup 时，你只能访问以下 property：\n+ props\n+ attrs\n+ slots\n+ emit\n\n在script steup中可以使用顶层 await，结果代码会被编译成 async setup()","url":"","summary":"","reference":"","dot":"#ff0000"},{"prefix":"","tag":"expose","suffix":"","desc":"`expose: ['increment'],`\n一个将暴露在公共组件实例上的 property 列表。\n当设置了后，没有暴露的数据将不能被外部直接访问到。\n\n# setup应用\n当setup返回一个渲染函数时，可通过expose暴露数据或方法。\n```\nimport { h, ref } from 'vue'\nexport default {\n  setup(props, { expose }) {\n    const count = ref(0)\n    const increment = () => ++count.value\n\n    expose({\n      increment\n    })\n\n    return () => h('div', count.value)\n  }\n}\n```","url":"","summary":"","reference":"参考资料|https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E4%BD%BF%E7%94%A8%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0\nAPI文档|https://v3.cn.vuejs.org/api/options-data.html#expose","dot":"#a6e22e"}]},{"title":"表单","fold":false,"list":[{"prefix":"","tag":"v-model","suffix":"","desc":"`<input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\">`","url":"","summary":"# select 注意事项\n添加一个初始化为空的禁用项 `<option disabled value=\"\">请选择</option>`","reference":"select注意事项|https://cn.vuejs.org/v2/guide/forms.html#%E9%80%89%E6%8B%A9%E6%A1%86","dot":""},{"prefix":"v-model","tag":".lazy","suffix":"","desc":"在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步","url":"","summary":"","reference":"","dot":""},{"prefix":"v-model","tag":".number","suffix":"","desc":"如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"v-model","tag":".trim","suffix":"","desc":"如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"","tag":"@[event]","suffix":"","desc":"支持多事件处理器\n`<button @click=\"one($event), two($event)\">submit</button>`\n*移除.native修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".once","suffix":"","desc":"只触发一次回调。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".stop","suffix":"","desc":"阻止冒泡，调用 event.stopPropagation()。\n修饰符可以串联","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".capture","suffix":"","desc":"添加事件侦听器时使用 capture 模式。\n即内部元素触发的事件先在此处理，然后才交由内部元素进行处理","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".self","suffix":"","desc":"只当事件是从侦听器绑定的元素本身触发时才触发回调。\n用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".prevent","suffix":"","desc":"阻止默认事件，调用 event.preventDefault()。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".passive","suffix":"","desc":"以 { passive: true } 模式添加侦听器\n`<div v-on:scroll.passive=\"onScroll\">...</div>`\n滚动事件的默认行为 (即滚动行为) 将会立即触发，而不会等待 `onScroll` 完成。\n这个 .passive 修饰符尤其能够提升移动端的性能。\n不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。","url":"","summary":"","reference":"","dot":""},{"prefix":"@KeyboardEvent","tag":".$key","suffix":"","desc":"`<input v-on:keyup.enter=\"submit\">` 按键事件\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right","url":"","summary":"","reference":"key values|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values","dot":""},{"prefix":"@click","tag":".left/right/middle","suffix":"","desc":"鼠标点击事件修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".ctrl/alt/shift/meta","suffix":"","desc":"系统修饰键，可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。\n\nMac:meta 对应 command 键 (⌘)。\nWin:meta 对应 Windows 徽标键 (⊞)。\n\n`<div v-on:click.ctrl=\"doSomething\">Do something</div>`","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".exact","suffix":"","desc":"```\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button v-on:click.exact=\"onClick\">A</button>\n```","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Vue3指令","barcolor":"","fold":false,"box":[{"title":"注册指令","fold":false,"list":[{"prefix":"","tag":"directives","suffix":"","desc":"调用 `v-$cmd.$modifier:$arg=\"$value\"`\n需要对部分dom元素绑定格式化操作或交互行为。\n**当在组件中使用时，自定义指令总是会被应用在组件的根节点上。\n当被应用在一个多根节点的组件上时，指令会被忽略，并且会抛出一个警告。**\n\n# 局部注册\n```\ndirectives: {\n  //指令名称\n  $cmd: {\n    //钩子函数\n    $hook: function (el,binding,vnode,oldVnode) {\n       //DOM操作\n    }\n  }\n}\n```\n# 局部注册（简写）\n默认绑到mounted和updated钩子上\n```\ndirectives: {\n  $cmd: function (el,binding,vnode,oldVnode) {\n     //DOM操作\n  }\n}\n```","url":"","summary":"","reference":"自定义实例|https://segmentfault.com/a/1190000038475001","dot":""},{"prefix":"","tag":"Vue.directive","suffix":"(opt)","desc":"# 全局注册\n`Vue.directive($cmd,opt)`","url":"","summary":"","reference":"官方文档|https://cn.vuejs.org/guide/reusability/custom-directives.html#directive-hooks","dot":""},{"prefix":"","tag":"v","suffix":"NameOfDirective","desc":"在setup中，必须以 vNameOfDirective 的形式来命名本地自定义指令，以使得它们可以直接在模板中使用。\n\n```\nscript setup>\nconst vMyDirective = {\n  beforeMount: (el) => {\n    // 在元素上做些操作\n  }\n}\n</script>\n<template>\n  <h1 v-my-directive>This is a Heading</h1>\n</template>\n\n<script setup>\n  // 导入的指令同样能够工作，并且能够通过重命名来使其符合命名规范\n  import { myDirective as vMyDirective } from './MyDirective.js'\n</script>\n```","url":"","summary":"","reference":"","dot":"#c184ff"}]},{"title":"钩子函数","fold":false,"list":[{"prefix":"","tag":"created","suffix":"","desc":"在绑定元素的 attribute 或事件监听器被应用之前调用","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeMount","suffix":"","desc":"在绑定元素的父组件挂载之前调用","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mounted","suffix":"","desc":"在绑定元素的父组件挂载之后调用","url":"","summary":"","reference":"","dot":"#a6e22e"},{"prefix":"","tag":"beforeUpdate","suffix":"","desc":"在包含组件的 VNode 更新之前调用","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"updated","suffix":"","desc":"在包含组件的 VNode 及其子组件的 VNode 更新之后调用","url":"","summary":"","reference":"","dot":"#a6e22e"},{"prefix":"","tag":"beforeUnmount","suffix":"","desc":"在绑定元素的父组件卸载之前调用","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"unmounted","suffix":"","desc":"在绑定元素的父组件卸载之后调用","url":"","summary":"","reference":"","dot":""}]},{"title":"钩子参数","fold":false,"list":[{"prefix":"","tag":"el","suffix":"","desc":"el：指令所绑定的元素，可以用来直接操作 DOM。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"instance","suffix":"","desc":"使用指令的组件实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"value","suffix":"","desc":"指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"oldValue","suffix":"","desc":"先前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否有更改都可用。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"arg","suffix":"","desc":"传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"modifiers","suffix":"","desc":"modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。","url":"","summary":"","reference":"","dot":""},{"prefix":"binding.","tag":"dir","suffix":"","desc":"一个对象，在注册指令时作为参数传递。","url":"","summary":"例如，在以下指令中\n```\napp.directive('focus', {\n  mounted(el) {\n    el.focus()\n  }\n})\n```\ndir 将会是以下对象：\n```\n{\n  mounted(el) {\n    el.focus()\n  }\n}\n```","reference":"","dot":""},{"prefix":"","tag":"vnode","suffix":"","desc":"一个真实 DOM 元素的蓝图，对应上面收到的 el 参数。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"prevNode","suffix":"","desc":"上一个虚拟节点，仅在 beforeUpdate 和 updated 钩子中可用。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue2组件","barcolor":"","fold":false,"box":[{"title":"注册","fold":false,"list":[{"prefix":"","tag":"Vue.component","suffix":"(name,opt)","desc":"每个组件必须只有一个根元素","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"components","suffix":"","desc":"注意局部注册的组件在其子组件中不可用。\n```\ncomponents: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"functional","suffix":"","desc":"函数式组件","url":"","summary":"使组件无状态 (没有 data) 和无实例 (没有 this 上下文)。他们用一个简单的 render 函数返回虚拟节点使它们渲染的代价更小。","reference":"参考资料|https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6","dot":""}]},{"title":"属性","fold":false,"list":[{"prefix":"","tag":"props","suffix":"","desc":"单向数据流（实际上引用对象仍为响应式）\n```\nprops:['a','b']\nprops:{\n   test: {\n      type: String,  //支持自定义构造函数（使用instanceof验证）\n      required: true,\n      default: 100,\n      validator ： fn(val)\n   },\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind=","suffix":"\"propObj\"","desc":"将整个对象的全部属性都作为props传入","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$attrs","suffix":"","desc":"$attrs包含所有传递给子组件的全部属性（不包括prop,class,style），默认根节点继承，可设置`inheritAttrs:false`禁用，通过v-bind=\"$attrs\"给其他元素绑定。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"provide/inject","suffix":"","desc":"provide，子组件可作为属性读取，基本类型数据无响应更新。\n```\nprovide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n```\n\ninject\n```\ninject: {\n    foo: {\n      from: 'bar', //原始provide属性名不同名\n      default: 'foo',\n      default: () => [1, 2, 3] //与 prop 的默认值类似，你需要对非原始值使用一个工厂方法\n    }\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"动态组件","fold":false,"list":[{"prefix":"component ","tag":":is","suffix":"=\"$component\"","desc":"`<component v-bind:is=\"currentView\"></component>` 当 `currentView` 改变时，组件也跟着改变","url":"","summary":"","reference":"参考文档|https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6","dot":""},{"prefix":"tag ","tag":"is=","suffix":"\"$component\"","desc":"有些 HTML 元素，诸如 ul、ol、table 和 select，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 li、tr 和 option，只能出现在其它某些特定的元素内部。\n```\n<table>\n  <tr is=\"my-row\"></tr>\n</table>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"keep-alive","suffix":"","desc":"# 用途\n保持这些组件的状态，以避免反复重新渲染导致的性能问题。\n一般用于多个直属子组件（不应包含内容每次需要变更的组件）。\n默认只能有1个子组件处于激活状态。\n\n# 参数\n+ include - 字符串或正则表达式或数组。只有名称匹配的组件会被缓存。\n+ exclude - 字符串或正则表达式或数组。任何名称匹配的组件都不会被缓存。\n+ max - 数字。最多可以缓存多少组件实例。\n\n# 注意事项\n1.不能为匿名组件\n2.设置了Max后，达到最大值在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。\n3.不会在函数式组件中正常工作，因为它们没有缓存实例。\n4.用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，keep-alive>要求同时只有一个子元素被渲染。\n5.当组件在keep-alive内被切换时，它的 mounted 和 unmounted 生命周期钩子不会被调用（除首次挂载），取而代之的是 activated 和 deactivated。","url":"","summary":"","reference":"API参考文档|https://cn.vuejs.org/v2/api/#keep-alive","dot":""}]},{"title":"异步组件","fold":false,"list":[{"prefix":"","tag":"Vue.component","suffix":"","desc":"全局异步组件注册\n## 方法一\n```\nVue.component(\n  'async-webpack-example',\n  // 这个动态导入会返回一个 `Promise` 对象。\n  () => import('./my-async-component')\n)\n```\n\n# 方法二\n```\nVue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 `require` 语法将会告诉 webpack\n  // 自动将你的构建代码切割成多个包，这些包\n  // 会通过 Ajax 请求加载\n  require(['./my-async-component'], resolve)\n})\n```\n\n# 方法三\n```\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // 向 `resolve` 回调传递组件定义\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"components","suffix":"","desc":"局部注册异步组件。\n默认将组件限制不要渲染，例如v-if\n```\ncomponents: {\n    'my-component': () => import('./my-async-component')\n}\n```\n\n# 加载状态\n这里的异步组件工厂函数也可以返回一个如下格式的对象：\n```\nconst AsyncComponent = () => ({\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n})\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"vm","tag":".$emit","suffix":"(e,...payload)","desc":"子组件触发事件","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"@[event]","suffix":"=handler($event)","desc":"父组件监听事件\n+ 没有参数时，传递事件参数\n+ 指定参数时，传递指定参数\n+ 指定参数和$event时，传递指定参数和event事件对象","url":"","summary":"","reference":"参考资料|https://blog.csdn.net/a1059526327/article/details/108768224","dot":""},{"prefix":"vm","tag":".$once","suffix":"(e,cb(payload))","desc":"监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"vm","tag":".$on","suffix":"(e,cb)","desc":"监听当前实例上的自定义事件。\n可创建一个空Vue对象作为Bus总线。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"vm","tag":".$off","suffix":"([e,cb])","desc":"移除自定义事件监听器。\n+ 如果没有提供参数，则移除所有的事件监听器；\n+ 如果只提供了事件，则移除该事件所有的监听器；\n+ 如果同时提供了事件与回调，则只移除这个回调的监听器。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"","tag":"v-model","suffix":"","desc":"```\nprops : ['someprop'],  //传入属性名称\nmodel: {\n    prop: 'someprop',  //设置需要向上同步的属性\n    event: 'eventname' //设置触发更新的事件\n},\nmethods : {\n    fn : function(){\n         this.$emit('eventname',newval)\n    }\n}\n```\n一个组件上的 v-model 默认会利用名为 **value** 的 prop 和名为 **input** 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。","url":"","summary":"","reference":"API文档|https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model","dot":"#ff0000"},{"prefix":":prop","tag":".sync","suffix":"","desc":"会扩展成一个更新父组件绑定值的 v-on 侦听器。\n`<text-document v-bind.sync=\"doc\"></text-document>` 多个prop\n`this.$emit('update:propname')` 需要通过此事件触发更新","url":"","summary":"","reference":"","dot":"#ff0000","title":"事件"}]},{"title":"插槽","fold":false,"list":[{"prefix":"","tag":"slot","suffix":"","desc":"# 子组件定义插槽\n`<slot>default</slot>`\n不具名插槽，一个不带 name 的 <slot> 出口会带有隐含的名字“default”。\n# 父组件使用插槽\n该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而不能访问被插入组件作用域。\n如果组件的 template 中没有包含一个 <slot> 元素，则引用该组件起始标签和结束标签之间的任何内容都会被抛弃。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"slot name=\"$name\"","suffix":"","desc":"# 子组件中定义插槽\n`<slot name=\"$name\"></slot>`\n# 父组件中使用插槽\n`<template v-slot:$name></template>`\n或缩写\n`<template #name></template>`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-slot:default","suffix":"=\"slotProps\"","desc":"# 子组件传递插槽属性 \n`<slot v-bind:prop=\"data\"></slot>`\n# 父组件插槽使用属性 \n`<template v-slot:default=\"slotProps\"></template>` （可使用解构）","url":"","summary":"","reference":"","dot":""}]},{"title":"边界情况","fold":false,"list":[{"prefix":"","tag":"$root","suffix":"","desc":"当前组件树的根组件实例","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$parent","suffix":"","desc":"父实例","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"ref","suffix":"","desc":"在指定组件上定义`ref=<name>`，并使用`this.$refs.<name>`访问组件实例 或 **DOM元素**。\n**$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。**","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$forceUpdate","suffix":"()","desc":"迫使 Vue 实例重新渲染。\n注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$nextTick","suffix":"(cb)","desc":"回调函数将在 DOM 更新完成后被调用\n`Vue.nextTick(callback)` 或 `vm.$nextTick()`","url":"","summary":"","reference":"","dot":""}]},{"title":"过渡动画","fold":false,"list":[{"prefix":"","tag":"transition ","suffix":"","desc":"用于单个节点或同一时间渲染多个节点中的一个\nVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡\n+ 条件渲染 (使用 v-if)\n+ 条件展示 (使用 v-show)\n+ 动态组件\n+ 组件根节点\n\n","url":"","summary":"<img style=\"max-width:100%\" src=\"https://cn.vuejs.org/images/transition.png\" />","reference":"API文档|https://cn.vuejs.org/v2/api/#transition","dot":""},{"prefix":"","tag":"transition-group ","suffix":"[tag=ul]","desc":"不同于 transition，它会以一个真实元素呈现：默认为一个 span。你也可以通过 tag attribute 更换为其他元素。\n过渡模式不可用，因为我们不再相互切换特有的元素。\n内部元素总是需要提供唯一的 key attribute 值。\nCSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"name","suffix":"=\"$ani\"","desc":"对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 transition，则 v- 是这些类名的默认前缀。如果你使用了name，那么 v-enter 会替换为对应的name-。","url":"","summary":"","reference":"","dot":""},{"prefix":"$state","tag":"-class","suffix":"=\"$ani\"","desc":"我们可以通过以下 attribute 来自定义过渡类名：\nenter-class\nenter-active-class\nenter-to-class (2.1.8+)\nleave-class\nleave-active-class\nleave-to-class (2.1.8+)\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mode","suffix":"=\"in-out\"","desc":"+ in-out：新元素先进行过渡，完成之后当前元素过渡离开。\n+ out-in：当前元素先进行过渡，完成之后新元素过渡进入。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"type","suffix":"=\"animation/transition\"","desc":"Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。\n\n但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type attribute 并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"duration","suffix":"=\"$time\"","desc":"在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。\n\n在这种情况下你可以用 <transition> 组件上的 duration prop 定制一个显性的过渡持续时间 (以毫秒计)：\n`<transition :duration=\"1000\">...</transition>`\n你也可以定制进入和移出的持续时间：\n`<transition :duration=\"{ enter: 500, leave: 800 }\">...</transition>`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-on:$state","suffix":"=fn","desc":"可以在 attribute 中声明 JavaScript 钩子。\n# done回调\n当只用 JavaScript 过渡的时候，**在 enter 和 leave 中必须使用 done 进行回调**。否则，它们将被同步调用，过渡会立即完成。\n```\nenter: function (el, done) {\n      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })\n      Velocity(el, { fontSize: '1em' }, { complete: done })\n},\n```\n\n\n```\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n```\n\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"css","suffix":"=false","desc":"# 禁用css过渡\n推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css=\"false\"`，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"appear","suffix":"","desc":"可以通过 appear attribute 设置节点在初始渲染的过渡\n\n# css类\n这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。\n```\n<transition\n  appear\n  appear-class=\"custom-appear-class\"\n  appear-to-class=\"custom-appear-to-class\" (2.1.8+)\n  appear-active-class=\"custom-appear-active-class\"\n>\n  <!-- ... -->\n</transition>\n```\n\n# 自定义 JavaScript 钩子\n在上面的例子中，无论是 appear attribute 还是 v-on:appear 钩子都会生成初始渲染过渡。\n```\n<transition\n  appear\n  v-on:before-appear=\"customBeforeAppearHook\"\n  v-on:appear=\"customAppearHook\"\n  v-on:after-appear=\"customAfterAppearHook\"\n  v-on:appear-cancelled=\"customAppearCancelledHook\"\n>\n  <!-- ... -->\n</transition>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"enter","suffix":"","desc":"v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"enter-active","suffix":"","desc":"定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"enter-to","suffix":"","desc":"定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"leave","suffix":"","desc":"定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"leave-active","suffix":"","desc":"定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"leave-to","suffix":"","desc":"定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"move","suffix":"","desc":"仅transition-group中可用。\nv-move class，它会在元素的改变定位的过程中应用\n可以通过 name attribute 来自定义前缀\n也可以通过 move-class attribute 手动设置。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue3组件","barcolor":"","fold":false,"box":[{"title":"注册","fold":false,"list":[{"prefix":"app","tag":".component","suffix":"(name,opt)","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"components","suffix":"","desc":"注意局部注册的组件在其子组件中不可用。\n```\ncomponents: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"属性","fold":false,"list":[{"prefix":"","tag":"props","suffix":"","desc":"```\nprops:['a','b']\nprops:{\n   test: {\n      type: String,  //支持自定义构造函数（使用instanceof验证）\n      required: true,\n      default: 100,\n      validator ： fn(val)\n   },\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"defineProps","suffix":"(val)","desc":"在 setup中必须使用 defineProps 来声明 props\n```\nconst props = defineProps({\n  foo: String\n})\n```","url":"","summary":"","reference":"","dot":"#c184ff"},{"prefix":"","tag":"v-bind=","suffix":"\"propObj\"","desc":"将整个对象的全部属性都作为props传入","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$attrs","suffix":"","desc":"$attrs包含所有传递给子组件的全部属性（包括class,style），默认根节点继承，可设置`inheritAttrs:false`禁用，通过v-bind=\"$attrs\"给其他元素绑定。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"provide/inject","suffix":"","desc":"# setup\n```\n//上级组件\nprovide(key,ref(val))\n\n//子孙组件\ninject(key,[default])\n```\n有时我们需要在注入数据的组件内部更新 inject 的数据。在这种情况下，我们建议 provide 一个方法来负责改变响应式 property。\n\n# 默认\n我们可以通过传递一个 ref property 或 reactive 对象给 provide使其提供的数据是响应式的。\n```\nprovide() {\n    return {\n      todoLength: Vue.computed(() => this.todos.length)\n    }\n}\n```","url":"","summary":"","reference":"参考文档|https://v3.cn.vuejs.org/guide/composition-api-provide-inject.html#%E4%BF%AE%E6%94%B9%E5%93%8D%E5%BA%94%E5%BC%8F-property","dot":"#ffa500"},{"prefix":"app.config.","tag":"globalProperties","suffix":"","desc":"添加一个可以在应用的任何组件实例中访问的全局 property。\n组件的 property 在命名冲突时具有优先权。\n```\napp.config.globalProperties.foo = 'bar'\n\napp.component('child-component', {\n  mounted() {\n    console.log(this.foo) // 'bar'\n  }\n})\n```","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/application-config.html#globalproperties","dot":""}]},{"title":"动态组件","fold":false,"list":[{"prefix":"component ","tag":":is","suffix":"=\"$component\"","desc":"`<component v-bind:is=\"currentView\"></component>` 当 `currentView` 改变时，组件也跟着改变","url":"","summary":"","reference":"参考文档|https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6","dot":""},{"prefix":"tag ","tag":"is=","suffix":"\"$component\"","desc":"有些 HTML 元素，诸如 ul、ol、table 和 select，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 li、tr 和 option，只能出现在其它某些特定的元素内部。\n```\n<table>\n  <tr is=\"my-row\"></tr>\n</table>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"keep-alive","suffix":"","desc":"# 用途\n保持这些组件的状态，以避免反复重新渲染导致的性能问题。\n一般用于多个直属子组件（不应包含内容每次需要变更的组件）。\n默认只能有1个子组件处于激活状态。\n\n# 参数\n+ include - 字符串或正则表达式或数组。只有名称匹配的组件会被缓存。\n+ exclude - 字符串或正则表达式或数组。任何名称匹配的组件都不会被缓存。\n+ max - 数字。最多可以缓存多少组件实例。\n\n# 注意事项\n1.不能为匿名组件\n2.设置了Max后，达到最大值在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。\n3.不会在函数式组件中正常工作，因为它们没有缓存实例。\n4.用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，keep-alive>要求同时只有一个子元素被渲染。\n5.当组件在keep-alive内被切换时，它的 mounted 和 unmounted 生命周期钩子不会被调用（除首次挂载），取而代之的是 activated 和 deactivated。","url":"","summary":"","reference":"API参考文档|https://cn.vuejs.org/v2/api/#keep-alive","dot":""}]},{"title":"异步组件","fold":false,"list":[{"prefix":"","tag":"components","suffix":"","desc":"异步组件需要通过将其包裹在新的 defineAsyncComponent 助手方法中来显式地定义\n```\nimport { defineAsyncComponent } from 'vue'\nimport ErrorComponent from './components/ErrorComponent.vue'\nimport LoadingComponent from './components/LoadingComponent.vue'\n\n// 不带选项的异步组件\nconst asyncModal = defineAsyncComponent(() => import('./Modal.vue'))\n\n// 带选项的异步组件\nconst asyncModalWithOptions = defineAsyncComponent({\n  loader: () => import('./Modal.vue'),\n  delay: 200,\n  timeout: 3000,\n  errorComponent: ErrorComponent,\n  loadingComponent: LoadingComponent\n})\n```","url":"","summary":"# Suspense\n异步组件在默认情况下是可挂起的。这意味着如果它在父链中有一个 <Suspense>，它将被视为该 <Suspense> 的异步依赖。在这种情况下，加载状态将由 <Suspense> 控制，组件自身的加载、错误、延迟和超时选项都将被忽略。\n\n通过在其选项中指定 suspensible: false，异步组件可以退出 Suspense 控制，并始终控制自己的加载状态。","reference":"","dot":"#ff0000"},{"prefix":"app","tag":".component","suffix":"","desc":"显示声明后，注册全局异步组件","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"suspense","suffix":"","desc":"```\n<suspense>\n    <template #default>\n        <component :is=\"Component\"></component>\n    </template>\n    <template #fallback>\n        <div>Loading...</div>\n    </template>\n</suspense>\n```","url":"","summary":"","reference":"","dot":"#a6e22e"}]},{"title":"事件","fold":false,"list":[{"prefix":"vm","tag":".$emit","suffix":"(e,...payload)","desc":"子组件触发事件","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"@event","suffix":"=handler($event)","desc":"监听组件事件","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"emits","suffix":"","desc":"`emits: ['inFocus', 'submit']` \n`emits: {eventname : (args)=>{return true}}`\n可以通过 emits 选项在组件上定义发出的事件。可以设置验证器。","url":"","summary":"# 验证抛出的事件\n与 prop 类型验证类似，如果使用对象语法而不是数组语法定义发出的事件，则可以对它进行验证。\n要添加验证，请为事件分配一个函数，该函数接收传递给 $emit 调用的参数，并返回一个布尔值以指示事件是否有效。\n```\napp.component('custom-form', {\n  emits: {\n    // 没有验证\n    click: null,\n\n    // 验证 submit 事件\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n})\n```","reference":"","dot":"#a6e22e"},{"prefix":"","tag":"defineEmits","suffix":"([events,..])","desc":"在setup中必须使用 defineEmits API 来声明 emits\n```\nconst emit = defineEmits(['change', 'delete'])\n```","url":"","summary":"","reference":"","dot":"#c184ff"},{"prefix":"","tag":"v-model","suffix":"","desc":"默认情况下，组件上的 v-model 使用 **modelValue** 作为 prop 和 **update:modelValue** 作为事件。\n# 可以使用多个v-model\n```\n<user-name\n  v-model:first-name=\"firstName\"\n  v-model:last-name=\"lastName\"\n></user-name>\n```","url":"","summary":"```\napp.component('user-name', {\n  props: {\n    firstName: String,\n    lastName: String\n  },\n  emits: ['update:firstName', 'update:lastName'],\n  template: `\n    <input \n      type=\"text\"\n      :value=\"firstName\"\n      @input=\"$emit('update:firstName', $event.target.value)\">\n\n    <input\n      type=\"text\"\n      :value=\"lastName\"\n      @input=\"$emit('update:lastName', $event.target.value)\">\n  `\n})\n```","reference":"","dot":"#ff0000"},{"prefix":"[$prop|model]","tag":"Modifiers","suffix":"","desc":"自定义v-model修饰符\n```\nprops: {\n    modelValue: String,\n    modelModifiers: {  //默认\n      default: () => ({})\n    }\n},\nprops: ['description', 'descriptionModifiers'], //多个\n\nif (this.modelModifiers.capitalize) {\n   value = value.charAt(0).toUpperCase() + value.slice(1)\n}\n```","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/guide/component-custom-events.html#%E5%A4%84%E7%90%86-v-model-%E4%BF%AE%E9%A5%B0%E7%AC%A6","dot":"#a6e22e"}]},{"title":"插槽","fold":false,"list":[{"prefix":"","tag":"slot","suffix":"","desc":"# 子组件定义插槽\n`<slot>default</slot>`\n不具名插槽，一个不带 name 的 <slot> 出口会带有隐含的名字“default”。\n# 父组件使用插槽\n该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而不能访问被插入组件作用域。\n如果组件的 template 中没有包含一个 <slot> 元素，则引用该组件起始标签和结束标签之间的任何内容都会被抛弃。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"slot name=\"$name\"","suffix":"","desc":"# 子组件中定义插槽\n`<slot name=\"$name\"></slot>`\n# 父组件中使用插槽\n`<template v-slot:$name></template>`\n或缩写\n`<template #name></template>`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-slot:default","suffix":"=\"slotProps\"","desc":"# 子组件传递插槽属性 \n`<slot v-bind:prop=\"data\"></slot>`\n# 父组件插槽使用属性 \n`<template v-slot:default=\"slotProps\"></template>` （可使用解构）","url":"","summary":"","reference":"","dot":""}]},{"title":"边界情况","fold":false,"list":[{"prefix":"","tag":"$root","suffix":"","desc":"当前组件树的根组件实例","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$parent","suffix":"","desc":"父实例","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"ref","suffix":"","desc":"在指定组件上定义`ref=<name>`，并使用`this.$refs.<name>`访问组件实例 或 **DOM元素**。\n**$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。**","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$forceUpdate","suffix":"()","desc":"迫使 Vue 实例重新渲染。\n注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$nextTick","suffix":"","desc":"返回一个promise","url":"","summary":"","reference":"","dot":"#ffa500"},{"prefix":"","tag":"teleport","suffix":"","desc":"控制在 DOM 中哪个父节点下渲染了 HTML\n```\n<teleport to=\"body\" :disabled=\"false\">\n...\n</teleport>\n```","url":"","summary":"","reference":"API文档：https://v3.cn.vuejs.org/api/built-in-components.html#teleport","dot":"#a6e22e"}]},{"title":"过渡动画","fold":false,"list":[{"prefix":"","tag":"transition","suffix":"","desc":"Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡\n+ 条件渲染 (使用 v-if)\n+ 条件展示 (使用 v-show)\n+ 动态组件\n+ 组件根节点","url":"","summary":"<img style=\"max-width:100%;background:#fff\" src=\"https://v3.cn.vuejs.org/images/transitions.svg\" />","reference":"API文档|https://v3.cn.vuejs.org/api/built-in-components.html#transition","dot":""},{"prefix":"","tag":"transition-group ","suffix":"[tag=ul]","desc":"不同于 transition，它会以一个真实元素呈现：默认为一个 span。你也可以通过 tag attribute 更换为其他元素。\n过渡模式不可用，因为我们不再相互切换特有的元素。\n内部元素总是需要提供唯一的 key attribute 值。\nCSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"name","suffix":"=\"$ani\"","desc":"对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 transition，则 v- 是这些类名的默认前缀。如果你使用了name，那么 v-enter 会替换为对应的name-。","url":"","summary":"","reference":"","dot":""},{"prefix":"$state","tag":"-class","suffix":"=\"$ani\"","desc":"我们可以通过以下 attribute 来自定义过渡类名：\nenter-from-class\nenter-active-class\nenter-to-class\nleave-from-class\nleave-active-class\nleave-to-class\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mode","suffix":"=\"in-out\"","desc":"+ in-out：新元素先进行过渡，完成之后当前元素过渡离开。\n+ out-in：当前元素先进行过渡，完成之后新元素过渡进入。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"type","suffix":"=\"animation/transition\"","desc":"Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。\n\n但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type attribute 并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"duration","suffix":"=\"$time\"","desc":"在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。\n\n在这种情况下你可以用 <transition> 组件上的 duration prop 定制一个显性的过渡持续时间 (以毫秒计)：\n`<transition :duration=\"1000\">...</transition>`\n你也可以定制进入和移出的持续时间：\n`<transition :duration=\"{ enter: 500, leave: 800 }\">...</transition>`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-on:$state","suffix":"=fn","desc":"可以在 attribute 中声明 JavaScript 钩子。\n# done回调\n当只用 JavaScript 过渡的时候，**在 enter 和 leave 中必须使用 done 进行回调**。否则，它们将被同步调用，过渡会立即完成。\n```\nenter: function (el, done) {\n      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })\n      Velocity(el, { fontSize: '1em' }, { complete: done })\n},\n```\n\n\n```\n<transition\n  @before-enter=\"beforeEnter\"\n  @enter=\"enter\"\n  @after-enter=\"afterEnter\"\n  @enter-cancelled=\"enterCancelled\"\n  @before-leave=\"beforeLeave\"\n  @leave=\"leave\"\n  @after-leave=\"afterLeave\"\n  @leave-cancelled=\"leaveCancelled\"\n  :css=\"false\"\n>\n  <!-- ... -->\n</transition>\n```\n\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"css","suffix":"=false","desc":"# 禁用css过渡\n推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css=\"false\"`，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"appear","suffix":"","desc":"可以通过 appear attribute 设置节点在初始渲染的过渡\n\n# css类\n这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。\n```\n<transition\n  appear\n  appear-class=\"custom-appear-class\"\n  appear-to-class=\"custom-appear-to-class\" (2.1.8+)\n  appear-active-class=\"custom-appear-active-class\"\n>\n  <!-- ... -->\n</transition>\n```\n\n# 自定义 JavaScript 钩子\n在上面的例子中，无论是 appear attribute 还是 v-on:appear 钩子都会生成初始渲染过渡。\n```\n<transition\n  appear\n  v-on:before-appear=\"customBeforeAppearHook\"\n  v-on:appear=\"customAppearHook\"\n  v-on:after-appear=\"customAfterAppearHook\"\n  v-on:appear-cancelled=\"customAppearCancelledHook\"\n>\n  <!-- ... -->\n</transition>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"enter-from","suffix":"","desc":"定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"enter-active","suffix":"","desc":"定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"enter-to","suffix":"","desc":"定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/动画完成之后移除。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"leave-from","suffix":"","desc":"定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"leave-active","suffix":"","desc":"定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"leave-to","suffix":"","desc":"离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被移除)，在过渡/动画完成之后移除。","url":"","summary":"","reference":"","dot":""},{"prefix":"~","tag":"move","suffix":"","desc":"仅transition-group中可用。\nv-move class，它会在元素的改变定位的过程中应用\n可以通过 name attribute 来自定义前缀\n也可以通过 move-class attribute 手动设置。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vuex","barcolor":"","fold":false,"box":[{"title":"Init","fold":false,"list":[{"prefix":"vue vuex","tag":" ","suffix":"","desc":"```js\n// 1.Dependency\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\n\n// 2.Build An Store\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n\n// 3.Install Store\nnew Vue({\n  el: '#app',\n  store: store,\n})\n\n// 4.Use Store\nthis.$store.<fn|prop>\n```\n\n","url":"","summary":"","reference":"","dot":""}]},{"title":"store","fold":false,"list":[{"prefix":"","tag":"state","suffix":"","desc":"# state\n```\nstate : { ... }\nstore.state.xx\n```\n# mapState\n```javascript\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: {\n  localComputed () { /* ... */ },\n  ...mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n  }\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"getters","suffix":"","desc":"# getter\n```\ngetters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n}\n\nstore.getters.doneTodos\n```\n\n# mapGetters\n```\nimport { mapGetters } from 'vuex'\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n\n...mapGetters({\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mutations","suffix":"","desc":"# mutation\n```\nmutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n}\nstore.commit('increment',payload)\n```\n\n# mapMutations\n```\nimport { mapMutations } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"actions","suffix":"","desc":"# actions\n```\nactions: {\n  increment (context,payload) {\n    context.commit('increment')\n    return $promise\n  }\n}\nstore.dispatch('increment',payload).then()\n```\n\n# mapActions\n```\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"modules","suffix":"","desc":"# modules\n```\nconst moduleA = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Pinia","barcolor":"","fold":false,"box":[{"title":"Init","fold":false,"list":[{"prefix":"pinia=","tag":"createPinia()","suffix":"","desc":"```\nimport { createPinia } from 'pinia'\napp.use(createPinia())\n```","url":"","summary":"","reference":"参考资料|https://mp.weixin.qq.com/s/OiNd6vShudTntw4YULL45A\n官方文档|https://pinia.vuejs.org/introduction.html","dot":""},{"prefix":"store=","tag":"defineStore","suffix":"(options)","desc":"```\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore({\n  id: 'user', // id必填，且需要唯一\n  state: () => {\n    return {\n      name: '张三'\n    }\n  }\n})\n\nuseUserStore.name\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"state","fold":false,"list":[{"prefix":"store","tag":".key","suffix":"=val","desc":"可以直接修改值\n```\n<template>\n     <div>\n         <button @click=\"Add\">+</button>\n          <div>\n             {{Test.current}}\n          </div>\n     </div>\n</template>\n \n<script setup lang='ts'>\nimport {useTestStore} from './store'\nconst Test = useTestStore()\nconst Add = () => {\n    Test.current++\n}\n</script>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"storeToRefs","suffix":"(store)","desc":"直接结构会失去响应性\n```js\nimport { storeToRefs } from 'pinia'\nconst Test = useTestStore()\nconst { current, name } = storeToRefs(Test)\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mapState/mapWritableState","suffix":"(store,[keys])","desc":"批量引入\nmapState 只读，mapWritableState可写\n\n```js\nimport { mapState } from 'pinia'\nimport { useCounterStore } from '../stores/counterStore'\n\nexport default {\n  computed: {\n    // gives access to this.counter inside the component\n    // same as reading from store.counter\n    ...mapState(useCounterStore, ['counter'])\n    // same as above but registers it as this.myOwnName\n    ...mapState(useCounterStore, {\n      myOwnName: 'counter',\n      // you can also write a function that gets access to the store\n      double: store => store.counter * 2,\n      // it can have access to `this` but it won't be typed correctly...\n      magicValue(store) {\n        return store.someGetter + this.counter + this.double\n      },\n    }),\n  },\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"store","tag":".$patch","suffix":"(state)","desc":"批量修改\n```js\nconst Add = () => {\n    Test.$patch({\n       current:200,\n       age:300\n    })\n}\n```\n函数形式\n```js\nconst Add = () => {\n    Test.$patch((state)=>{\n       state.current++;\n       state.age = 40\n    })\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"store","tag":".$state","suffix":"=state","desc":"可以通过将store的属性设置为新对象来替换store的整个状态\n```js\nconst Test = useTestStore()\nconst Add = () => {\n    Test.$state = {\n       current:10,\n       age:30\n    }    \n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"store","tag":".$subscribe","suffix":"((mutation,state))","desc":"只要有state 的变化就会走这个函数\n$subscribe()与常规相比使用的优点watch()是订阅只会在补丁后触发一次（例如，使用上面的函数版本时）。\n```js\ncartStore.$subscribe((mutation, state) => {\n  // import { MutationType } from 'pinia'\n  mutation.type // 'direct' | 'patch object' | 'patch function'\n  // same as cartStore.$id\n  mutation.storeId // 'cart'\n  // only available with mutation.type === 'patch object'\n  mutation.payload // patch object passed to cartStore.$patch()\n\n  // persist the whole state to the local storage whenever it changes\n  localStorage.setItem('cart', JSON.stringify(state))\n})\n```\n如果你的组件卸载之后还想继续调用请设置第二个参数`detached:true`\n```js\nTest.$subscribe((args,state)=>{\n   console.log(args,state);\n},{\n  detached:true\n})\n```","url":"","summary":"","reference":"参考资料|https://pinia.vuejs.org/core-concepts/state.html#subscribing-to-the-state","dot":""}]},{"title":"actions","fold":false,"list":[{"prefix":"actions","tag":".fn","suffix":"(){this.key=val}","desc":"在actions 中直接使用this就可以指到state里面的值\n```\nimport { defineStore } from 'pinia'\nimport { Names } from './store-naspace'\nexport const useTestStore = defineStore(Names.TEST, {\n     state:()=>{\n         return {\n            current:1,\n            age:30\n         }\n     },\n \n     actions:{\n         setCurrent () {\n             this.current++\n         }\n     }\n})\n```\n使用方法直接在实例调用\n```\n<template>\n     <div>\n         <button @click=\"Add\">+</button>\n          <div>\n             {{Test.current}}\n          </div>\n          <div>\n            {{Test.age}}\n          </div>\n     </div>\n</template>\n \n<script setup lang='ts'>\nimport {useTestStore} from './store'\nconst Test = useTestStore()\nconst Add = () => {\n     Test.setCurrent()\n}\n</script>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mapActions","suffix":"(store,[actions])","desc":"批量映射为组件方法\n```\nimport { mapActions } from 'pinia'\nimport { useCounterStore } from '../stores/counterStore'\nexport default {\n  methods: {\n    // gives access to this.increment() inside the component\n    // same as calling from store.increment()\n    ...mapActions(useCounterStore, ['increment'])\n    // same as above but registers it as this.myOwnName()\n    ...mapActions(useCounterStore, { myOwnName: 'doubleCounter' }),\n  },\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"store","tag":".$onAction","suffix":"((action))","desc":"只要有actions被调用就会走这个函数\n```js\nTest.$onAction((args)=>{\n   console.log(args);\n})\n```","url":"","summary":"```js\nconst unsubscribe = someStore.$onAction(\n  ({\n    name, // name of the action\n    store, // store instance, same as `someStore`\n    args, // array of parameters passed to the action\n    after, // hook after the action returns or resolves\n    onError, // hook if the action throws or rejects\n  }) => {\n    // a shared variable for this specific action call\n    const startTime = Date.now()\n    // this will trigger before an action on `store` is executed\n    console.log(`Start \"${name}\" with params [${args.join(', ')}].`)\n\n    // this will trigger if the action succeeds and after it has fully run.\n    // it waits for any returned promised\n    after((result) => {\n      console.log(\n        `Finished \"${name}\" after ${\n          Date.now() - startTime\n        }ms.\\nResult: ${result}.`\n      )\n    })\n\n    // this will trigger if the action throws or returns a promise that rejects\n    onError((error) => {\n      console.warn(\n        `Failed \"${name}\" after ${Date.now() - startTime}ms.\\nError: ${error}.`\n      )\n    })\n  }\n)\n```\n默认情况下，操作订阅绑定到添加它们的组件（如果商店位于组件的 内部setup()）。意思是，当组件被卸载时，它们将被自动删除。如果要在卸载组件后保留它们，请true作为第二个参数传递以将操作订阅与当前组件分离。","reference":"","dot":""}]},{"title":"getters","fold":false,"list":[{"prefix":"store","tag":".key","suffix":"","desc":"## 箭头函数形式\n不能使用this，this指向已经改变指向undefined，修改值请用state\n```js\n    getters:{\n       newPrice : (state)=>  `${state.user.price}`\n    },\n```\n## 普通函数形式\n```js\n    getters:{\n       newCurrent () {\n           return ++this.current\n       }\n    },\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"other","fold":false,"list":[{"prefix":"store","tag":".$reset()","suffix":"","desc":"重置","url":"","summary":"","reference":"","dot":""},{"prefix":"pinia","tag":".use","suffix":"(plugin)","desc":"Pinia 插件是一个函数，可以选择返回要添加到商店的属性。它需要一个可选参数，一个context：\n```\nexport function myPiniaPlugin(context) {\n  context.pinia // the pinia created with `createPinia()`\n  context.app // the current app created with `createApp()` (Vue 3 only)\n  context.store // the store the plugin is augmenting\n  context.options // the options object defining the store passed to `defineStore()`\n  // ...\n}\n```\n您可以通过简单地在插件中返回它们的对象来为每个商店添加属性\n```\npinia.use(() => ({ hello: 'world' }))\n```\n请注意，插件中发生的状态更改或添加（包括调用store.$patch()）发生在商店处于活动状态之前，因此不会触发任何订阅。","url":"","summary":"","reference":"参考资料|https://pinia.vuejs.org/core-concepts/plugins.html","dot":""}]}]},{"title":"Style","barcolor":"","fold":false,"box":[{"title":"scoped","fold":false,"list":[{"prefix":"","tag":":deep","suffix":"(selector)","desc":"1.使用scoped，父组件的样式不会泄漏到子组件中。\n2.但是，子组件的根节点会同时受到父级 CSS 和子级 CSS 的影响。\n3.如果您希望scoped样式中的选择器“深”，即影响子组件，则可以使用:deep()伪类\n```\n<style scoped>\n.a :deep(.b) {\n  /* ... */\n}\n</style>\n```\n\n","url":"","summary":"加deep为\n```\n.a[data-v-e95e3e20] .b {\n    color: #f00;\n}\n```\n不加deep为\n```\n.c-panel .c-panel-menu__item[data-v-e95e3e20] {\n    color: #f00;\n}\n```","reference":"参考资料|https://vuejs.org/api/sfc-css-features.html#scoped-css","dot":"#c184ff"},{"prefix":"","tag":":slotted","suffix":"(selector)","desc":"默认情况下，scoped作用域样式不会影响由`<slot/>`呈现的内容，因为它们被认为是由传递它们的父组件拥有。要显式定位插槽内容，请使用:slotted伪类。\n```\n<style scoped>\n:slotted(div) {\n  color: red;\n}\n</style>\n```","url":"","summary":"","reference":"","dot":"#c184ff"},{"prefix":"","tag":":global","suffix":"(selector)","desc":"如果您只想全局应用一个规则，则可以使用:global伪类而不是创建另一个规则`<style>`\n```\n<style scoped>\n:global(.red) {\n  color: red;\n}\n</style>\n```","url":"","summary":"","reference":"","dot":"#c184ff"}]},{"title":"module","fold":false,"list":[{"prefix":"","tag":"$style","suffix":".cls","desc":"`<style module>`标签被编译为CSS 模块，并将生成的 CSS 类作为以下键下的对象公开给组件`$style`\n\n```\n<template>\n  <p :class=\"$style.red\">This should be red</p>\n</template>\n\n<style module>\n.red {\n  color: red;\n}\n</style>\n```\n生成的类被散列以避免冲突，达到将 CSS 仅作用于当前组件的相同效果。","url":"","summary":"例如\n```\n.Panel_red__UpzU {\n    color: #f00;\n}\n```","reference":"","dot":"#c184ff"},{"prefix":"","tag":"module=","suffix":"\"classes\"","desc":"module您可以通过给属性一个值来自定义注入的类对象的属性键\n```\n<template>\n  <p :class=\"classes.red\">red</p>\n</template>\n\n<style module=\"classes\">\n.red {\n  color: red;\n}\n</style>\n```","url":"","summary":"","reference":"","dot":"#c184ff"}]},{"title":"data","fold":false,"list":[{"prefix":"","tag":"v-bind","suffix":"(data)","desc":"SFC`<style>`标签支持使用v-bindCSS 函数将 CSS 值链接到动态组件状态\n该语法适用于`<script setup>`，并支持 JavaScript 表达式（必须用引号括起来）\n```\ncolor: v-bind(color);\ncolor: v-bind('theme.color');\n```","url":"","summary":"","reference":"参考资料|https://vuejs.org/api/sfc-css-features.html#v-bind-in-css","dot":"#c184ff"}]}]}]},{"column":[{"title":"Vue Router","barcolor":"","fold":false,"box":[{"title":"Install","fold":false,"list":[{"prefix":"vue router ","tag":"v3","suffix":"","desc":"```\n// 1.Dependency\nimport Vue from \"vue\";\nimport VueRouter from \"vue-router\";\nVue.use(VueRouter);\n\n// 2.Components\nconst Home = () => import(\"../views/Home.vue\");\n\n// 3.Routes\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 4.Build An Instance\nconst router = new VueRouter({\n  mode : 'history'/'hash',\n  routes\n})\n\n// 5.Install router\nconst app = new Vue({\n  router\n}).$mount('#app')\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"vue router ","tag":"v4","suffix":"","desc":"```\n// 1.Dependency\nimport { createRouter, createWebHistory, createWebHashHistory } from \"vue-router\";\n\n// 2.Components\nconst Home = () => import(\"../views/Home.vue\");\n\n// 3.Routes\nconst routes = [{ path: \"/\", component: Home }];\n\n// 4.Build An Instance\nconst router = createRouter({\n    history: createWebHashHistory(), //hash\n    // history: createWebHistory(),  //rewrite\n    routes,\n});\n\n// 5.Install router\napp.use(router)\napp.mount('#app')\n\n// 6.Use router\nthis.$router.<fn>\nthis.$route.<prop>\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"HTML","fold":false,"list":[{"prefix":"","tag":"router-link ","suffix":"to=\"/path\"","desc":"路由链接\n```\n<router-link :to='/path/to'>User</router-link>\n<router-link :to=\"{ name: 'user', params: { username: 'erina' }}\">\n  User\n</router-link>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"router-view ","suffix":"name=\"default\"","desc":"显示与 url 对应的组件.\n同个路由，多个视图就需要多个组件","url":"","summary":"","reference":"","dot":""}]},{"title":"routes","fold":false,"list":[{"prefix":"","tag":"name","suffix":"","desc":"名称","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"path","suffix":"","desc":"+ `'/users/:id'` 动态params\n+ `'/user-*'` 使用以user-开头的任意路径\n+ `'/:orderId(\\\\d+)'` 正则限定（仅为数字）\n+ `'/:chapters+'` 重复参数\n+ `'/users/:userId?'` 可选参数\n","url":"","summary":"# 重复参数\n```\nconst routes = [\n  // /:chapters ->  匹配 /one, /one/two, /one/two/three, 等\n  { path: '/:chapters+' },\n  // /:chapters -> 匹配 /, /one, /one/two, /one/two/three, 等\n  { path: '/:chapters*' },\n]\n```\n\n# 可选参数\n```\nconst routes = [\n  // 匹配 /users 和 /users/posva\n  { path: '/users/:userId?' },\n  // 匹配 /users 和 /users/42\n  { path: '/users/:userId(\\\\d+)?' },\n]\n```","reference":"","dot":""},{"prefix":"","tag":"children","suffix":"","desc":"子路径\n在路径渲染在对应页面中的router-view中。\n父级可用于挂载layout\n\n```\nconst routes = [\n  {\n    path: '/user/:id',\n    component: User,\n    children: [\n      {\n        // 当 /user/:id/profile 匹配成功\n        // UserProfile 将被渲染到 User 的 <router-view> 内部\n        path: 'profile',\n        component: UserProfile,\n      },\n      {\n        // 当 /user/:id/posts 匹配成功\n        // UserPosts 将被渲染到 User 的 <router-view> 内部\n        path: 'posts',\n        component: UserPosts,\n      },\n    ],\n  },\n]\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"component","suffix":"","desc":"# 默认使用default\n```\n{name:\"xx\",component:ViewComponent}\n<router-view></router-view>\n```\n\n# 多个视图\n```\n{\n    name:\"xx\",\n    component:{\n        default : DefaultView,\n        sidebar : SidebarView,\n    }\n}\n<router-view></router-view>\n<router-view name=\"sidebar\"></router-view>\n```\n\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"redirect","suffix":"","desc":"重定向\n```\nconst routes = [{ path: '/home', redirect: '/' }]\nconst routes = [\n  {\n    // /search/screens -> /search?q=screens\n    path: '/search/:searchText',\n    redirect: to => {\n      // 方法接收目标路由作为参数\n      // return 重定向的字符串路径/路径对象\n      return { path: '/search', query: { q: to.params.searchText } }\n    },\n  },\n  {\n    path: '/search',\n    // ...\n  },\n]\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"alias","suffix":"","desc":"别名\n```\nconst routes = [{ path: '/', component: Homepage, alias: '/home' }]\nconst routes = [\n  {\n    path: '/users',\n    component: UsersLayout,\n    children: [\n      // 为这 3 个 URL 呈现 UserList\n      // - /users\n      // - /users/list\n      // - /people\n      { path: '', component: UserList, alias: ['/people', 'list'] },\n    ],\n  },\n]\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"props","suffix":":true","desc":"# 布尔模式\n路由参数动态传递\n```\nconst User = {\n  props: ['id'],\n  template: '<div>User {{ id }}</div>'\n}\nconst routes = [{ path: '/user/:id', component: User, props: true }]\n```\n\n# 命名视图\n对于有命名视图的路由，你必须为每个命名视图定义 props 配置\n```\nconst routes = [\n  {\n    path: '/user/:id',\n    components: { default: User, sidebar: Sidebar },\n    props: { default: true, sidebar: false }\n  }\n]\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"props","suffix":":{obj}","desc":"# 对象模式\n当 props 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。\n```\nconst routes = [\n  {\n    path: '/promotion/from-newsletter',\n    component: Promotion,\n    props: { newsletterPopup: false }\n  }\n]\n```\n\n# 函数模式\n你可以创建一个返回 props 的函数。这允许你将参数转换为其他类型，将静态值与基于路由的值相结合等等。\n```\nconst routes = [\n  {\n    path: '/search',\n    component: SearchUser,\n    props: route => ({ query: route.query.q })\n  }\n]\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeEnter","suffix":":fn|[fns]","desc":"这些守卫与全局前置守卫的方法参数是一样的。\n只在进入路由时触发，不会在 params、query 或 hash 改变时触发。\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n```\n你也可以将一个函数数组传递给 beforeEnter，这在为不同的路由重用守卫时很有用。","url":"","summary":"\n```\nfunction removeQueryParams(to) {\n  if (Object.keys(to.query).length)\n    return { path: to.path, query: {}, hash: to.hash }\n}\n\nfunction removeHash(to) {\n  if (to.hash) return { path: to.path, query: to.query, hash: '' }\n}\n\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UserDetails,\n    beforeEnter: [removeQueryParams, removeHash],\n  },\n  {\n    path: '/about',\n    component: UserDetails,\n    beforeEnter: [removeQueryParams],\n  },\n]\n```","reference":"","dot":""},{"prefix":"","tag":"meta","suffix":"","desc":"# 配置meta\n```\nconst routes = [\n  {\n    path: '/posts',\n    component: PostsLayout,\n    children: [\n      {\n        path: 'new',\n        component: PostsNew,\n        // 只有经过身份验证的用户才能创建帖子\n        meta: { requiresAuth: true }\n      },\n      {\n        path: ':id',\n        component: PostsDetail\n        // 任何人都可以阅读文章\n        meta: { requiresAuth: false }\n      }\n    ]\n  }\n]\n```\n\n# 使用meta\n```\nrouter.beforeEach((to, from) => {\n  // 而不是去检查每条路由记录\n  // to.matched.some(record => record.meta.requiresAuth)\n  if (to.meta.requiresAuth && !auth.isLoggedIn()) {\n    // 此路由需要授权，请检查是否已登录\n    // 如果没有，则重定向到登录页面\n    return {\n      path: '/login',\n      // 保存我们所在的位置，以便以后再来\n      query: { redirect: to.fullPath },\n    }\n  }\n})\n```","url":"","summary":"","reference":"官方文档|https://router.vuejs.org/zh/guide/advanced/meta.html","dot":""}]},{"title":"router","fold":false,"list":[{"prefix":"router","tag":".push","suffix":"()","desc":"```\n// 字符串路径\nrouter.push('/users/eduardo')\n\n// 带有路径的对象\nrouter.push({ path: '/users/eduardo' })\n\n// 命名的路由，并加上参数，让路由建立 url\nrouter.push({ name: 'user', params: { username: 'eduardo' } })\n\n// 带查询参数，结果是 /register?plan=private\nrouter.push({ path: '/register', query: { plan: 'private' } })\n\n// 带 hash，结果是 /about#team\nrouter.push({ path: '/about', hash: '#team' })\n```\npath和params不能同时使用","url":"","summary":"","reference":"","dot":""},{"prefix":"router","tag":".replace","suffix":"()","desc":"在导航时不会向 history 添加新记录\n```\nrouter.push({ path: '/home', replace: true })\n// 相当于\nrouter.replace({ path: '/home' })\n```","url":"","summary":"\n","reference":"","dot":""},{"prefix":"router","tag":".go","suffix":"(n)","desc":"该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 window.history.go(n)。\n```\n// 向前移动一条记录，与 router.forward() 相同\nrouter.go(1)\n\n// 返回一条记录，与router.back() 相同\nrouter.go(-1)\n\n// 前进 3 条记录\nrouter.go(3)\n\n// 如果没有那么多记录，静默失败\nrouter.go(-100)\nrouter.go(100)\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"router","tag":".forward","suffix":"()","desc":"向前一步","url":"","summary":"","reference":"","dot":""},{"prefix":"router","tag":".back","suffix":"()","desc":"后退一步","url":"","summary":"","reference":"","dot":""}]},{"title":"全局导航守卫","fold":false,"list":[{"prefix":"router","tag":".beforeEach","suffix":"()","desc":"# 全局前置守卫\nto: 即将要进入的目标 路由对象\nfrom: 当前导航正要离开的路由\nnext : (v3一定要调用该方法来 resolve 这个钩子)\n```\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n  else next()\n})\n```\n或\n```\nrouter.beforeEach(async (to, from) => {\n  // canUserAccess() 返回 `true` 或 `false`\n  // 如果返回undefined路由有效\n  return await canUserAccess(to)\n  // return route对象\n})\n```","url":"","summary":"","reference":"V3文档|https://v3.router.vuejs.org/zh/guide/advanced/navigation-guards.html\nV4文档|https://router.vuejs.org/zh/guide/advanced/navigation-guards.html","dot":""},{"prefix":"router","tag":".beforeResolve","suffix":"()","desc":"# 全局解析守卫\n在所有组件内守卫和异步路由组件被解析之后，可以访问自定义 meta 属性\n是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。","url":"","summary":"","reference":"","dot":""},{"prefix":"router","tag":".afterEach","suffix":"()","desc":"# 全局后置钩子\n这些钩子不会接受 next 函数也不会改变导航本身","url":"","summary":"","reference":"","dot":""}]},{"title":"组件导航守卫","fold":false,"list":[{"prefix":"component","tag":".beforeRouteEnter","suffix":"","desc":"```\nconst UserDetails = {\n  template: `...`,\n  beforeRouteEnter(to, from) {\n    // 在渲染该组件的对应路由被验证前调用\n    // 不能获取组件实例 `this` ！\n    // 因为当守卫执行时，组件实例还没被创建！\n  },\n}\n```\nbeforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。\n但可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。\n```\nbeforeRouteEnter (to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n  })\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"component","tag":".beforeRouteUpdate","suffix":"","desc":"```\nconst Foo = {\n  template: `...`,\n  beforeRouteUpdate(to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n}\n```\n","url":"","summary":"","reference":"","dot":""},{"prefix":"component","tag":".beforeRouteLeave","suffix":"","desc":"```\nconst Foo = {\n  template: `...`,\n  beforeRouteLeave(to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"composition API","fold":false,"list":[{"prefix":"","tag":"useRouter, useRoute","suffix":"","desc":"```\nimport { useRouter, useRoute } from 'vue-router'\n\nexport default {\n  setup() {\n    const router = useRouter()\n    const route = useRoute()\n\n    function pushWithQuery(query) {\n      router.push({\n        name: 'search',\n        query: {\n          ...route.query,\n        },\n      })\n    }\n  },\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"onBeforeRouteLeave, onBeforeRouteUpdate","suffix":"","desc":"```\nimport { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'\n\nexport default {\n  setup() {\n    // 与 beforeRouteLeave 相同，无法访问 `this`\n    onBeforeRouteLeave((to, from) => {\n      const answer = window.confirm(\n        'Do you really want to leave? you have unsaved changes!'\n      )\n      // 取消导航并停留在同一页面上\n      if (!answer) return false\n    })\n\n    const userData = ref()\n\n    // 与 beforeRouteUpdate 相同，无法访问 `this`\n    onBeforeRouteUpdate(async (to, from) => {\n      //仅当 id 更改时才获取用户，例如仅 query 或 hash 值已更改\n      if (to.params.id !== from.params.id) {\n        userData.value = await fetchUser(to.params.id)\n      }\n    })\n  },\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":false,"list":[{"prefix":"v3 ","tag":"transition","suffix":"","desc":"```\n<transition :name=\"transitionName\">\n  <router-view></router-view>\n</transition>\n```","url":"","summary":"","reference":"官方文档|https://v3.router.vuejs.org/zh/guide/advanced/transitions.html","dot":""},{"prefix":"v4 ","tag":"transition","suffix":"","desc":"```\n<router-view v-slot=\"{ Component }\">\n  <transition name=\"fade\">\n    <component :is=\"Component\" />\n  </transition>\n</router-view>\n```","url":"","summary":"","reference":"官方文档|https://router.vuejs.org/zh/guide/advanced/transitions.html","dot":""},{"prefix":"","tag":"scrollBehavior","suffix":"","desc":"滚动行为\n如果返回一个 falsy 的值，或者是一个空对象，那么不会发生滚动。\n```\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [...],\n  scrollBehavior (to, from, savedPosition) {\n    // return 期望滚动到哪个的位置\n  }\n})\n```","url":"","summary":"```\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [...],\n  scrollBehavior (to, from, savedPosition) {\n    // return 期望滚动到哪个的位置\n    return { top: 0 }  // 始终滚动到顶部\n\n    return { // 始终在元素 #main 上方滚动 10px\n      // 也可以这么写\n      // el: document.getElementById('main'),\n      el: '#main',\n      top: -10,\n    }\n\n    //已记录位置\n    if (savedPosition) {\n      return savedPosition\n    } else {\n      return { top: 0 }\n    }\n\n    //滚动到锚点\n    if (to.hash) {\n      return {\n        el: to.hash,\n        behavior: 'smooth',  //流畅\n      }\n    }\n\n    //延迟滚动\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve({ left: 0, top: 0 })\n      }, 500)\n    })\n\n  }\n})\n```","reference":"官方文档|https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html","dot":""}]}]}]},{"column":[{"title":"其它","barcolor":"","fold":false,"box":[{"title":"官方文档","fold":false,"list":[{"prefix":"","tag":"vue2 教程","suffix":"","desc":"","url":"https://cn.vuejs.org/v2/guide/","summary":"","reference":"","dot":""},{"prefix":"","tag":"vue2 API","suffix":"","desc":"","url":"https://cn.vuejs.org/v2/api/","summary":"","reference":"","dot":""},{"prefix":"","tag":"vue3 教程","suffix":"","desc":"","url":"https://v3.cn.vuejs.org/guide/introduction.html","summary":"","reference":"","dot":""},{"prefix":"","tag":"vue3 API","suffix":"","desc":"","url":"https://v3.cn.vuejs.org/api/","summary":"","reference":"","dot":""},{"prefix":"","tag":"vue2->vue3迁移指南","suffix":"","desc":"","url":"https://v3.cn.vuejs.org/guide/migration/introduction.html","summary":"","reference":"","dot":""},{"prefix":"","tag":"router api v4","suffix":"","desc":"","url":"https://router.vuejs.org/zh/api/","summary":"","reference":"","dot":""},{"prefix":"","tag":"router api v3","suffix":"","desc":"","url":"https://v3.router.vuejs.org/zh/api/","summary":"","reference":"","dot":""},{"prefix":"","tag":"vuex","suffix":"","desc":"","url":"https://vuex.vuejs.org/zh/","summary":"","reference":"","dot":""},{"prefix":"","tag":"pinia","suffix":"","desc":"","url":"https://pinia.vuejs.org/introduction.html","summary":"","reference":"","dot":""}]},{"title":"构建工具","fold":false,"list":[{"prefix":"","tag":"vue cli","suffix":"","desc":"","url":"https://cli.vuejs.org/zh/index.html","summary":"","reference":"","dot":""},{"prefix":"","tag":"vite api","suffix":"","desc":"","url":"https://vitejs.cn/config/","summary":"","reference":"","dot":""}]},{"title":"参考资料","fold":false,"list":[{"prefix":"","tag":"vue2技术揭秘","suffix":"","desc":"","url":"https://ustbhuangyi.github.io/vue-analysis/","summary":"","reference":"","dot":""},{"prefix":"","tag":"其它","suffix":"","desc":"","url":"","summary":"","reference":"vue核心原理|https://segmentfault.com/a/1190000038375749","dot":""}]}]}]}]}