{"version":1581701590595,"name":"webapi","data":[{"column":[{"title":"Server-Sent Events","barcolor":"","fold":false,"box":[{"title":"ServerSide","fold":false,"list":[{"prefix":"","tag":"W3C","suffix":"","desc":"事件流是一个简单的文本数据流，文本应该使用 UTF-8 格式的编码。事件流中的消息由一对换行符分开。以冒号开头的行为注释行，会被忽略。","url":"https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events","summary":"","reference":"","dot":""},{"prefix":"","tag":"http_version","suffix":"","desc":"无需升级协议，只需要HTTP协议为1.1版本（默认）即可","url":"","summary":"```\nlocation /sse-endpoint {\n    # 使用HTTP 1.1协议\n    proxy_http_version 1.1;\n    \n    # 配置缓冲区大小，如果需要的话\n    proxy_buffering off;\n\n    # 代理转发头部信息\n    proxy_set_header Host $host;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"Upgrade\";\n    proxy_set_header Accept-Encoding \"\";\n\n    # 向后端服务器转发SSE请求\n    proxy_pass http://backend_server_sse;\n}\n```","reference":"","dot":""},{"prefix":"","tag":"text/event-stream","suffix":"","desc":"发送事件的服务器端脚本需要使用 text/event-stream MIME 类型响应内容。每个通知以文本块形式发送，并以一对换行符结尾。\n```js\nres.setHeader('Content-Type', 'text/event-stream');\nres.setHeader('Cache-Control', 'no-cache');\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"response","suffix":"","desc":"事件流是一个简单的文本数据流，文本应该使用 UTF-8 格式的编码。事件流中的消息由一对换行符分开。以冒号开头的行为注释行，会被忽略。\n```\nevent: $event\nid: $id\nretry : $n(ms)\ndata: $data\n\\n\\n\n:注释(心跳)\n\\n\\n\n```","url":"","summary":"event\n一个用于标识事件类型的字符串。如果指定了这个字符串，浏览器会将具有指定事件名称的事件分派给相应的监听器；网站源代码应该使用 addEventListener() 来监听指定的事件。如果一个消息没有指定事件名称，那么 onmessage 处理程序就会被调用。\n\ndata\n消息的数据字段。当 EventSource 接收到多个以 data: 开头的连续行时，会将它们连接起来，在它们之间插入一个换行符。末尾的换行符会被删除。\n\nid\n事件 ID，会成为当前 EventSource 对象的内部属性“最后一个事件 ID”的属性值。\n\nretry\n重新连接的时间。如果与服务器的连接丢失，浏览器将等待指定的时间，然后尝试重新连接。这必须是一个整数，以毫秒为单位指定重新连接的时间。如果指定了一个非整数值，该字段将被忽略。","reference":"","dot":""},{"prefix":"","tag":"heartbeat","suffix":"","desc":"需设置心跳，避免客户端代理自动关闭","url":"","summary":"一般来说，浏览器和网络设备可能在几分钟内因为认为连接空闲而关闭连接。为了应对这种情况，通常建议服务器端每隔15到30秒发送一次注释行（例如，发送一个冒号开始的行，:\\n\\n）作为心跳，以保持连接活跃。这个心跳消息对于客户端来说是透明的，不会被当作有效的事件数据处理，但足以保持连接不被自动关闭。","reference":"","dot":""},{"prefix":"","tag":"limit","suffix":"","desc":"$window(tab)+$domain 不超过6个\n使用http/2时可协商，默认100","url":"","summary":"当不使用 HTTP/2 时，服务器发送事件（SSE）受到打开连接数的限制，这个限制是对于浏览器的，并且设置为非常低的数字（6），打开多个选项卡时可能会特别痛苦。在 Chrome 和 Firefox 中，这个问题已被标记为“不会修复”。这个限制是每个浏览器和域名的，这意味着你可以在所有标签页中打开 6 个 SSE 连接到 www.example1.com，以及另外 6 个 SSE 连接到 www.example2.com（来源：Stackoverflow）。当使用 HTTP/2 时，最大并发 HTTP 流的数量是由服务器和客户端协商的（默认为 100）。","reference":"","dot":""}]},{"title":"ClientSide","fold":false,"list":[{"prefix":"","tag":"MDN","suffix":"","desc":"","url":"","summary":"","reference":"MDN指南|https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events\nAPI参考|https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource","dot":""},{"prefix":"","tag":"new EventSource","suffix":"(url, options)","desc":"创建实例（启用跨域）\n```js\nconst evtSource = new EventSource(\"//api.example.com/ssedemo.php\", {\n  withCredentials: true,\n});\n```","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource/EventSource","dot":""},{"prefix":"es","tag":".onmessage","suffix":"","desc":"如果服务器发送的消息中没有 event 字段，则这些消息会被视为 message 事件。为了接收这些 message 事件，需要为 message 事件附加一个事件处理程序。\n```js\nevtSource.onmessage = function (event) {\n   //event.data\n};\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"es","tag":".addEventListener","suffix":"($evt,cb)","desc":"自定义事件\n```js\nevtSource.addEventListener(\"ping\", (event) => {\n   //event.data   返回的都是字符串\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"es","tag":".onerror","suffix":"","desc":"错误处理\n当发生错误时（例如网络超时或与访问控制有关的问题），会生成一个错误事件。可以通过在 EventSource 对象上实现 onerror 回调来编程地处理它\n```js\nevtSource.onerror = (err) => {\n  console.error(\"EventSource failed:\", err);\n};\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"es","tag":".close()","suffix":"","desc":"关闭连接\n默认情况下，如果客户端和服务器之间的连接关闭，则连接将重新启动。可以使用 .close() 方法终止连接。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"CORS","barcolor":"","fold":false,"box":[{"title":"ServerSide","fold":false,"list":[{"prefix":"","tag":"options method","suffix":"","desc":"需要设置正确响应预检请求（preflight request），这是一个CORS机制的一部分，当请求携带特定类型的头部或使用特殊方法时，浏览器会首先发送一个预检请求。","url":"","summary":"```\nif (req.method === 'OPTIONS') {\n        // 预检请求，直接返回200\n        res.writeHead(200);\n        res.end();\n        return;\n}\n```","reference":"","dot":""}]}]}]}]}