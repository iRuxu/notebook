{"version":1577292216582,"name":"css","data":[{"column":[{"title":"Global","barcolor":"","fold":false,"box":[{"title":"property value","fold":false,"list":[{"prefix":"","tag":"initial","suffix":"","desc":"将属性设置为其初始值","url":"https://developer.mozilla.org/en-US/docs/Web/CSS/initial","summary":"","reference":"","dot":""},{"prefix":"","tag":"inherit","suffix":"","desc":"使元素的属性与其父元素相同","url":"https://developer.mozilla.org/en-US/docs/Web/CSS/inherit","summary":"","reference":"","dot":""},{"prefix":"","tag":"revert","suffix":"","desc":"恢复到浏览器初始样式（丢弃用户自定义）","url":"https://developer.mozilla.org/en-US/docs/Web/CSS/revert","summary":"","reference":"","dot":""},{"prefix":"","tag":"unset","suffix":"","desc":"如果继承，则使用unset关键字将属性设置为其继承值，如果不继承，则使用其初始值。\n在第一种情况下（继承属性）它的行为类似于inherit ，在第二种情况下（非继承属性）类似于initial。","url":"https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset","summary":"","reference":"","dot":""}]},{"title":"property","fold":false,"list":[{"prefix":"","tag":"all","suffix":"","desc":"CSS all 简写属性 将除了 unicode-bidi 与 direction 之外的所有属性重设至其初始值，或继承值。","url":"https://developer.mozilla.org/zh-CN/docs/Web/CSS/all","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Flex","barcolor":"","fold":false,"box":[{"title":"Display","fold":false,"list":[{"prefix":"display:","tag":"flex","suffix":"","desc":"注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。","url":"","summary":"","reference":"Flex布局教程|https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\nFlex布局实例|https://www.ruanyifeng.com/blog/2015/07/flex-examples.html\nMDN参考文档|https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex","dot":""},{"prefix":"display:","tag":"inline-flex","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"Container","fold":false,"list":[{"prefix":"","tag":"flex-direction","suffix":"","desc":"控制文本流方向\n+ *row*（默认值）：主轴为水平方向，起点在左端。\n+ row-reverse：主轴为水平方向，起点在右端。\n+ *column*：主轴为垂直方向，起点在上沿。\n+ column-reverse：主轴为垂直方向，起点在下沿。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"flex-wrap","suffix":"","desc":"折行设定\n+ *nowrap*（默认）：不换行。\n+ *wrap*：换行，第一行在上方。\n+ wrap-reverse：换行，第一行在下方。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"flex-flow","suffix":"","desc":"flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"justify-content","suffix":"","desc":"主轴对齐方式\n+ flex-start（默认值）：左对齐\n+ flex-end：右对齐\n+ *center*： 居中\n+ *space-between*：两端对齐，项目之间的间隔都相等。\n+ space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"align-items","suffix":"","desc":"交叉轴对齐方式\n+ flex-start：交叉轴的起点对齐。\n+ flex-end：交叉轴的终点对齐。\n+ *center*：交叉轴的中点对齐。\n+ baseline: 项目的第一行文字的基线对齐。\n+ *stretch*（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"align-content","suffix":"","desc":"定义了多根轴线的对齐方式。\n（如果项目只有一根轴线，该属性不起作用。即只有折行时有效。）\n+ flex-start：与交叉轴的起点对齐。\n+ flex-end：与交叉轴的终点对齐。\n+ *center*：与交叉轴的中点对齐。\n+ *space-between*：与交叉轴两端对齐，轴线之间的间隔平均分布。\n+ space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n+ *stretch*（默认值）：轴线占满整个交叉轴。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"gap","suffix":"","desc":"间距","url":"","summary":"","reference":"","dot":""}]},{"title":"Item","fold":false,"list":[{"prefix":"","tag":"flex-grow","suffix":"","desc":"属性定义项目的*放大比例，默认为0*。\n即如果存在剩余空间，也不放大。\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话，没有则占满剩余全部）。\n如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"flex-shrink","suffix":"","desc":"定义了项目的*缩小比例，默认为1*。\n即如果空间不足，该项目将缩小。\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。\n如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，该项目不缩小。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"flex-basis","suffix":"","desc":"*占据空间，它的默认值为auto，即项目的本来大小*。\n定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"flex","suffix":"","desc":"flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\nauto (1 1 auto) 自动收缩成长\nnone (0 0 auto) 全部固定尺寸","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"order","suffix":"","desc":"*定义项目的排列顺序，默认为0。*\n数值越小，排列越靠前。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"align-self","suffix":"","desc":"允许单个项目*有与其他项目不一样的对齐方式*，可覆盖align-items属性。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Grid","barcolor":"","fold":false,"box":[{"title":"Display","fold":false,"list":[{"prefix":"display:","tag":"grid","suffix":"","desc":"网格布局","url":"","summary":"","reference":"入门教程|https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid","dot":""}]}]}]},{"column":[{"title":"样式","barcolor":"","fold":false,"box":[{"title":"滤镜","fold":false,"list":[{"prefix":"","tag":"filter","suffix":"","desc":"```\n/* URL to SVG filter */\nfilter: url(\"filters.svg#filter-id\");   //使用svg的filter元素\n\n/* <filter-function> values */\nfilter: blur(5px);   //高斯模糊\nfilter: brightness(0.4);  //亮度\nfilter: contrast(200%); //对比度\nfilter: drop-shadow(16px 16px 20px blue);  //投影\nfilter: grayscale(50%);   //灰度\nfilter: hue-rotate(90deg);  //色相旋转\nfilter: invert(75%);  //反相\nfilter: opacity(25%);  //透明度\nfilter: saturate(30%);  //饱和度\nfilter: sepia(60%);  //将图像转为深褐色\n\n/* Multiple filters */\nfilter: contrast(175%) brightness(3%);\n\n/* Use no filter */\nfilter: none;\n```","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter","dot":""},{"prefix":"","tag":"_filter","suffix":"","desc":"IE特有的滤镜属性,配合上述实现透明颜色,透明区块,另外由于IE无法正常显示PNG透明图片,当图片用作为背景图时,同样可以使用本属性解决.\n```css\nbackground:url('../images/ex.png') no-repeat;\n_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"images/ex.png\");\n```\n*注意:通过滤镜对引入图片，滤镜引入图片的时候是相对于HTML文件，而不是相对于CSS文件，建议引入绝对路径。此方法不能应用于平铺图像！\nIE6使用滤镜PNG图片透明后，容器内链接失效，设置a{_position:relative;}\n\nie filter滤镜的说明：\n1.ie9滤镜重叠，给定统一class在条件注释中取消ie9滤镜。\n2.z-index与filter的渲染冲突bug。[详情](https://www.cnblogs.com/iruxu/p/4604274.html)\n3.ie8中对img包裹元素a滤镜失效需要设置在img","url":"","summary":"","reference":"","dot":""},{"prefix":"filter ","tag":"convert ","suffix":"black to hex","desc":"将纯黑色通过多滤镜转为指定纯色\n[codepen demo](https://codepen.io/sosuke/pen/Pjoqqp)","url":"","summary":"```\n'use strict';\n\nclass Color {\n  constructor(r, g, b) {\n    this.set(r, g, b);\n  }\n  \n  toString() {\n    return `rgb(${Math.round(this.r)}, ${Math.round(this.g)}, ${Math.round(this.b)})`;\n  }\n\n  set(r, g, b) {\n    this.r = this.clamp(r);\n    this.g = this.clamp(g);\n    this.b = this.clamp(b);\n  }\n\n  hueRotate(angle = 0) {\n    angle = angle / 180 * Math.PI;\n    const sin = Math.sin(angle);\n    const cos = Math.cos(angle);\n\n    this.multiply([\n      0.213 + cos * 0.787 - sin * 0.213,\n      0.715 - cos * 0.715 - sin * 0.715,\n      0.072 - cos * 0.072 + sin * 0.928,\n      0.213 - cos * 0.213 + sin * 0.143,\n      0.715 + cos * 0.285 + sin * 0.140,\n      0.072 - cos * 0.072 - sin * 0.283,\n      0.213 - cos * 0.213 - sin * 0.787,\n      0.715 - cos * 0.715 + sin * 0.715,\n      0.072 + cos * 0.928 + sin * 0.072,\n    ]);\n  }\n\n  grayscale(value = 1) {\n    this.multiply([\n      0.2126 + 0.7874 * (1 - value),\n      0.7152 - 0.7152 * (1 - value),\n      0.0722 - 0.0722 * (1 - value),\n      0.2126 - 0.2126 * (1 - value),\n      0.7152 + 0.2848 * (1 - value),\n      0.0722 - 0.0722 * (1 - value),\n      0.2126 - 0.2126 * (1 - value),\n      0.7152 - 0.7152 * (1 - value),\n      0.0722 + 0.9278 * (1 - value),\n    ]);\n  }\n\n  sepia(value = 1) {\n    this.multiply([\n      0.393 + 0.607 * (1 - value),\n      0.769 - 0.769 * (1 - value),\n      0.189 - 0.189 * (1 - value),\n      0.349 - 0.349 * (1 - value),\n      0.686 + 0.314 * (1 - value),\n      0.168 - 0.168 * (1 - value),\n      0.272 - 0.272 * (1 - value),\n      0.534 - 0.534 * (1 - value),\n      0.131 + 0.869 * (1 - value),\n    ]);\n  }\n\n  saturate(value = 1) {\n    this.multiply([\n      0.213 + 0.787 * value,\n      0.715 - 0.715 * value,\n      0.072 - 0.072 * value,\n      0.213 - 0.213 * value,\n      0.715 + 0.285 * value,\n      0.072 - 0.072 * value,\n      0.213 - 0.213 * value,\n      0.715 - 0.715 * value,\n      0.072 + 0.928 * value,\n    ]);\n  }\n\n  multiply(matrix) {\n    const newR = this.clamp(this.r * matrix[0] + this.g * matrix[1] + this.b * matrix[2]);\n    const newG = this.clamp(this.r * matrix[3] + this.g * matrix[4] + this.b * matrix[5]);\n    const newB = this.clamp(this.r * matrix[6] + this.g * matrix[7] + this.b * matrix[8]);\n    this.r = newR;\n    this.g = newG;\n    this.b = newB;\n  }\n\n  brightness(value = 1) {\n    this.linear(value);\n  }\n  contrast(value = 1) {\n    this.linear(value, -(0.5 * value) + 0.5);\n  }\n\n  linear(slope = 1, intercept = 0) {\n    this.r = this.clamp(this.r * slope + intercept * 255);\n    this.g = this.clamp(this.g * slope + intercept * 255);\n    this.b = this.clamp(this.b * slope + intercept * 255);\n  }\n\n  invert(value = 1) {\n    this.r = this.clamp((value + this.r / 255 * (1 - 2 * value)) * 255);\n    this.g = this.clamp((value + this.g / 255 * (1 - 2 * value)) * 255);\n    this.b = this.clamp((value + this.b / 255 * (1 - 2 * value)) * 255);\n  }\n\n  hsl() {\n    // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.\n    const r = this.r / 255;\n    const g = this.g / 255;\n    const b = this.b / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h, s, l = (max + min) / 2;\n\n    if (max === min) {\n      h = s = 0;\n    } else {\n      const d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n\n        case g:\n          h = (b - r) / d + 2;\n          break;\n\n        case b:\n          h = (r - g) / d + 4;\n          break;\n      }\n      h /= 6;\n    }\n\n    return {\n      h: h * 100,\n      s: s * 100,\n      l: l * 100,\n    };\n  }\n\n  clamp(value) {\n    if (value > 255) {\n      value = 255;\n    } else if (value < 0) {\n      value = 0;\n    }\n    return value;\n  }\n}\n\nclass Solver {\n  constructor(target, baseColor) {\n    this.target = target;\n    this.targetHSL = target.hsl();\n    this.reusedColor = new Color(0, 0, 0);\n  }\n\n  solve() {\n    const result = this.solveNarrow(this.solveWide());\n    return {\n      values: result.values,\n      loss: result.loss,\n      filter: this.css(result.values),\n    };\n  }\n\n  solveWide() {\n    const A = 5;\n    const c = 15;\n    const a = [60, 180, 18000, 600, 1.2, 1.2];\n\n    let best = { loss: Infinity };\n    for (let i = 0; best.loss > 25 && i < 3; i++) {\n      const initial = [50, 20, 3750, 50, 100, 100];\n      const result = this.spsa(A, a, c, initial, 1000);\n      if (result.loss < best.loss) {\n        best = result;\n      }\n    }\n    return best;\n  }\n\n  solveNarrow(wide) {\n    const A = wide.loss;\n    const c = 2;\n    const A1 = A + 1;\n    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];\n    return this.spsa(A, a, c, wide.values, 500);\n  }\n\n  spsa(A, a, c, values, iters) {\n    const alpha = 1;\n    const gamma = 0.16666666666666666;\n\n    let best = null;\n    let bestLoss = Infinity;\n    const deltas = new Array(6);\n    const highArgs = new Array(6);\n    const lowArgs = new Array(6);\n\n    for (let k = 0; k < iters; k++) {\n      const ck = c / Math.pow(k + 1, gamma);\n      for (let i = 0; i < 6; i++) {\n        deltas[i] = Math.random() > 0.5 ? 1 : -1;\n        highArgs[i] = values[i] + ck * deltas[i];\n        lowArgs[i] = values[i] - ck * deltas[i];\n      }\n\n      const lossDiff = this.loss(highArgs) - this.loss(lowArgs);\n      for (let i = 0; i < 6; i++) {\n        const g = lossDiff / (2 * ck) * deltas[i];\n        const ak = a[i] / Math.pow(A + k + 1, alpha);\n        values[i] = fix(values[i] - ak * g, i);\n      }\n\n      const loss = this.loss(values);\n      if (loss < bestLoss) {\n        best = values.slice(0);\n        bestLoss = loss;\n      }\n    }\n    return { values: best, loss: bestLoss };\n\n    function fix(value, idx) {\n      let max = 100;\n      if (idx === 2 /* saturate */) {\n        max = 7500;\n      } else if (idx === 4 /* brightness */ || idx === 5 /* contrast */) {\n        max = 200;\n      }\n\n      if (idx === 3 /* hue-rotate */) {\n        if (value > max) {\n          value %= max;\n        } else if (value < 0) {\n          value = max + value % max;\n        }\n      } else if (value < 0) {\n        value = 0;\n      } else if (value > max) {\n        value = max;\n      }\n      return value;\n    }\n  }\n\n  loss(filters) {\n    // Argument is array of percentages.\n    const color = this.reusedColor;\n    color.set(0, 0, 0);\n\n    color.invert(filters[0] / 100);\n    color.sepia(filters[1] / 100);\n    color.saturate(filters[2] / 100);\n    color.hueRotate(filters[3] * 3.6);\n    color.brightness(filters[4] / 100);\n    color.contrast(filters[5] / 100);\n\n    const colorHSL = color.hsl();\n    return (\n      Math.abs(color.r - this.target.r) +\n      Math.abs(color.g - this.target.g) +\n      Math.abs(color.b - this.target.b) +\n      Math.abs(colorHSL.h - this.targetHSL.h) +\n      Math.abs(colorHSL.s - this.targetHSL.s) +\n      Math.abs(colorHSL.l - this.targetHSL.l)\n    );\n  }\n\n  css(filters) {\n    function fmt(idx, multiplier = 1) {\n      return Math.round(filters[idx] * multiplier);\n    }\n    return `filter: invert(${fmt(0)}%) sepia(${fmt(1)}%) saturate(${fmt(2)}%) hue-rotate(${fmt(3, 3.6)}deg) brightness(${fmt(4)}%) contrast(${fmt(5)}%);`;\n  }\n}\n\nfunction hexToRgb(hex) {\n  // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n  const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  hex = hex.replace(shorthandRegex, (m, r, g, b) => {\n    return r + r + g + g + b + b;\n  });\n\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? [\n      parseInt(result[1], 16),\n      parseInt(result[2], 16),\n      parseInt(result[3], 16),\n    ]\n    : null;\n}\n\n$(document).ready(() => {\n  $('button.execute').click(() => {\n    const rgb = hexToRgb($('input.target').val());\n    if (rgb.length !== 3) {\n      alert('Invalid format!');\n      return;\n    }\n\n    const color = new Color(rgb[0], rgb[1], rgb[2]);\n    const solver = new Solver(color);\n    const result = solver.solve();\n\n    let lossMsg;\n    if (result.loss < 1) {\n      lossMsg = 'This is a perfect result.';\n    } else if (result.loss < 5) {\n      lossMsg = 'The is close enough.';\n    } else if (result.loss < 15) {\n      lossMsg = 'The color is somewhat off. Consider running it again.';\n    } else {\n      lossMsg = 'The color is extremely off. Run it again!';\n    }\n\n    $('.realPixel').css('background-color', color.toString());\n    $('.filterPixel').attr('style', result.filter);\n    $('.filterDetail').text(result.filter);\n    $('.lossDetail').html(`Loss: ${result.loss.toFixed(1)}. <b>${lossMsg}</b>`);\n  });\n});\n```","reference":"stackoverflow| https://stackoverflow.com/a/43960991/604861","dot":""}]}]}]}]}