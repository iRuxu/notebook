{"version":1584764487902,"name":"git","data":[{"column":[{"title":"Buffer","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"","tag":"Buffer.from","suffix":"(str,encoding)","desc":"Buffer 实例也是 Uint8Array 实例，长度1为1个字节（8位）\n+ Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）\n+ Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n+ Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例\n+ Buffer.from(object[, offsetOrEncoding[, length]]) 对于对象的valueOf()返回值\n+ Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例\n+ Buffer.from(path)：从文件内容返回","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Buffer.alloc","suffix":"(size)","desc":"+ Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0\n+ Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据\n+ Buffer.allocUnsafeSlow(size)","url":"","summary":"","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"buf","tag":"[i]","suffix":"","desc":"获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".length","suffix":"","desc":"返回 Buffer 对象所占据的内存长度。(字节数）\n`Buffer.byteLength(buf)`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"<encoding>","suffix":"","desc":"# nodejs默认内置字符编码\n+ ascii \n仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n+ utf-8\n多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n+ hex \n将每个字节编码为两个十六进制字符（1字节=8位=2个4位,2^4=16）\n+ base64\nMIME编码的一种\n+ latin1/binary \n一种把 Buffer 编码成一字节编码的字符串的方式,ISO-8859-1的别名\n+ utf16le/ucs2 \n2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。","url":"","summary":"# ascii\n作用：表语英语及西欧语言。\n位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。\n范围：ASCII从00到7F，扩展从00到FF\n# iso8859-1\n作用：扩展ASCII，表示西欧、希腊语等。\n位数：8位\n范围：从00到FF，兼容ASCII字符集\n# GB2312字符集\n作用：国家简体中文字符集，兼容ASCII。\n位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。\n范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码。\n# GBK字符集\n作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。\n位数：使用2个字节表示，可表示21886个字符。\n范围：高字节从81到FE，低字节从40到FE。\n# BIG5字符集\n作用：它解决了中文、日文、朝鲜语等的编码，兼容GBK。\n位数：它采用变字节表示(1 ASCII，2，4字节)。可表示27484个文字。\n范围：1字节从00到7F; 2字节高字节从81到FE，低字节从40到7E和80到FE；4字节第一三字节从81到FE，第二四字节从30到39。\n# UTF-8/UTF-32/UTF-16/UTF-7\n作用：为世界650种语言进行统一编码，兼容ISO-8859-1。\n位数：UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16和UTF-32。","reference":"参考资料1|https://www.cnblogs.com/happyday56/p/4135845.html\n参考资料2|https://dailc.github.io/2017/06/03/utf8ToUtf16ToGbk.html","dot":""},{"prefix":"buf","tag":".toString","suffix":"([encoding])","desc":"解码缓冲区数据并使用指定的编码返回字符串。\n`buf.toString([encoding[, start[, end]]])`\nencoding - 使用的编码。默认为 'utf8' 。\nstart - 指定开始读取的索引位置，默认为 0。\nend - 结束位置，默认为缓冲区的末尾。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"iconv-lite","suffix":"","desc":"包括gbk在内的更多编码支持\n```javascript\nvar iconv = require('iconv-lite');\n \n// Convert from an encoded buffer to js string.\nstr = iconv.decode(Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]), 'win1251');\n \n// Convert from js string to an encoded buffer.\nbuf = iconv.encode(\"Sample input string\", 'win1251');\n \n// Check if encoding is supported\niconv.encodingExists(\"us-ascii\")\n```","url":"https://www.npmjs.com/package/iconv-lite","summary":"","reference":"","dot":""}]},{"title":"操作","fold":false,"list":[{"prefix":"buf","tag":".write","suffix":"(str)","desc":"返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n`buf.write(string[, offset[, length]][, encoding])`\nstring - 写入缓冲区的字符串。\noffset - 缓冲区开始写入的索引值，默认为 0 。\nlength - 写入的字节数，默认为 buffer.length\nencoding - 使用的编码。默认为 'utf8' 。","url":"","summary":"buf.writeBigInt64BE(value[, offset])\nbuf.writeBigInt64LE(value[, offset])\nbuf.writeBigUInt64BE(value[, offset])\nbuf.writeBigUInt64LE(value[, offset])\nbuf.writeDoubleBE(value[, offset])\nbuf.writeDoubleLE(value[, offset])\nbuf.writeFloatBE(value[, offset])\nbuf.writeFloatLE(value[, offset])\nbuf.writeInt8(value[, offset])\nbuf.writeInt16BE(value[, offset])\nbuf.writeInt16LE(value[, offset])\nbuf.writeInt32BE(value[, offset])\nbuf.writeInt32LE(value[, offset])\nbuf.writeIntBE(value, offset, byteLength)\nbuf.writeIntLE(value, offset, byteLength)\nbuf.writeUInt8(value[, offset])\nbuf.writeUInt16BE(value[, offset])\nbuf.writeUInt16LE(value[, offset])\nbuf.writeUInt32BE(value[, offset])\nbuf.writeUInt32LE(value[, offset])\nbuf.writeUIntBE(value, offset, byteLength)\nbuf.writeUIntLE(value, offset, byteLength)","reference":"","dot":""},{"prefix":"","tag":"Buffer.concat","suffix":"([buf1,buf2,..])","desc":"缓冲区合并,返回一个多个成员合并的新 Buffer 对象。\n`Buffer.concat(list[, totalLength])`\nlist - 用于合并的 Buffer 对象数组列表。\ntotalLength - 指定合并后Buffer对象的总长度。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".slice","suffix":"(start,[end])","desc":"`buf.slice([start[, end]])`\n返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".copy","suffix":"(buf2)","desc":"`buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])`\n缓冲区拷贝,没有返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".compare","suffix":"(buf2)","desc":"比较两个buffer，返回一个数字，表示 buf 在 otherBuffer 之前(<0)，之后或相同\n`buf.equals(otherBuffer)` 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".fill","suffix":"(val)","desc":"`buf.fill(value[, offset][, end])`\n使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"events","barcolor":"","fold":false,"box":[{"title":"创建实例","fold":false,"list":[{"prefix":"","tag":"new events.EventEmitter()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"添加监听","fold":false,"list":[{"prefix":"emitter","tag":".addListener","suffix":"(evt,fn)","desc":"为指定事件添加一个监听器到监听器数组的尾部。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".on","suffix":"(evt,fn)","desc":"为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数\n不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 与 listener 会导致 listener 会被添加多次。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependListener","suffix":"(evt,fn)","desc":"添加 listener 函数到名为 eventName 的事件的监听器数组的开头。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".once","suffix":"(evt,fn)","desc":"为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependOnceListener","suffix":"(evt,fn)","desc":"添加单次监听器 listener 到名为 eventName 的事件的监听器数组的开头。 \n当 eventName 事件下次触发时，监听器会先被移除，然后再调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"newListener","suffix":",fn)","desc":"实例在新的监听器被添加到其内部监听器数组之前，会触发自身的 'newListener' 事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"移除监听","fold":false,"list":[{"prefix":"emitter","tag":".removeListener","suffix":"(evt,fn)","desc":"移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。\n最多只会从监听器数组中移除一个监听器。 如果监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener() 才能移除所有实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".off","suffix":"(evt,fn)","desc":"emitter.removeListener() 的别名。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".removeAllListeners","suffix":"([evt])","desc":"移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"removeListener","suffix":",fn)","desc":"'removeListener' 事件在 listener 被移除后触发。","url":"","summary":"","reference":"","dot":""}]},{"title":"触发事件","fold":false,"list":[{"prefix":"emitter","tag":".emit","suffix":"(evt,args..)","desc":"按监听器的顺序执行执行每个监听器\n如果事件有注册监听返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"error","suffix":",fn)","desc":"我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"emitter","tag":".eventNames()","suffix":"","desc":"返回已注册监听器的事件名数组。 数组中的值为字符串或 Symbol。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listeners","suffix":"(evt)","desc":"返回指定事件的监听器数组。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listenerCount","suffix":"(evt)","desc":"返回正在监听的名为 eventName 的事件的监听器的数量。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".setMaxListeners","suffix":"(n)","desc":"默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 \nsetMaxListeners 函数用于提高监听器的默认限制的数量。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"struct","fold":false,"list":[{"prefix":"","tag":"struct.pack","suffix":"(flag,data)","desc":"把任意数据类型变成bytes","url":"","summary":"","reference":"参考资料|https://www.liaoxuefeng.com/wiki/1016959663602400/1017685387246080","dot":"","title":"python"},{"prefix":"","tag":"struct.unpack","suffix":"(flag,bytes)","desc":"把bytes变成相应的数据类型","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"stream","barcolor":"","fold":false,"box":[{"title":"管道全自动","fold":false,"list":[{"prefix":"rs","tag":".pipe","suffix":"(ws,[{end:false}])","desc":"绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。 数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。\n**返回:目标流的引用**\n默认情况下，当来源可读流触发 'end' 事件时，目标可写流也会调用 stream.end() 结束写入。 若要禁用这种默认行为， end 选项应设为 false，这样目标流就会保持打开\n```\nreader.pipe(writer, { end: false });\nreader.on('end', () => {\n  writer.end('结束');\n});\n```\n如果可读流在处理期间发送错误，则可写流目标不会自动关闭。 如果发生错误，则需要手动关闭每个流以防止内存泄漏。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"pipe","suffix":",fn(rs))","desc":"当在可读流上调用 stream.pipe() 方法时会发出 'pipe' 事件，并将此可写流添加到其目标集","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".unpipe","suffix":"([ws])","desc":"解绑之前使用 stream.pipe() 方法绑定的可写流\n如果没有指定 destination, 则解绑所有管道\n如果指定了 destination, 但它没有建立管道，则不起作用","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"unpipe","suffix":",fn)","desc":"在可读流上调用 stream.unpipe() 方法时会发出 'unpipe'事件，从其目标集中移除此可写流。\n当可读流通过管道流向可写流发生错误时，也会触发此事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"s","tag":".destroy","suffix":"([error])","desc":"销毁流","url":"","summary":"","reference":"","dot":""},{"prefix":"s.on(","tag":"close","suffix":",fn)","desc":"当流或其底层资源（比如文件描述符）被关闭时触发 'close' 事件。 \n该事件表明不会再触发其他事件，也不会再发生操作。","url":"","summary":"","reference":"","dot":""},{"prefix":"s.on(","tag":"error","suffix":",fn)","desc":"发生错误时","url":"","summary":"","reference":"","dot":""}]}]},{"title":"stream.Transform","barcolor":"","fold":false,"box":[{"title":"自定义","fold":false,"list":[{"prefix":"ts = ","tag":"new stream.Transform","suffix":"","desc":"转换流是一种双工流，它会对输入做些计算然后输出。\n```\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"ts","tag":"._transform","suffix":"(chunk,encoding,done)","desc":"将读入的chunk进行操作后，最后传递给push。`this.push(newChunk)`\n_transform的回调函数，第一参数可为err，第2个参数将传递给push。\n","url":"","summary":"该方法是用于接受输入并产生输出的一个中转站，该方法内部实现对写入的字节进行操作，然后计算出一个输出，最后将输出使用readable.push()方法传递给可读流。\ncallback函数必须在当前块完全消耗完毕之后调用，如果在处理输入的时候发生错误的时候回调的第一个参数必须是一个Error对象，否则是一个null。如果回调有第二个参数的话，它将会转发给readable.push()。\n```\nconst { Transform } = require(\"stream\");\nclass myTransform extends Transform {\n    constructor(options) {\n        super(options);\n    }\n    _transform(chunk, encoding, done) {\n        const upperChunk = chunk.toString().toUpperCase();\n        this.push(upperChunk);\n        done();\n    }\n    _flush(done) {\n        // this.push(\"end\\n\");\n        done();\n    }\n}\n```","reference":"参考资料|https://juejin.im/entry/59b5539af265da066c22e28a","dot":""},{"prefix":"ts","tag":"._flush","suffix":"(done)","desc":"收尾处理，在finish之前执行。\n_flush的回调函数，第一个参数可为null，第2个参数将传递给push。","url":"","summary":"\n","reference":"","dot":""}]}]},{"title":"stream.Readable","barcolor":"","fold":false,"box":[{"title":"stream.Readable","fold":false,"list":[{"prefix":"rs","tag":".readableFlowing","suffix":"","desc":"+ null 没有提供消费流数据的机制，所以流不会产生数据\n+ false 数据可能会堆积在流的内部缓冲中\n+ true ","url":"","summary":"# 两种模式\n可读流运作于两种模式之一：流动模式（flowing）或暂停模式（paused）。 这些模式与对象模式分开。 无论是否处于流动模式或暂停模式，可读流都可以处于对象模式。\n在流动模式中，数据自动从底层系统读取，并通过 EventEmitter 接口的事件尽可能快地被提供给应用程序。\n在暂停模式中，必须显式调用 stream.read() 读取数据块。\n# 模式切换\n所有可读流都开始于暂停模式\n*切换到流动模式*：\n+ 添加 'data' 事件句柄。\n+ 调用 stream.resume() 方法。\n+ 调用 stream.pipe() 方法将数据发送到可写流。\n\n*切换回暂停模式*：\n+ 如果没有管道目标，则调用 stream.pause()。\n+ 如果有管道目标，则移除所有管道目标。调用 stream.unpipe() 可以移除多个管道目标。\n# 补充说明\n只有提供了消费或忽略数据的机制后，可读流才会产生数据。 如果消费的机制被禁用或移除，则可读流会停止产生数据。\n\n为了向后兼容，移除 'data' 事件句柄不会自动地暂停流。 如果有管道目标，一旦目标变为 drain 状态并请求接收数据时，则调用 stream.pause() 也不能保证流会保持暂停模式。\n\n如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。 例如，当调用 readable.resume() 时，没有监听 'data' 事件或 'data' 事件句柄已移除。\n\n添加 'readable' 事件句柄会使流自动停止流动，并通过 readable.read() 消费数据。 如果 'readable' 事件句柄被移除，且存在 'data' 事件句柄，则流会再次开始流动。","reference":"","dot":""},{"prefix":"rs","tag":".setEncoding","suffix":"(encoding)","desc":"为从可读流读取的数据设置字符编码\n默认情况下没有设置字符编码，流数据返回的是 Buffer 对象。 如果设置了字符编码，则流数据返回指定编码的字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".readableHighWaterMark","suffix":"","desc":"默认16KB","url":"","summary":"","reference":"","dot":""}]},{"title":"纯手动","fold":false,"list":[{"prefix":"rs.on(","tag":"readable","suffix":",fn)","desc":"当有数据可从流中读取时，就会触发 'readable' 事件。 \n在某些情况下，为 'readable' 事件附加监听器将会导致将一些数据读入内部缓冲区\n```\nreadable.on('readable', function() {\n  // 有数据可读取。\n  let data;\n\n  while (data = this.read()) {\n    console.log(data);\n  }\n});\n```","url":"","summary":"当到达流数据的尽头时， 'readable' 事件也会触发，但是在 'end' 事件之前触发。\n'readable' 事件表明流有新的动态：要么有新的数据，要么到达流的尽头。 对于前者，stream.read() 会返回可用的数据。 对于后者，stream.read() 会返回 null。","reference":"","dot":""},{"prefix":"rs","tag":".read","suffix":"([size])","desc":"从内部缓冲拉取并返回数据。size指定要读取的数据的字节数。\n如果没有可读的数据，则返回 null。 \n默认情况下， readable.read() 返回的数据是 Buffer 对象，除非使用 readable.setEncoding() 指定字符编码或流处于对象模式。\n```\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(`接收到 ${chunk.length} 字节的数据`);\n  }\n});\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"可调节","fold":false,"list":[{"prefix":"rs.on(","tag":"data","suffix":",fn(chunk))","desc":"当流将数据块传送给消费者后触发\n将 'data' 事件监听器附加到尚未显式暂停的流将会使流切换为流动模式。 数据将会在可用时立即传递。\n```\nreadable.on('data', (chunk) => {\n  console.log(`接收到 ${chunk.length} 个字节的数据`);\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".pause()","suffix":"","desc":"使流动模式的流停止触发 'data' 事件，并切换出流动模式。\n任何可用的数据都会保留在内部缓存中。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs.on(","tag":"pause","suffix":",fn)","desc":"当调用 stream.pause() 并且 readsFlowing 不为 false 时，就会触发 'pause' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".resume()","suffix":"","desc":"将被暂停的可读流恢复触发 'data' 事件，并将流切换到流动模式。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs.on(","tag":"resume","suffix":",fn)","desc":"当调用 stream.resume() 并且 readsFlowing 不为 true 时，将会触发 'resume' 事件","url":"","summary":"","reference":"","dot":""}]},{"title":"读取完毕","fold":false,"list":[{"prefix":"rs.on(","tag":"end","suffix":",fn)","desc":"当流中没有数据可供消费时触发。\n'end' 事件只有在数据被完全消费掉后才会触发。 ","url":"","summary":"","reference":"","dot":""}]},{"title":"自定义","fold":false,"list":[{"prefix":"rs = ","tag":"new stream.Readable","suffix":"","desc":"创建一个readable流\n```\nconst { Readable } = require('stream');\n\nconst myReadable = new Readable({\n  read(size) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/stream.html#stream_new_stream_readable_options","dot":""},{"prefix":"rs","tag":"._read","suffix":"([size])","desc":"自定义按需读取","url":"","summary":"","reference":"参考资料|https://github.com/jabez128/stream-handbook","dot":""},{"prefix":"rs","tag":".push","suffix":"(chunk,[encoding])","desc":"当 chunk 是 Buffer、 Uint8Array 或 string 时， chunk 的数据会被添加到内部队列中供流消费。 \n在没有数据可写入后，给 chunk 传入 **null** 表示流的结束（EOF）。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"stream.Readable.from","suffix":"(ite)","desc":"一个从迭代器中创建可读流的实用方法","url":"","summary":"```\nconst { Readable } = require('stream');\n\nasync function * generate() {\n  yield 'hello';\n  yield 'streams';\n}\n\nconst readable = Readable.from(generate());\n\nreadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n```","reference":"","dot":""}]}]},{"title":"stream.Writable","barcolor":"","fold":false,"box":[{"title":"stream.Writable","fold":false,"list":[{"prefix":"ws","tag":".setDefaultEncoding","suffix":"(encoding)","desc":"为可写流设置默认的 encoding","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".writableHighWaterMark","suffix":"","desc":"默认16KB","url":"","summary":"","reference":"","dot":""}]},{"title":"写入中","fold":false,"list":[{"prefix":"ws","tag":".write","suffix":"(chunk,[encoding,callback])","desc":"`writable.write(chunk[, encoding][, callback])`\n写入数据到流，并在数据被完全处理之后调用 callback。 \n在接收了 chunk 后，如果内部的缓冲小于创建流时配置的 highWaterMark，则返回 true 。 如果返回 false ，则应该停止向流写入数据，直到 'drain' 事件被触发。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"drain","suffix":",fn)","desc":"writable.write(chunk)返回false以后，当缓存数据全部写入完成，可以继续写入时，会触发drain事件，表示缓存空了。","url":"","summary":"","reference":"","dot":""}]},{"title":"写入完","fold":false,"list":[{"prefix":"ws","tag":".end","suffix":"([chunk,encoding,callback])","desc":"`writable.end([chunk[, encoding]][, callback])`\n表明已没有数据要被写入可写流。 \n可选的 chunk 和 encoding 参数可以在关闭流之前再写入一块数据。 \n如果传入了 callback 函数，则会做为监听器添加到 'finish' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"finish","suffix":",fn)","desc":"缓冲数据都已传给底层系统之后触发","url":"","summary":"","reference":"","dot":""}]},{"title":"自定义","fold":false,"list":[{"prefix":"ws = ","tag":"new stream.Writable","suffix":"","desc":"创建一个可写流\n```\nconst { Writable } = require('stream');\n\nconst myWritable = new Writable({\n  write(chunk, encoding, callback) {\n    // ...\n  },\n  writev(chunks, callback) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/stream.html#stream_constructor_new_stream_writable_options","dot":""},{"prefix":"ws","tag":"._write","suffix":"(chunk,encoding,callback)","desc":"所有可写流的实现必须提供 writable.\\_write() 和/或 writable.\\_writev() 方法将数据发送到底层资源。\n`writable._writev(chunks, callback)` 一次处理多个数据块","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":"._final","suffix":"(callback)","desc":"当结束写入所有剩余数据时的回调函数\n该方法会在流关闭之前被调用，且在 callback 被调用后触发 'finish' 事件。 主要用于在流结束之前关闭资源或写入缓冲的数据。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"path","barcolor":"","fold":false,"box":[{"title":"全局变量","fold":false,"list":[{"prefix":"","tag":"__filename","suffix":"","desc":"指向当前运行的脚本文件名","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__dirname","suffix":"","desc":"指向当前运行的脚本所在的目录","url":"","summary":"","reference":"","dot":""}]},{"title":"生成","fold":false,"list":[{"prefix":"path","tag":".resolve","suffix":"([...paths])","desc":"将路径或路径片段的序列解析为绝对路径","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".join","suffix":"([...paths])","desc":"使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。","url":"","summary":"零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 '.'，表示当前工作目录","reference":"","dot":""},{"prefix":"path","tag":".normalize","suffix":"(path)","desc":"规范化给定的 path","url":"","summary":"","reference":"","dot":""}]},{"title":"分析","fold":false,"list":[{"prefix":"path","tag":".parse","suffix":"(path)","desc":"返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略，\n```\npath.parse('/home/user/dir/file.txt');\n// 返回:\n// { root: '/',\n//   dir: '/home/user/dir',\n//   base: 'file.txt',\n//   ext: '.txt',\n//   name: 'file' \n```","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".format","suffix":"(obj)","desc":"从对象返回路径字符串,path逆方法\ndir和root只需一个\nbase和name+ext只需一个","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/path.html#path_path_format_pathobject","dot":""},{"prefix":"path","tag":".isAbsolute","suffix":"(path)","desc":"检测 path 是否为绝对路径。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".relative","suffix":"(from, to)","desc":"根据当前工作目录返回 from 到 to 的相对路径。 ","url":"","summary":"","reference":"","dot":""}]},{"title":"信息","fold":false,"list":[{"prefix":"path","tag":".dirname","suffix":"(path)","desc":"返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略\n```\npath.dirname('/foo/bar/baz/asdf/quux');\n// 返回: '/foo/bar/baz/asdf'\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".basename","suffix":"(path,[ext])","desc":"返回 path 的最后一部分，类似于 Unix 的 basename 命令。\n尾部的目录分隔符将被忽略\n```javascript\npath.basename('/foo/bar/baz/asdf/quux.html');\n// 返回: 'quux.html'\npath.basename('/foo/bar/baz/asdf/quux.html', '.html');\n// 返回: 'quux'\n```","url":"","summary":"","reference":"","dot":"","title":"其它"},{"prefix":"path","tag":".extname","suffix":"(path)","desc":"返回 path 的扩展名\n从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 path.basename()）除了第一个字符以外没有 .，则返回空字符串。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"path","tag":".delimiter","suffix":"","desc":"提供平台特定的路径定界符：\n; 用于 Windows\n: 用于 POSIX","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".sep","suffix":"","desc":"提供平台特定的路径片段分隔符：\nWindows 上是 \\。\nPOSIX 上是 /。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".win32","suffix":"","desc":"提供对特定于 Windows 的 path 方法的实现的访问。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".posix","suffix":"","desc":"提供对 path 方法的 POSIX 特定实现的访问","url":"","summary":"","reference":"","dot":""}]}]},{"title":"目录","barcolor":"","fold":false,"box":[{"title":"检查","fold":false,"list":[{"prefix":"fs","tag":".existsSync","suffix":"(path)","desc":"如果路径存在，则返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""}]},{"title":"移动","fold":false,"list":[{"prefix":"fse","tag":".move","suffix":"(src,dest,fn)","desc":"移动内容，默认不覆盖\n```\nfs.move(srcpath, dstpath)\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/move.md","summary":"","reference":"","dot":""}]},{"title":"创建","fold":false,"list":[{"prefix":"fs","tag":".mkdir","suffix":"(path,fn)","desc":"创建目录,如已存在会失败\n同步方法：`fs.mkdirSync(path[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_mkdir_path_options_callback","dot":""},{"prefix":"fs","tag":".mkdtemp","suffix":"(prefix,fn)","desc":"创建一个唯一的临时目录。\n同步方法：`fs.mkdtempSync(prefix[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_mkdtemp_prefix_options_callback","dot":""}]},{"title":"删除","fold":false,"list":[{"prefix":"fs","tag":".rmdir","suffix":"(path,[opt],fn)","desc":"删除目录\n同步方法：`fs.rmdirSync(path[, options])`\nopt.recursive 如果为 true，则执行递归的目录删除。在递归模式中，如果 path 不存在则不报告错误，并且在失败时重试操作。默认值: false。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_rmdir_path_options_callback","dot":""},{"prefix":"fse","tag":".remove","suffix":"(path)","desc":"递归删除文件和目录\n```\nfs.remove('/tmp/myfile')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/remove.md","summary":"","reference":"","dot":""},{"prefix":"fse","tag":".emptyDir","suffix":"(dir)","desc":"递归清空目录\n```\nfs.emptyDir('/tmp/some/dir')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"fs","tag":".readdir","suffix":"(path,fn)","desc":"读取目录的内容\n同步方法：`fs.readdirSync(path[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_readdir_path_options_callback","dot":""},{"prefix":"fs","tag":".opendir","suffix":"(path,fn)","desc":"打开目录\n同步方法：`fs.opendirSync(path[, options])`","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_opendir_path_options_callback","dot":""},{"prefix":"","tag":"glob","suffix":"(**/*.js,fn(err,files))","desc":"选择glob规则指定文件\n```\nvar glob = require(\"glob\")\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n})\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/glob","dot":""}]}]},{"title":"zlib","barcolor":"","fold":false,"box":[{"title":"zlib","fold":false,"list":[{"prefix":"","tag":"compressing","suffix":"","desc":"","url":"https://github.com/node-modules/compressing","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"fs","barcolor":"","fold":false,"box":[{"title":"读取","fold":false,"list":[{"prefix":"fs","tag":".createReadStream","suffix":"(path,opt)","desc":"按流读取，highWaterMark为64KB。","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_createreadstream_path_options","dot":""},{"prefix":"fs","tag":".readFile","suffix":"(path,encoding,fn)","desc":"异步地读取文件的全部内容。（会缓冲整个文件）\n同步方法： `fs.readFileSync(path,opt);`\n","url":"","summary":"+ path：可以为文件名或文件描述符\n+ encoding：如果没有指定 encoding，则返回原始的 buffer。\n```\nfs.readFile('/etc/passwd', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n```","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback","dot":""},{"prefix":"fs","tag":".copyFile","suffix":"(src,dest,fn)","desc":"复制文件。如果已存在，则覆盖它。\n同步方法：`fs.copyFileSync(src, dest[, flags])`","url":"","summary":"","reference":"","dot":""},{"prefix":"fse","tag":".copy","suffix":"(src,dest)","desc":"递归拷贝\n```\nconst fs = require('fs-extra')\nfs.copy('/tmp/myfile', '/tmp/mynewfile')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/copy.md","summary":"","reference":"","dot":""}]},{"title":"写入","fold":false,"list":[{"prefix":"fs","tag":".createWriteStream","suffix":"(path,opt)","desc":"创建可写流","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options","dot":""},{"prefix":"fs","tag":".writeFile","suffix":"(file,data,fn)","desc":"异步地将数据写入到一个文件，如果文件已存在则覆盖该文件。\n同步方法：`fs.writeFileSync(file, data[, options])`","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback","dot":""},{"prefix":"fs","tag":".appendFile","suffix":"(path,data,fn)","desc":"异步地将数据追加到文件，如果文件尚不存在则创建该文件。data 可以是字符串或 Buffer。\n同步方法：`fs.appendFileSync(path, data[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_appendfile_path_data_options_callback","dot":""},{"prefix":"fse","tag":".outputFile","suffix":"(file,data)","desc":"写入文件，如果不存在，自动创建\n导出json，`fs.outputJson(file, object[, options][, callback])` \n```\nfs.outputFile(file, 'hello!')\n.then(() => fs.readFile(file, 'utf8'))\n.then(data => {\n  console.log(data) // => hello!\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/outputFile.md","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".truncate","suffix":"(path,len,fn)","desc":"截断文件内容,len指定保留的长度（字节数）\n同步方法：`fs.truncateSync(path[, len])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_truncate_path_len_callback","dot":""}]},{"title":"开关","fold":false,"list":[{"prefix":"fd","tag":" ","suffix":"","desc":"在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。 每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。 在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。 Windows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。 为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。\n大多数操作系统限制在任何给定时间内可能打开的文件描述符的数量，因此当操作完成时关闭描述符至关重要。 如果不这样做将导致内存泄漏，最终导致应用程序崩溃。","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".open","suffix":"(path,fn(err,fd))","desc":"打开文件\n同步方法：`fs.openSync(path[, flags, mode])`","url":"","summary":"<table class=\"reference\">\n<tbody><tr><th>Flag</th><th>描述</th></tr>\n<tr><td>r</td><td>以读取模式打开文件。如果文件不存在抛出异常。</td></tr>\n<tr><td>r+</td><td> 以读写模式打开文件。如果文件不存在抛出异常。</td></tr>\n<tr><td>rs</td><td>以同步的方式读取文件。</td></tr>\n<tr><td>rs+</td><td>以同步的方式读取和写入文件。</td></tr>\n<tr><td>w</td><td>以写入模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>wx</td><td>类似 'w'，但是如果文件路径存在，则文件写入失败。</td></tr>\n<tr><td>w+</td><td>以读写模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>wx+</td><td>类似 'w+'， 但是如果文件路径存在，则文件读写失败。</td></tr>\n<tr><td>a</td><td>以追加模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>ax</td><td>类似 'a'， 但是如果文件路径存在，则文件追加失败。</td></tr>\n<tr><td>a+</td><td>以读取追加模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>ax+</td><td>类似 'a+'， 但是如果文件路径存在，则文件读取追加失败。</td></tr>\n</tbody></table>","reference":"","dot":""},{"prefix":"fs","tag":".read","suffix":"(fd,buffer,offset,length,position)","desc":"从 fd 指定的文件中读取数据\n同步方法：`fs.readSync(fd, buffer, offset, length, position)`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback","dot":""},{"prefix":"fs","tag":".write","suffix":"(fd,data,fn)","desc":"将 buffer 写入到 fd 指定的文件。\n`fs.write(fd, buffer[, offset[, length[, position]]], callback)`\n`fs.write(fd, string[, position[, encoding]], callback)`\n同步方法：\n`fs.writeSync(fd, buffer[, offset[, length[, position]]])`\n`fs.writeSync(fd, string[, position[, encoding]])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback","dot":""},{"prefix":"fs","tag":".writev","suffix":"(fd,buffers,fn)","desc":"使用 writev() 将一个 ArrayBufferView 数组写入 fd 指定的文件。\n同步方法：`fs.writevSync(fd, buffers[, position])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_writev_fd_buffers_position_callback","dot":""},{"prefix":"fs","tag":".close","suffix":"(fd,fn)","desc":"关闭文件\n同步方法：`fs.closeSync(fd)`","url":"","summary":"","reference":"","dot":""}]},{"title":"监听","fold":false,"list":[{"prefix":"fs","tag":".watch","suffix":"(path,fn)","desc":"监视 filename 的更改，其中 filename 是文件或目录","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_watch_filename_options_listener","dot":""},{"prefix":"fs","tag":".watchFile","suffix":"(file,fn)","desc":"监视 filename 的更改。","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_watchfile_filename_options_listener","dot":""},{"prefix":"fs","tag":".unwatchFile","suffix":"(file,fn)","desc":"停止监视 filename 的变化","url":"","summary":"","reference":"","dot":""},{"prefix":"watcher.on(","tag":"change","suffix":",fn)","desc":"+ change 当监视的目录或文件中发生更改时触发\n+ error 当监视文件时发生错误时触发\n+ close 当监视器停止监视更改时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"watcher","tag":".close()","suffix":"","desc":"给定的 fs.FSWatcher 停止监视更改。 一旦停止，则 fs.FSWatcher 对象将不再可用。","url":"","summary":"","reference":"","dot":""}]},{"title":"链接","fold":false,"list":[{"prefix":"link","tag":" ","suffix":"","desc":"# inode\n我们首先来看看 linux 系统里面的一个重要概念：inode。\n\n我们知道，文件存储在硬盘上，硬盘存储的最小单位是扇区（sector，每个扇区 512 B）。而操作系统读取文件时，按块读取（连续的多个扇区），也就是说文件存取的最小单位是块（block，块通常是 4 KB）。\n\n除了文件数据，我们还必须存储文件的元信息（如：文件大小、文件创建者、文件数据的块位置、文件读/写/执行权限、文件时间戳等等），这种存储文件元信息的结构就称为 inode。\n\n每个 inode 都有一个唯一的号码标志，linux 系统内部使用 inode 的号码来识别文件，并不使用文件名。我们打开一个文件时，系统首先找到文件名对应的 inode 号码，然后通过 inode 号码获取 inode 信息，最后根据 inode 信息中的文件数据所在的 block 读出数据。\n\n实际上，在 linux 系统中，目录也是一种文件。目录文件包含一系列目录项，每个目录项由两部分组成：所包含文件的文件名，以及该文件名对应的 inode 号码。我们可以使用 ls -i 来列出目录中的文件以及它们的 inode 号码。这其实也解释了仅更改目录的读权限，并不能实现读取目录下所有文件内容的原因，通常需要 chmod -R 来进行递归更改。\n\n总结下：\n\n硬盘存取的最小单位是扇区，文件存取的最小单位是块（连续的扇区）\n存储文件元信息（文件大小、创建者、块位置、时间戳、权限等非数据信息）的结构称为 inode\n每个 inode 拥有一个唯一号码，系统内部通过它来识别文件\n目录也是一种文件，其内容包含一系列目录项（每个目录项由文件的文件名和文件对应的 inode 号码组成）","url":"","summary":"# 硬链接\n一般情况，一个文件名“唯一”对应一个 inode。但是，linux 允许多个文件名都指向同一个 inode。这表示我们可以使用不同的文件名访问同样的内容；对文件内容进行修改将“反映”到所有文件；删除一个文件不影响另一个文件的访问 。这种机制就被称为“硬链接”。\n\n# 软链接\n软链接\n软链接类似于 windows 中的”快捷方式“。两个文件虽然 inode 号码不一样，但是文件 A 内部会指向文件 B 的 inode。当我们读取文件 A 时，系统就自动导向文件 B，文件 A 就是文件 B 的软链接（或者叫符号链接）。这表示我们同样可以使用不同的文件名访问同样的内容；对文件内容修改将”反映“到所有文件。但是当我们删除掉源文件 B 时，再访问文件 A 时会报错 “No such file or directory”。","reference":"参考资料|https://kohpoll.github.io/blog/2016/05/30/hardlink-symlink-require-in-nodejs/","dot":""},{"prefix":"fs","tag":".link","suffix":"(old,new,fn)","desc":"创建硬链接\n同步方法：`fs.linkSync(existingPath, newPath)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".unlink","suffix":"(path,fn)","desc":"异步地删除文件或符号链接。\n同步方法：`fs.unlinkSync(path)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".readlink","suffix":"(path,encoding,fn)","desc":"异步读取链接\n同步方法：`fs.readlinkSync(path[, options])` ","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_readlink_path_options_callback","dot":""},{"prefix":"fs","tag":".symlink","suffix":"(target,path,fn)","desc":"软链接。创建名为 path 的链接，该链接指向 target。\n同步方法：`fs.symlinkSync(target, path[, type])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_symlink_target_path_type_callback","dot":""}]},{"title":"权限","fold":false,"list":[{"prefix":"fs","tag":".chmod","suffix":"(path,mode,fn)","desc":"异步地更改文件的权限，0o<所有者7><群组6><其他人5>\n同步方法：`fs.chmodSync(path, mode)`\n强制执行：`fs.fchmod(fd, mode, callback)`\nMacOS：`fs.lchmod(path, mode, callback)`","url":"","summary":"权限数字\n<table><thead><tr><th>数字</th><th>说明</th></tr></thead><tbody><tr><td><code>7</code></td><td>可读、可写、可执行</td></tr><tr><td><code>6</code></td><td>可读、可写</td></tr><tr><td><code>5</code></td><td>可读、可执行</td></tr><tr><td><code>4</code></td><td>只读</td></tr><tr><td><code>3</code></td><td>可写、可执行</td></tr><tr><td><code>2</code></td><td>只写</td></tr><tr><td><code>1</code></td><td>只可执行</td></tr><tr><td><code>0</code></td><td>没有权限</td></tr></tbody></table>\n构造 mode 更简单的方法是使用三个八进制数字的序列（ 例如 765）。 最左边的数字（示例中的 7）指定文件所有者的权限。 中间的数字（示例中的 6）指定群组的权限。 最右边的数字（示例中的 5）指定其他人的权限。\n例如，八进制值 0o765 表示：\n所有者可以读取、写入和执行该文件。\n群组可以读和写入该文件。\n其他人可以读取和执行该文件。\n注意事项：在 Windows 上，只能更改写入权限，并且不会实现群组、所有者或其他人的权限之间的区别。","reference":"","dot":""},{"prefix":"fs","tag":".chown","suffix":"(path,uid,gid,fn)","desc":"异步地更改文件的所有者和群组\n同步方法：`fs.chownSync(path, uid, gid)`\n强制执行：`fs.fchown(fd, uid, gid, callback)`\nMacOS：`fs.lchown(path, uid, gid, callback)`","url":"","summary":"","reference":"","dot":""}]},{"title":"杂项","fold":false,"list":[{"prefix":"fs","tag":".stat","suffix":"(path,fn(err,stats))","desc":"同步方法：`fs.statSync(path[, options])`\nstats.isDirectory() 是否为目录\nstats.isFile() 是否为常规文件\nstats.isSocket() 是否为套接字\nstats.isSymbolicLink() 是否为软链接","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_class_fs_stats","dot":""},{"prefix":"fs","tag":".rename","suffix":"(old,new,fn)","desc":"文件重命名。如果 newPath 已存在，则覆盖它。\n同步方法：`fs.renameSync(oldPath, newPath)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".utimes","suffix":"(path,atime,mtime,fn)","desc":"更改 path 指向的对象的文件系统时间戳。\n同步方法：`fs.utimesSync(path, atime, mtime)`","url":"","summary":"atime 和 mtime 参数遵循以下规则：\n值可以是表示 Unix 纪元时间的数字、 Date 对象、或类似 '123456789.0' 的数值字符串。\n如果该值无法转换为数值、或值为 NaN、 Infinity 或 -Infinity，则抛出错误。","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"python","fold":false,"list":[{"prefix":"","tag":"open","suffix":"(file,flag)","desc":"`f = open('/Users/michael/test.txt', 'w')`","url":"https://www.runoob.com/python3/python3-file-methods.html","summary":"","reference":"","dot":""},{"prefix":"f","tag":".write","suffix":"(data)","desc":"`f.write('Hello, world!')`","url":"","summary":"","reference":"","dot":""},{"prefix":"f","tag":".close()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"crypto","barcolor":"","fold":false,"box":[{"title":"hash","fold":false,"list":[{"prefix":"crypto","tag":".createHash","suffix":"('md5',[opt])","desc":"创建并返回一个 Hash 对象，该对象可用于生成哈希摘要\n常用md5,sha1,sha256,sha512 \n","url":"","summary":"可选的 options 参数控制流的行为。 对于 XOF 哈希函数（例如 'shake256'）， outputLength 选项可用于指定所需的输出长度（以字节为单位）。","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_crypto_createhash_algorithm_options","dot":""},{"prefix":"hash","tag":".update","suffix":"(data)","desc":"默认字符串编码为UTF-8，也可以传入Buffer","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_hash_update_data_inputencoding","dot":""},{"prefix":"hash","tag":".digest","suffix":"('hex')","desc":"如果提供了 encoding，则返回字符串，否则返回 Buffer","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_hash_digest_encoding","dot":""},{"prefix":"crypto","tag":".getHashes()","suffix":"","desc":"支持的hash算法列表","url":"","summary":"algorithm 取决于平台上的 OpenSSL 的版本所支持的可用算法。\n新 `openssl list -digest-algorithms`\n旧 `openssl list-message-digest-algorithms`","reference":"","dot":""}]},{"title":"hmac","fold":false,"list":[{"prefix":"crypto","tag":".createHmac","suffix":"(alg,key)","desc":"加盐摘要\n```\nconst crypto = require('crypto');\nconst hmac = crypto.createHmac('sha256', '密钥');\nhmac.update('要创建哈希的数据');\nhmac.digest('hex')\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"hmac","tag":".update","suffix":"(data)","desc":"可通过多次调用或输入流","url":"","summary":"```\nconst input = fs.createReadStream(filename);\ninput.on('readable', () => {\n  // 哈希流只会生成一个元素。\n  const data = input.read();\n  if (data)\n    hmac.update(data);\n  else {\n    console.log(`${hmac.digest('hex')} ${filename}`);\n  }\n});\n```","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_class_hmac","dot":""},{"prefix":"hmac","tag":".digest","suffix":"([encoding])","desc":"计算使用 hmac.update() 传入的所有数据的 HMAC 摘要。 如果提供了 encoding，则返回字符串，否则返回 Buffer。\n调用 hmac.digest() 方法之后， Hmac 对象不能被再次使用。 多次调用 hmac.digest() 将会导致抛出错误。","url":"","summary":"","reference":"","dot":""}]},{"title":"Diffie-Hellman","fold":false,"list":[{"prefix":"crypto","tag":".createDiffieHellman","suffix":"(len)","desc":"密钥交换协议\n```\nconst crypto = require('crypto');\nconst assert = require('assert');\n\n// 生成 Alice 的密钥。\nconst alice = crypto.createDiffieHellman(2048);\nconst aliceKey = alice.generateKeys();\n\n// 生成 Bob 的密钥。\nconst bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());\nconst bobKey = bob.generateKeys();\n\n// 交换并生成密钥。\nconst aliceSecret = alice.computeSecret(bobKey);\nconst bobSecret = bob.computeSecret(aliceKey);\n\nassert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n```","url":"","summary":"","reference":"参考资料|https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640\n官方文档|http://nodejs.cn/api/crypto.html#crypto_class_diffiehellman","dot":""},{"prefix":"crypto","tag":".createECDH() ","suffix":"","desc":"椭圆曲线 Elliptic Curve Diffie-Hellman（ECDH）\n```\nconst crypto = require('crypto');\nconst assert = require('assert');\n\n// 生成 Alice 的密钥。\nconst alice = crypto.createECDH('secp521r1');\nconst aliceKey = alice.generateKeys();\n\n// 生成 Bob 的密钥。\nconst bob = crypto.createECDH('secp521r1');\nconst bobKey = bob.generateKeys();\n\n// 交换并生成密钥。\nconst aliceSecret = alice.computeSecret(bobKey);\nconst bobSecret = bob.computeSecret(aliceKey);\n\nassert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n```","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_class_ecdh","dot":""},{"prefix":"crypto","tag":".getCurves()","suffix":"","desc":"查看全部椭圆曲线算法","url":"","summary":"","reference":"","dot":""}]},{"title":"AES","fold":false,"list":[{"prefix":"crypto","tag":".createCipher","suffix":"('aes192',key)","desc":"对称加密算法,常用如aes192，aes-128-ecb，aes-256-cbc等\n```\nfunction aesEncrypt(data, key) {\n    const cipher = crypto.createCipher('aes192', key);\n    var crypted = cipher.update(data, 'utf8', 'hex');\n    crypted += cipher.final('hex');\n    return crypted;\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"crypto","tag":".createDecipher","suffix":"('aes192',key)","desc":"```\nfunction aesDecrypt(encrypted, key) {\n    const decipher = crypto.createDecipher('aes192', key);\n    var decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"crypto","tag":".getCiphers()","suffix":"","desc":"支持的对称加密算法列表","url":"","summary":"","reference":"","dot":""}]},{"title":"RSA","fold":false,"list":[{"prefix":"crypto","tag":".privateEncrypt","suffix":"(prvKey,data)","desc":"非对称加密算法\n私钥加密 `let enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, 'utf8'));`\n公钥解密 `let dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv)`\n","url":"","summary":"","reference":"RSA算法原理（一）|http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\nRSA算法原理（二）|http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html","dot":""},{"prefix":"crypto","tag":".publicEncrypt","suffix":"(pubKey,data)","desc":"RSA加密的原始信息必须小于Key的长度\n公钥加密 `let enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, 'utf8'))`\n私钥解密 `let dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub)`","url":"","summary":"","reference":"","dot":""}]},{"title":"Misc","fold":false,"list":[{"prefix":"crypto","tag":".randomBytes","suffix":"(len).toString('hex')","desc":"生成随机字符\n```\nconst buf = crypto.randomBytes(256);\nconsole.log(\n  `${buf.length} 位的随机数据: ${buf.toString('hex')}`);\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"uuid","suffix":"","desc":"# Random UUIDs\n```\nimport { v4 as uuidv4 } from 'uuid';\nuuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'\n```\n# Timestamp UUIDs\n```\nimport { v1 as uuidv1 } from 'uuid';\nuuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8b2d-1b9d6bcdbbfd'\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/uuid","dot":""}]},{"title":"web crypto api","fold":false,"list":[{"prefix":"window","tag":".crypto","suffix":".subtle","desc":"","url":"","summary":"","reference":"参考资料|https://cloud.tencent.com/developer/article/1171800\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/SubtleCrypto","dot":""},{"prefix":"crypto.subtle","tag":".digest","suffix":"(alg,data)","desc":"摘要算法\n```\ncrypto.subtle.digest('SHA-256', new Uint8Array([1,2,3,4]))\n.then((hash)=>{\n    let arr = new Uint8Array(hash)\n    let str = ''\n    for(bit of arr){\n        str += bit.toString(16)\n    }\n})\n```","url":"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest","summary":"","reference":"MDN|https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"hash","fold":false,"list":[{"prefix":"md5|sha1","tag":".update","suffix":"(val)","desc":"```\nimport hashlib\nhashlib.md5()\n```","url":"","summary":"MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。","reference":"","dot":""},{"prefix":"md5|sha1","tag":".hexdigest()","suffix":"","desc":"MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。\nSHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示","url":"","summary":"","reference":"","dot":""}]},{"title":"hmac","fold":false,"list":[{"prefix":"hmac","tag":".new","suffix":"(key,data,digestmod='MD5')","desc":"```\nimport hmac\nmessage = b'Hello, world!'\nkey = b'secret'\nh = hmac.new(key, message, digestmod='MD5')\n```\n如果消息很长，可以多次调用h.update(msg)","url":"","summary":"","reference":"","dot":""},{"prefix":"h","tag":".hexdigest()","suffix":"","desc":"使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"process","barcolor":"","fold":false,"box":[{"title":"属性","fold":false,"list":[{"prefix":"process","tag":".argv","suffix":"","desc":"返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数\n+ `process.argv0` 当 Node.js 启动时传入的 argv[0] 的原始值的只读副本\n+ `process.execPath` 返回启动 Node.js 进程的可执行文件的绝对路径名\n+ `process.execArgv` 返回当 Node.js 进程被启动时，Node.js 特定的命令行选项,这些选项在 process.argv 属性返回的数组中不会出现","url":"","summary":"\n","reference":"","dot":""},{"prefix":"process","tag":".env","suffix":"","desc":"返回包含用户环境的对象\n可以修改此对象，但这些修改不会反映到 Node.js 进程之外，或者（除非明确请求）反映到其他 Worker 线程。","url":"","summary":"通常的做法是，新建一个环境变量NODE_ENV，用它确定当前所处的开发阶段，生产阶段设为production，开发阶段设为develop或staging，然后在脚本中读取process.env.NODE_ENV即可。\n`export NODE_ENV=production && node app.js`","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_env","dot":""},{"prefix":"process","tag":".cwd()","suffix":"","desc":"返回 Node.js 进程的当前工作目录\n`process.chdir(dir)`  变更 Node.js 进程的当前工作目录，如果变更目录失败会抛出异常","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".pid","suffix":"","desc":"`process.pid` 返回进程的 PID\n`process.ppid` 返回当前父进程的 PID\n`process.title` 返回当前进程标题,可以自定义该值","url":"","summary":"","reference":"","dot":""}]},{"title":"IPC","fold":false,"list":[{"prefix":"process","tag":".channel","suffix":"","desc":"如果 Node.js 进程是由 IPC 通道（参阅子进程文档）方式创建的， process.channel 属性保存 IPC 通道的引用。 如果 IPC 通道不存在，则此属性值为 undefined。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".send","suffix":"(msg,handle,fn)","desc":"进程间发送消息\n消息会进行序列化和解析","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"message","suffix":",fn)","desc":"收到消息时","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".disconnect()","suffix":"","desc":"关闭到父|子进程的 IPC 通道","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"disconnect","suffix":",fn)","desc":"IPC 通道关闭时将触发 'disconnect' 事件","url":"","summary":"调用父进程中的 subprocess.disconnect() 或子进程中的 process.disconnect() 后会触发 'disconnect' 事件。 断开连接后就不能再发送或接收信息，且 subprocess.connected 属性为 false。","reference":"","dot":""}]},{"title":"退出","fold":false,"list":[{"prefix":"process","tag":".exit","suffix":"(0)","desc":"以退出状态 code 指示 Node.js 同步地终止进程。\n0成功 1失败","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/process.html#process_process_exit_code","dot":""},{"prefix":"process","tag":".exitCode","suffix":"","desc":"指定错误码，抛出异常退出\n```\nprocess.exitCode = 1;\nthrow new Error(\"xx condition failed\");\n```","url":"","summary":"`process.exit()` 手动退出当前进程\n+ 如果参数大于0表示执行失败\n+ 如果等于0表示执行成功\n注意，process.exit()很多时候是不需要的。因为如果没有错误，一旦事件循环之中没有待完成的任务，Node 本来就会退出进程，不需要调用process.exit(0)。这时如果调用了，进程会立刻退出，不管有没有异步任务还在执行，所以不如等 Node 自然退出。另一方面，如果发生错误，Node 往往也会退出进程，也不一定要调用process.exit(1)。","reference":"","dot":""},{"prefix":"process.on(","tag":"exit","suffix":",fn(code))","desc":"当 Node.js 进程因以下原因之一即将退出时，则会触发 'exit' 事件：\n+ 显式调用 `process.exit()` 方法；\n+ Node.js 事件循环不再需要执行任何其他工作。\n此时无法阻止退出事件循环，并且一旦所有 'exit' 事件的监听器都已完成运行时，Node.js 进程将终止。\n\n注意，此时回调函数只能执行*同步*操作，不能包含异步操作，因为执行完回调函数，进程就会退出，无法监听到回调函数的操作结果。","url":"","summary":"# 退出码\n正常情况下，如果没有异步操作正在等待，那么 Node.js 会以状态码 0 退出，其他情况下，会用如下的状态码:\n1 未捕获异常 - 有一个未被捕获的异常, 并且没被 domain 或 'uncaughtException' 事件处理器处理。\n2 - 未被使用 (Bash 为防内部滥用而保留)\n3 内部的 JavaScript 解析错误 - Node.js 内部的 JavaScript 源代码在引导进程中导致了一个语法解析错误。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n4 内部的 JavaScript 执行失败 - 引导进程执行 Node.js 内部的 JavaScript 源代码时，返回函数值失败。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n5 致命错误 - 在 V8 中有一个致命的错误。 比较典型的是以 FATALERROR 为前缀从 stderr 打印出来的消息。\n6 非函数的内部异常处理 - 发生了一个内部异常，但是内部异常处理函数被设置成了一个非函数，或者不能被调用。\n7 内部异常处理运行时失败 - 有一个不能被捕获的异常，在试图处理这个异常时，处理函数本身抛出了一个错误。 这是可能发生的, 比如, 如果一个 'uncaughtException' 或者 domain.on('error') 处理函数抛出了一个错误。\n8 - 未被使用，在之前版本的 Node.js, 退出码 8 有时候表示一个未被捕获的异常。\n9 - 不可用参数 - 也许是某个未知选项没有确定，或者没给必需要的选项填值。\n10 内部的 JavaScript 运行时失败 - 调用引导函数时，引导进程执行 Node.js 内部的 JavaScript 源代码抛出错误。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n12 不可用的调试参数 - --inspect 和/或 --inspect-brk 选项已设置，但选择的端口号无效或不可用。\n>128 退出信号 - 如果 Node.js 接收到致命信号, 诸如 SIGKILL 或 SIGHUP，那么它的退出代码将是 128 加上信号的码值。 这是 POSIX 的标准做法，因为退出码被定义为 7 位整数，并且信号退出设置高位，然后包含信号码值。 例如，信号 SIGABRT 的值为 6，因此预期的退出代码将为 128 + 6 或 134。","reference":"","dot":""},{"prefix":"process.on(","tag":"beforeExit","suffix":",fn)","desc":"对于导致显式终止的条件，不会触发 'beforeExit' 事件，例如调用 process.exit() 或未捕获的异常。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".abort()","suffix":"","desc":"使 Node.js 进程立即结束，并生成一个核心文件","url":"","summary":"Worker 线程中没有此特性。","reference":"","dot":""}]},{"title":"信号","fold":false,"list":[{"prefix":"process","tag":".kill","suffix":"(pid,[signal])","desc":"对指定ID的线程发送信号，默认为SIGTERM信号","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_kill_pid_signal","dot":""},{"prefix":"process","tag":".kill","suffix":"([signal])","desc":"子进程或cluster worker自杀\n默认信号SIGTERM。如果成功，则此函数返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"<sign>","suffix":",fn)","desc":"当 Node.js 进程接收到一个信号时，会触发信号事件。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_signal_events","dot":""}]},{"title":"异常","fold":false,"list":[{"prefix":"process.on(","tag":"error","suffix":",fn)","desc":"每当出现以下情况时触发 'error' 事件：\n无法衍生进程；\n无法杀死进程；\n向子进程发送消息失败。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"uncaughtException","suffix":",fn(err,origin))","desc":"只要有错误没有捕获，就会触发这个事件。\n正确使用 'uncaughtException' 事件的方式，是用它在进程结束前执行一些已分配资源（比如文件描述符，句柄等等）的同步清理操作","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_event_uncaughtexception","dot":""},{"prefix":"process.on(","tag":"rejectionHandled","suffix":")","desc":"每当 Promise 被拒绝并且错误处理函数附加到它（例如，使用 promise.catch()）晚于一个 Node.js 事件循环时，就会触发 'rejectionHandled' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"unhandledRejection","suffix":")","desc":"如果在事件循环的一次轮询中，一个 Promise 被拒绝，并且此 Promise 没有绑定错误处理器， 'unhandledRejection 事件会被触发。 ","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"warning","suffix":",fn)","desc":"任何时候 Node.js 触发进程告警，都会触发 'warning' 事件。\n告警不是 Node.js 和 Javascript 错误处理流程的正式组成部分。 一旦探测到可能导致应用性能问题，缺陷或安全隐患相关的代码实践，Node.js 就可发出告警。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".emitWarning","suffix":"(msg,opt)","desc":"触发自定义或应用特定的进程警告\n","url":"","summary":"```\nprocess.emitWarning('出错啦', {\n  code: 'MY_WARNING',\n  detail: '一些额外的信息'\n});\n```","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_emitwarning_warning_options","dot":""}]},{"title":"优先级","fold":false,"list":[{"prefix":"process","tag":".nextTick","suffix":"(fn)","desc":"放到当前一轮事件循环（Event Loop）的尾部\nsetTimeout(f,0)是将任务放到下一轮事件循环的头部，因此nextTick会比它先执行。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".setPriority","suffix":"([pid],priority)","desc":"尝试为 pid 指定的进程设置调度优先级。 \n如果未提供 pid 或者为 0，则使用当前进程的进程 ID。\npriority 输入必须是 -20（高优先级）到 19（低优先级）之间的整数。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".getPriority","suffix":"([pid])","desc":"返回由 pid 指定的进程的调度优先级。\n如果未提供 pid 或者为 0，则返回当前进程的优先级。","url":"","summary":"","reference":"","dot":""}]},{"title":"信息","fold":false,"list":[{"prefix":"process","tag":".uptime()","suffix":"","desc":"返回当前 Node.js 进程运行时间秒长","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".memoryUsage()","suffix":"","desc":"返回 Node.js 进程的内存使用情况的对象，该对象每个属性值的单位为字节。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".resourceUsage()","suffix":"","desc":"资源使用","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".config","suffix":"","desc":"返回一个 Object，其中包含用于编译当前 Node.js 可执行文件的配置选项的 JavaScript 表示形式。 这与运行 ./configure 脚本时生成的 config.gypi 文件相同。","url":"","summary":"","reference":"","dot":""}]},{"title":"环境","fold":false,"list":[{"prefix":"process","tag":".platform","suffix":"","desc":"返回字符串，标识 Node.js 进程运行其上的操作系统平台。\n当前可能的值有：\n'aix'\n'darwin'\n'freebsd'\n'linux'\n'openbsd'\n'sunos'\n'win32'","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".arch","suffix":"","desc":"为其编译 Node.js 二进制文件的操作系统的 CPU 架构。 \n可能的值有：'arm'、 'arm64'、 'ia32'、 'mips'、 'mipsel'、 'ppc'、 'ppc64'、 's390'、 's390x'、 'x32' 和 'x64'。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".version","suffix":"","desc":"返回 Node.js 的版本信息","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"child_process","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"child_process.","tag":"exec","suffix":"(cmd,fn)","desc":"新建一个子进程，然后缓存它的运行结果，运行结束后调用回调函数，返回childprocess实例。\n同步方法：`child_process.execSync(command[, options])`\n适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。","url":"","summary":"回调函数参数：error, stdout, stderr\nexec方法会直接调用bash（/bin/sh程序）来解释命令","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback","dot":""},{"prefix":"child_process","tag":".spawn","suffix":"(cmd,[argarr])","desc":"与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。\n同步方法：`child_process.spawnSync(command[, args][, options])`\n适用于返回大量数据，例如图像处理，二进制数据处理","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options","dot":""},{"prefix":"child_process","tag":".execFile","suffix":"(file,[argarr],fn)","desc":"直接执行特定的程序，参数作为数组传入，不会被bash解释\n同步方法：`child_process.execFileSync(file[, args][, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback","dot":""},{"prefix":"child_process","tag":".fork","suffix":"(file)","desc":"fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。","url":"","summary":"衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。","reference":"参考资料|https://juejin.im/post/5d06d6ddf265da1b9570562a","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"child.on(","tag":"close","suffix":",fn)","desc":"当子进程的 stdio 流已被关闭时会触发 'close' 事件。 这与 'exit' 事件不同，因为多个进程可能共享相同的 stdio 流。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"cluster","barcolor":"","fold":false,"box":[{"title":"主进程","fold":false,"list":[{"prefix":"pm2 start app.js","tag":" -i 4","suffix":"","desc":"集群，-i 参数用来告诉PM2以cluster\\_mode的形式运行你的app（对应的叫fork_mode），后面的数字表示要启动的工作线程的数量。如果给定的数字为0，PM2则会根据你CPU核心的数量来生成对应的工作线程。注意一般在生产环境使用cluster\\_mode模式，测试或者本地环境一般使用fork模式，方便测试到错误。","url":"","summary":"","reference":"官方文档|https://pm2.keymetrics.io/docs/usage/quick-start/","dot":""},{"prefix":"cluster","tag":".isMaster","suffix":"","desc":"`cluster.isMaster` 如果该进程是主进程，则为 true。\n`cluster.isWorker` 如果该进程不是主进程，则为 true","url":"","summary":"","reference":"参考资料|https://juejin.im/post/5d43017be51d4561f40adcf9#heading-17","dot":""},{"prefix":"cluster","tag":".fork()","suffix":"","desc":"衍生出一个新的工作进程。","url":"","summary":"```\nvar cluster = require('cluster');\n\nif(cluster.isMaster) {\n  var numWorkers = require('os').cpus().length;\n  console.log('Master cluster setting up ' + numWorkers + ' workers...');\n\n  for(var i = 0; i < numWorkers; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('online', function(worker) {\n    console.log('Worker ' + worker.process.pid + ' is online');\n  });\n\n  cluster.on('exit', function(worker, code, signal) {\n    console.log('Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal);\n    console.log('Starting a new worker');\n    cluster.fork();\n  });\n}\n```","reference":"参考资料|https://zhuanlan.zhihu.com/p/74879045","dot":""},{"prefix":"cluster.on(","tag":"<event>","suffix":",fn)","desc":"+ fork 当主进程衍生工作进程时触发\n+ online 当工作进程运行时触发\n+ listening 任意worker触发时触发\n+ message 从任意工作进程收到消息时\n+ disconnect 任意worker工作进程的 IPC 管道被断开后触发。 可能导致事件触发的原因包括：工作进程优雅地退出、被杀死、或手动断开连接\n+ exit 任意worker退出时","url":"","summary":"","reference":"","dot":""},{"prefix":"cluster.","tag":"disconnect","suffix":"(fn)","desc":"在 cluster.workers 的每个工作进程中调用 .disconnect()","url":"","summary":"","reference":"","dot":""}]},{"title":"子进程","fold":false,"list":[{"prefix":"worker.on(","tag":"<event>","suffix":",fn)","desc":"'message' 事件\n+ online 就绪时\n+ listening 当调用 listen() 时触发\n+ disconnect 断开连接时\n+ message 收到消息时\n+ exit 退出时","url":"","summary":"","reference":"参考资料|https://zhuanlan.zhihu.com/p/74879045","dot":""},{"prefix":"worker","tag":".id","suffix":"","desc":"每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在 id 里面。\n当工作进程还存活时，这个编号可以作为在 cluster.workers 中的索引。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"worker_threads","barcolor":"","fold":false,"box":[{"title":"主线程","fold":false,"list":[{"prefix":"","tag":"isMainThread","suffix":"","desc":"当前线程为主线程时返回true","url":"","summary":"```\nconst {\n    Worker,\n    isMainThread,\n    threadId,\n    workerData,\n    SHARE_ENV\n} = require(\"worker_threads\");\n\n//主线程\nif (isMainThread) {\n    console.log(threadId);  //主线程ID\n    var worker = new Worker(__filename, {\n        workerData: \"Hello, world!\",    //传递数据\n        env: SHARE_ENV  //共享环境变量\n    });\n\n    worker.on(\"exit\", () => {\n        console.log(process.env.SET_IN_WORKER);\n    });\n\n//工作线程\n} else {\n    console.log(threadId);  //子线程ID\n    // console.log(workerData);    //被传递数据\n    process.env.SET_IN_WORKER = \"foo\";  //设置共享环境变量\n}\n```","reference":"参考资料|https://juejin.im/post/5d736a675188254faf71521a","dot":""},{"prefix":"","tag":"new Worker","suffix":"(path,opt)","desc":"# opt\nenv ：SHARE_ENV //主线程与子线程可共享环境变量读写\nworkerData : 传递数据 \nresourceLimits ： 资源限制","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/worker_threads.html#worker_threads_new_worker_filename_options","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(data,[transferList])","desc":"向工作线程发送数据","url":"","summary":"","reference":"","dot":""},{"prefix":"worker.on(","tag":"message","suffix":",fn)","desc":"收到工作线程消息时","url":"","summary":"","reference":"","dot":""},{"prefix":"worker.on(","tag":"<event>","suffix":",fn)","desc":"工作线程的其他事件\n+ online 工作线程就绪\n+ error 错误事件\n+ exit 退出事件\n ","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".terminate()","suffix":"","desc":"关闭线程","url":"","summary":"","reference":"","dot":""}]},{"title":"工作线程","fold":false,"list":[{"prefix":"parentPort.on(","tag":"message","suffix":",fn)","desc":"接收主线程消息","url":"","summary":"","reference":"","dot":""},{"prefix":"parentPort","tag":".postMessage","suffix":"(data)","desc":"向主主线程发送消息","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"workerData","suffix":"","desc":"初始化时由主线程拷贝传递的数据","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"threadId","suffix":"","desc":"线程唯一ID","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"io","barcolor":"","fold":false,"box":[{"title":"process","fold":false,"list":[{"prefix":"ps","tag":".stdin","suffix":".on(data,fn(data))","desc":"返回连接到 stdin (fd 0) 的流。 它是一个 net.Socket 流（也就是双工流）\n由于stdin和stdout都部署了stream接口，所以可以使用stream接口的方法\n`process.stdin` 当前进程\n`child.stdin` 创建的子进程实例，可绑定data事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ps","tag":".stdout","suffix":".on(data,fn(data))","desc":"返回连接到 stdout (fd 1) 的流。它是一个 net.Socket 流（也就是双工流），","url":"","summary":"","reference":"","dot":""},{"prefix":"ps","tag":".stderr","suffix":".on(data,fn(data))","desc":"返回连接到 stderr (fd 2) 的流。 它是一个 net.Socket 流（也就是双工流）","url":"","summary":"","reference":"","dot":""}]},{"title":"lib","fold":false,"list":[{"prefix":"","tag":"commander","suffix":"","desc":"","url":"https://www.npmjs.com/package/commander","summary":"","reference":"","dot":""},{"prefix":"","tag":"chalk","suffix":"","desc":"","url":"https://www.npmjs.com/package/chalk","summary":"","reference":"","dot":""}]}]},{"title":"os","barcolor":"","fold":false,"box":[{"title":"信息","fold":false,"list":[{"prefix":"os","tag":".freemem()","suffix":"","desc":"以整数的形式返回空闲的系统内存量（以字节为单位）\n`os.totalmem()` 以整数的形式返回系统的内存总量（以字节为单位）。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".loadavg()","suffix":"","desc":"返回一个数组，包含 1、5 和 15 分钟的平均负载。\n平均负载是系统活动性的测量，由操作系统计算得出，并表现为一个分数。\n平均负载是 UNIX 特定的概念。 在 Windows 上，其返回值始终为 [0, 0, 0]。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".uptime()","suffix":"","desc":"返回系统的正常运行时间（以秒为单位）。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".networkInterfaces()","suffix":"","desc":"返回一个对象，该对象包含已分配了网络地址的网络接口。\n返回的对象上的每个键都标识了一个网络接口。 关联的值是一个对象数组，每个对象描述了一个分配的网络地址。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/os.html#os_os_networkinterfaces","dot":""},{"prefix":"os","tag":".hostname()","suffix":"","desc":"以字符串的形式返回操作系统的主机名。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".homedir()","suffix":"","desc":"返回当前用户的主目录的字符串路径。\n在 POSIX 上，使用 $HOME 环境变量（如果有定义）。 否则，使用有效的 UID 来查找用户的主目录。\n在 Windows 上，使用 USERPROFILE 环境变量（如果有定义）。 否则，使用当前用户的配置文件目录的路径。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".tmpdir()","suffix":"","desc":"以字符串的形式返回操作系统的默认临时文件目录。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".userInfo()","suffix":"","desc":"返回关于当前有效用户的信息。\n在 POSIX 平台上，这通常是密码文件的子集。 返回的对象包含 username、 uid、 gid、 shell 和 homedir。 \n在 Windows 上，则 uid 和 gid 字段为 -1，且 shell 为 null。","url":"","summary":"","reference":"","dot":""}]},{"title":"环境","fold":false,"list":[{"prefix":"os","tag":".constants","suffix":"","desc":"包含错误码、进程信号等常用的操作系统特定的常量。 定义的特定常量在 OS 常量中描述。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".cpus()","suffix":"","desc":"返回一个对象数组，其中包含有关每个逻辑 CPU 内核的信息。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/os.html#os_os_cpus","dot":""},{"prefix":"os.","tag":"EOL","suffix":"","desc":"操作系统特定的行末标志。\n在 POSIX 上是 \\n。\n在 Windows 上是 \\r\\n。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".endianness()","suffix":"","desc":"返回一个字符串，该字符串标识为其编译 Node.js 二进制文件的 CPU 的字节序。\n可能的值有， 'BE' 用于大端字节序， 'LE' 用于小端字节序。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".platform()","suffix":"","desc":"返回标识操作系统平台的字符串。 该值在编译时设置。\n可能的值有 'aix'、 'darwin'、 'freebsd'、 'linux'、 'openbsd'、 'sunos' 和 'win32'。\n`os.type()` 返回操作系统名字。 例如，在 Linux 上返回 'Linux'，在 macOS 上返回 'Darwin'，在 Windows 上返回 'Windows_NT'。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".arch()","suffix":"","desc":"返回为其编译 Node.js 二进制文件的操作系统的 CPU 架构。 \n可能的值有：'arm'、 'arm64'、 'ia32'、 'mips'、 'mipsel'、 'ppc'、 'ppc64'、 's390'、 's390x'、 'x32' 和 'x64'","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".release()","suffix":"","desc":"以字符串的形式返回操作系统。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"io","fold":false,"list":[{"prefix":"","tag":"input","suffix":"(msg)","desc":"等待用户输入","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"print","suffix":"(val,..)","desc":"print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"","url":"","summary":"","reference":"","dot":""}]}]}]}]}