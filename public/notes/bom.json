{"version":1585048658556,"name":"bom","data":[{"column":[{"title":"Navigator","barcolor":"","fold":false,"box":[{"title":"代理","fold":false,"list":[{"prefix":"navigator","tag":".userAgent","suffix":"","desc":"返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。","url":"","summary":"","reference":"","dot":""},{"prefix":"navigator","tag":".platform","suffix":"","desc":"返回用户的操作系统信息，比如MacIntel、Win32、Linux x86_64等 。","url":"","summary":"","reference":"","dot":""},{"prefix":"navigator","tag":".language","suffix":"","desc":"浏览器的首选语言。该属性只读。\nnavigator.languages属性返回一个数组，表示用户可以接受的语言","url":"","summary":"","reference":"","dot":""}]},{"title":"地理","fold":false,"list":[{"prefix":"navigator","tag":".geolocation","suffix":"","desc":"返回一个 Geolocation 对象，包含用户地理位置的信息","url":"","summary":"","reference":"","dot":""},{"prefix":"geo","tag":".getCurrentPosition","suffix":"(suc(pos),fail(err),opt)","desc":"得到用户的当前位置","url":"","summary":"# opt\n+ enableHighAccuracy：布尔值，是否返回高精度结果。如果设为true，可能导致响应时间变慢或（移动设备的）功耗增加；反之，如果设为false，设备可以更快速地响应。默认值为false。\n+ timeout：正整数，表示等待查询的最长时间，单位为毫秒。默认值为Infinity。\n+ maximumAge：正整数，表示可接受的缓存最长时间，单位为毫秒。如果设为0，表示不返回缓存值，必须查询当前的实际位置；如果设为Infinity，必须返回缓存值，不管缓存了多少时间。默认值为0。","reference":"参考资料|https://wangdoc.com/webapi/geolocation.html","dot":""},{"prefix":"geo","tag":".watchPosition","suffix":"(suc(pos),fail(err),opt)","desc":"监听用户位置变化,返回一个id","url":"","summary":"","reference":"","dot":""},{"prefix":"geo","tag":".clearWatch","suffix":"(id)","desc":"取消watchPosition()方法指定的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"pos","tag":".coords","suffix":"","desc":"coords属性指向一个对象，包含了用户的位置信息\ncoords.latitude：纬度\ncoords.longitude：经度\ncoords.accuracy：精度\ncoords.altitude：海拔\ncoords.altitudeAccuracy：海拔精度（单位：米）\ncoords.heading：以360度表示的方向\ncoords.speed：每秒的速度（单位：米）\n大多数桌面浏览器不提供上面列表的后四个值。","url":"","summary":"","reference":"","dot":""},{"prefix":"pos","tag":".timestamp","suffix":"","desc":"返回获得位置信息的具体时间","url":"","summary":"","reference":"","dot":""},{"prefix":"err.","tag":"code","suffix":"","desc":"geoError的参数也是一个event对象。event.code属性表示错误类型，有四个值\n0：未知错误，浏览器没有提示出错的原因，相当于常量event.UNKNOWN\\_ERROR。\n1：用户拒绝授权，相当于常量event.PERMISSION_DENIED。\n2：没有得到位置，GPS或其他定位机制无法定位，相当于常量event.POSITION\\_UNAVAILABLE。\n3：超时，GPS没有在指定时间内返回结果，相当于常量event.TIMEOUT。","url":"","summary":"","reference":"","dot":""},{"prefix":"err","tag":".message","suffix":"","desc":"字符串，表示错误的描述。","url":"","summary":"","reference":"","dot":""}]},{"title":"状态","fold":true,"list":[{"prefix":"navigator","tag":".onLine","suffix":"","desc":"返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。\n有时，浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的onLine属性会返回true，所以不能假定只要是true，用户就一定能访问互联网。不过，如果是false，可以断定用户一定离线。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"offline","suffix":"","desc":"离线事件","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"online","suffix":"","desc":"上线事件","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Location","barcolor":"","fold":false,"box":[{"title":"location","fold":false,"list":[{"prefix":"window","tag":".isSecureContext","suffix":"","desc":"返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是true，否则就是false。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".<prop>","suffix":"","desc":"+ location.href：整个 URL。\n+ location.origin：URL 的协议、主机名和端口。\n+ location.protocol：当前 URL 的协议，包括冒号（:）。\n+ location.host：主机。如果端口不是协议默认的80和433，则还会包括冒号（:）和端口。\n+ location.hostname：主机名，不包括端口。\n+ location.port：端口号。\n+ location.pathname：URL 的路径部分，从根路径/开始。\n+ location.search：查询字符串部分，从问号?开始。\n+ location.hash：片段字符串部分，从#开始。\n+ location.username：域名前面的用户名。\n+ location.password：域名前面的密码。\n只有origin属性是只读的，其他属性都可写\n","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".assign","suffix":"(url)","desc":"立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".replace","suffix":"(url)","desc":"浏览器立刻跳转到新的 URL。\nreplace会在浏览器的浏览历史History里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".reload","suffix":"([true])","desc":"重新加载当前网址，相当于按下浏览器的刷新按钮。\n它接受一个布尔值作为参数。如果参数为true，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即scrollTop === 0）。如果参数是false或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"hashchange","suffix":"","desc":"变更锚点#","url":"","summary":"","reference":"","dot":""}]},{"title":"URL","fold":false,"list":[{"prefix":"","tag":"new URL","suffix":"(url,[base])","desc":"创建一个url实例\n包含属性：\n+ hash\n+ host\n+ hostname\n+ href\n+ origin\n+ password\n+ pathname\n+ port\n+ protocol\n+ search\n+ **searchParams** (已可直接使用)\n+ username","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/location.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/URL","dot":""},{"prefix":"url","tag":".toString()","suffix":"","desc":"返回包含整个 URL 的USVString。 它是URL.href的同义词，尽管它不能用于修改值。\n返回包含整个 URL 的USVString。 它返回与href属性相同的字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"URL","tag":".createObjectURL","suffix":"(blob)","desc":"参数：用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。​\n返回：一个DOMString包含了一个对象 URL，该 URL 可用于指定源 object的内容。\n\n## demo\n```js\nconst blob = new Blob([JSON.stringify(node)], { type: \"application/json\" });\nconst url = URL.createObjectURL(blob);\nconst a = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\");\na.href = url;\na.download = `${node.name}.json`;\na.click();\n```","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL\n实例参考|https://segmentfault.com/a/1190000041965165","dot":""},{"prefix":"URL","tag":".revokeObjectURL","suffix":"(objurl)","desc":"释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象。\n当你结束使用某个 URL 对象之后，应该通过调用这个方法来让浏览器知道不用在内存中继续保留对这个文件的引用了。","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL","dot":""}]},{"title":"URLSearchParams","fold":false,"list":[{"prefix":"","tag":"new URLSearchParams","suffix":"(val)","desc":"构造、解析和处理 URL 的查询字符串.\n对查询字符串自动编码","url":"","summary":"```\n// 方法一：传入字符串\nvar params = new URLSearchParams('?foo=1&bar=2');\n// 等同于\nvar params = new URLSearchParams(document.location.search);\n\n// 方法二：传入数组\nvar params = new URLSearchParams([['foo', 1], ['bar', 2]]);\n\n// 方法三：传入对象\nvar params = new URLSearchParams({'foo' : 1 , 'bar' : 2});\n```","reference":"参考资料|https://wangdoc.com/javascript/bom/location.html#urlsearchparams-%E5%AF%B9%E8%B1%A1\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams","dot":""},{"prefix":"params","tag":".toString()","suffix":"","desc":"返回实例的字符串形式","url":"","summary":"```\nvar params = new URLSearchParams({version: 2.0});\nwindow.location.href = location.pathname + '?' + params;\n```\n上面代码中，location.href赋值时，可以直接使用params对象。这时就会自动调用toString方法。","reference":"","dot":""},{"prefix":"params","tag":".get","suffix":"(key)","desc":"读取查询字符串里面的指定键,不存在返回null\n`params.getAll()` 方法返回一个数组，成员是指定键的所有键值。\n","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".has","suffix":"(key)","desc":"返回一个布尔值，表示查询字符串是否包含指定的键名","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".append","suffix":"(key,val)","desc":"追加一个查询参数,没有返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".set","suffix":"(key,val)","desc":"设置查询字符串的键值.如果是已经存在的键，键值会被改写，否则会被追加。","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".delete","suffix":"(key)","desc":"删除指定的查询参数","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".sort()","suffix":"","desc":"对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".entries()","suffix":"","desc":"URLSearchParams实例有遍历器接口，可以用for...of循环遍历\nparams.keys()\nparams.values()\nparams.entries()","url":"","summary":"```\nvar params = new URLSearchParams({'foo': 1 , 'bar': 2});\n\nfor (var p of params) {\n  console.log(p[0] + ': ' + p[1]);\n}\n// foo: 1\n// bar: 2\n```","reference":"","dot":""}]}]},{"title":"History","barcolor":"","fold":false,"box":[{"title":"访问","fold":false,"list":[{"prefix":"history","tag":".length","suffix":"","desc":"当前窗口一共访问过的网址个数","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".back()","suffix":"","desc":"等同`history.go(-1)`\n移动到上一个网址，等同于点击浏览器的后退键。\n注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".forward()","suffix":"","desc":"移动到下一个网址，等同于点击浏览器的前进键。","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".go","suffix":"(n)","desc":"接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如go(1)相当于forward()，go(-1)相当于back()。如果不指定参数，默认参数为0，相当于刷新当前页面。","url":"","summary":"","reference":"","dot":""}]},{"title":"记录","fold":false,"list":[{"prefix":"history","tag":".state","suffix":"","desc":"history 堆栈最上层的状态值","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/history.html","dot":""},{"prefix":"history","tag":".pushState","suffix":"(state,title,path)","desc":"使用pushState()方法在浏览记录（History 对象）中添加一个新记录。\n不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。\n```\nvar stateObj = { foo: 'bar' };\nhistory.pushState(stateObj, 'page 2', '2.html');\n```","url":"","summary":"如果pushState的 URL 参数设置了一个新的锚点值（即hash），并不会触发hashchange事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。","reference":"","dot":""},{"prefix":"history","tag":".replaceState","suffix":"(state,title,path)","desc":"修改 History 对象的当前记录，其他都与pushState()方法一模一样","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"popstate","suffix":"","desc":"每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。","url":"","summary":"注意，仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。\n\n回调函数的参数是一个event事件对象，它的state属性指向pushState和replaceState方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的event.state，就是通过pushState和replaceState方法，为当前 URL 绑定的state对象。","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"window.on","tag":"pageshow","suffix":"","desc":"即使从缓存中加载也会触发该事件\npageshow 事件有一个persisted属性，返回一个布尔值。\n页面第一次加载时，这个属性是false；当页面从缓存加载时，这个属性是true。","url":"","summary":"注意，这两个事件只在浏览器的history对象发生变化时触发，跟网页是否可见没有关系。","reference":"","dot":""},{"prefix":"window.on","tag":"pagehide","suffix":"","desc":"pagehide事件实例也有一个persisted属性\n将这个属性设为true，就表示页面要保存在缓存中；\n设为false，表示网页不保存在缓存中","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Window","barcolor":"","fold":false,"box":[{"title":"事件","fold":false,"list":[{"prefix":"window.on","tag":"load","suffix":"","desc":"文档和资源浏览器窗口加载完毕时\n注意，页面或资源从浏览器缓存加载，并不会触发load事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"beforeunload","suffix":"","desc":"在窗口、文档、各种资源将要卸载前触发\n它可以用来防止用户不小心卸载资源","url":"","summary":"如果该事件对象的returnValue属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。\n```\nwindow.addEventListener('beforeunload', function (e) {\n  var confirmationMessage = '确认关闭窗口？';\n\n  e.returnValue = confirmationMessage;\n  return confirmationMessage;\n});\n```","reference":"","dot":""},{"prefix":"window.on","tag":"focus","suffix":"","desc":"激活窗口，获得焦点","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"blur","suffix":"","desc":"失去焦点","url":"","summary":"","reference":"","dot":""}]},{"title":"窗口","fold":false,"list":[{"prefix":"window.","tag":"name","suffix":"","desc":"当前浏览器窗口的名字","url":"","summary":"只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问a.com时，该页面的脚本设置了window.name，接下来在同一个窗口里面载入了b.com，新页面的脚本可以读到上一个网页设置的window.name。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。","reference":"","dot":""},{"prefix":"window.","tag":"closed","suffix":"","desc":"检查当前窗口是否关闭\n`(popup !== null) && !popup.closed`","url":"","summary":"","reference":"","dot":""},{"prefix":"window.","tag":"opener","suffix":"","desc":"打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回null。","url":"","summary":"通过opener属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况，且其中一个窗口由另一个打开。a元素添加rel=\"noopener\"属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。","reference":"","dot":""},{"prefix":"window","tag":".open","suffix":"(url,name,opt)","desc":"打开一个新窗口,如果无法新建窗口，则返回null\n`var newWin = window.open('example.html', 'newWindow', 'height=400,width=400');`","url":"","summary":"strWindowFeatures是一个字符串值，这个值列出了将要打开的窗口的一些特性(窗口功能和工具栏) 。 字符串中不能包含任何空白字符，特性之间用逗号分隔开。对于那些可以打开和关闭的属性，设为yes或1或不设任何值就表示打开\n\nleft：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。\ntop：新窗口距离屏幕最顶部的距离（单位像素）。\nheight：新窗口内容区域的高度（单位像素），不得小于100。\nwidth：新窗口内容区域的宽度（单位像素），不得小于100。\nouterHeight：整个浏览器窗口的高度（单位像素），不得小于100。\nouterWidth：整个浏览器窗口的宽度（单位像素），不得小于100。\nmenubar：是否显示菜单栏。\ntoolbar：是否显示工具栏。\nlocation：是否显示地址栏。\npersonalbar：是否显示用户自己安装的工具栏。\nstatus：是否显示状态栏。\ndependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。\nminimizable：是否有最小化按钮，前提是dialog=yes。\nnoopener：新窗口将与父窗口切断联系，即新窗口的window.opener属性返回null，父窗口的window.open()方法也返回null。\nresizable：新窗口是否可以调节大小。\nscrollbars：是否允许新窗口出现滚动条。\ndialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。\ntitlebar：新窗口是否显示标题栏。\nalwaysRaised：是否显示在所有窗口的顶部。\nalwaysLowered：是否显示在父窗口的底下。\nclose：新窗口是否显示关闭按钮。","reference":"MDN参考|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open","dot":""},{"prefix":"window","tag":".close()","suffix":"","desc":"关闭当前窗口，一般只用来关闭window.open方法新建的窗口。\n`popup.close()`\n该方法只对顶层窗口有效，iframe框架之中的窗口使用该方法无效。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".stop()","suffix":"","desc":"完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。","url":"","summary":"","reference":"","dot":""}]},{"title":"视口","fold":false,"list":[{"prefix":"ele.on","tag":"scroll","suffix":"","desc":"页面或元素滚动时，会触发scroll事件，导致执行onscroll()","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/events/common.html","dot":""},{"prefix":"ele.on","tag":"resize","suffix":"","desc":"改变大小时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"fullscreenchange","suffix":"","desc":"进入或退出全屏状态时触发\nfullscreenerror事件在浏览器无法切换到全屏状态时触发","url":"","summary":"","reference":"","dot":""}]},{"title":"组件","fold":false,"list":[{"prefix":"window","tag":".print()","suffix":"","desc":"跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。\n桌面设备（比如手机）可能没有打印功能，这时可以这样判断。\n`typeof window.print === 'function'`","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".alert","suffix":"(msg)","desc":"弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。","url":"","summary":"用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。参数只能是字符串，没法使用 CSS 样式，但是可以用\\n指定换行。","reference":"","dot":""},{"prefix":"window","tag":".prompt","suffix":"(msg,default)","desc":"弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。\n# 返回值\n+ 用户输入信息，并点击“确定”，则用户输入的信息就是返回值。\n+ 用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。\n+ 用户点击了“取消”（或者按了 ESC 按钮），则返回值是null。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".confirm","suffix":"(msg)","desc":"弹出一个对话框\n返回一个布尔值，如果用户点击“确定”，返回true；如果用户点击“取消”，则返回false。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Frame","barcolor":"","fold":false,"box":[{"title":"父框架","fold":false,"list":[{"prefix":"window","tag":".self","suffix":"","desc":"window.self和window.window属性都指向窗口本身。这两个属性只读。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".frames","suffix":"","desc":"返回一个类似数组的对象，成员为页面内所有框架窗口，包括frame元素和iframe元素。\n`window.frames[0]`表示页面中第一个框架窗口,是一个window对象","url":"","summary":"如果iframe元素设置了id或name属性，那么就可以用属性值，引用这个iframe窗口。比如`<iframe name=\"myIFrame\">`可以用frames['myIFrame']或者frames.myIFrame来引用。","reference":"","dot":""},{"prefix":"frame","tag":".contentWindow","suffix":"","desc":"获得iframe节点包含的window对象\n在满足同源限制的情况下，可以读取子窗口内部的属性。","url":"","summary":"","reference":"","dot":""},{"prefix":"frame","tag":".contentDocument","suffix":"","desc":"子窗口的document对象","url":"","summary":"","reference":"","dot":""}]},{"title":"子框架","fold":false,"list":[{"prefix":"window","tag":".parent","suffix":"","desc":"指向父窗口,如果当前窗口没有父窗口，window.parent指向自身。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".top","suffix":"","desc":"指向最顶层窗口","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".frameElement","suffix":"","desc":"返回当前窗口所被嵌入的那个元素节点\n对于非嵌入的窗口，该属性等于null。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"postMessage","barcolor":"","fold":false,"box":[{"title":"postMessage","fold":false,"list":[{"prefix":"window","tag":".postMessage","suffix":"(val)","desc":"向window发送信息,不限制同源","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"message","suffix":"","desc":"双方监听消息事件","url":"","summary":"","reference":"","dot":""},{"prefix":"event","tag":".<prop>","suffix":"","desc":"event.data: 消息内容\nevent.source：发送消息的窗口\nevent.origin: 消息发向的网址","url":"","summary":"","reference":"","dot":""}]},{"title":"旧方案","fold":false,"list":[{"prefix":"iframe","tag":"#hash","suffix":"","desc":"片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Document","barcolor":"","fold":false,"box":[{"title":"文档","fold":false,"list":[{"prefix":"document.on","tag":"DOMContentLoaded","suffix":"","desc":"DOMContentLoaded事件只有在 DOM 结构生成之后才会触发\n```\ndocument.addEventListener(\"DOMContentLoaded\", function(event) {\n    console.log(document.body.innerHTML);\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"readystatechange","suffix":"","desc":"当 Document 对象和 XMLHttpRequest 对象的readyState属性发生变化时触发。\n+ loading（网页正在加载）、\n+ interactive（网页已经解析完成，但是外部资源仍然处在加载状态）\n+ complete（网页和所有外部资源已经结束加载，load事件即将触发）。","url":"","summary":"","reference":"","dot":""},{"prefix":"document","tag":".referrer","suffix":"","desc":"来源网页","url":"","summary":"","reference":"","dot":""},{"prefix":"window.","tag":"document","suffix":"","desc":"只有来自同源的脚本才能读取这个属性","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Source","barcolor":"","fold":false,"box":[{"title":"状态","fold":false,"list":[{"prefix":"source","tag":".complete","suffix":"","desc":"完成状态\n有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能load和error事件的监听函数根本不会执行。所以，比较可靠的方式，是用complete属性先判断一下是否加载完成。","url":"","summary":"","reference":"","dot":""}]},{"title":"进度","fold":false,"list":[{"prefix":"source.on","tag":"load","suffix":"","desc":"资源加载成功时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"loadstart","suffix":"","desc":"外部资源开始加载时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"progress","suffix":"","desc":"部资源加载过程中不断触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"loadend","suffix":"","desc":"外部资源停止加载时触发，发生顺序排在error、abort、load等事件的后面\n类似finally性质","url":"","summary":"","reference":"","dot":""}]},{"title":"异常","fold":false,"list":[{"prefix":"source.on","tag":"abort","suffix":"","desc":"资源中止加载时（比如用户取消）触发。\n如果发生错误导致中止，不会触发该事件。","url":"","summary":"ProgressEvent接口主要用来描述外部资源加载的进度，比如 AJAX 加载、img、video、style、link等外部资源加载。进度相关的事件都继承了这个接口。\n+ lengthComputable：布尔值，表示加载的总量是否可以计算，默认是false。\n+ loaded：整数，表示已经加载的量，默认是0。\n+ total：整数，表示需要加载的总量，默认是0。","reference":"","dot":""},{"prefix":"source.on","tag":"error","suffix":"","desc":"由于错误导致资源无法加载时触发。\nerror事件有一个特殊的性质，就是不会冒泡。所以，子元素的error事件，不会触发父元素的error事件监听函数。","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"timeout","suffix":"","desc":"加载超时时触发","url":"","summary":"","reference":"","dot":""}]}]},{"title":"交互事件","barcolor":"","fold":false,"box":[{"title":"编辑","fold":false,"list":[{"prefix":"ele","tag":".contenteditable","suffix":"","desc":"允许用户修改内容\n+ true或空字符串：内容可以编辑\n+ false：不可以编辑","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".getSelection()","suffix":"","desc":"返回一个Selection对象，表示用户现在选中的文本\n`selection.toString()` 得到选中的文本","url":"","summary":"","reference":"","dot":""}]},{"title":"焦点","fold":false,"list":[{"prefix":"ele.on","tag":"focus","suffix":"","desc":"获得焦点时,该事件不会冒泡,**只能在捕获阶段触发**\nfocusin：元素节点将要获得焦点时触发，发生在focus事件之前。该事件会冒泡。","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"blur","suffix":"","desc":"失去焦点时,该事件不会冒泡,只能在捕获阶段触发\nfocusout：元素节点将要失去焦点时触发，发生在blur事件之前。该事件会冒泡。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Clipboard","barcolor":"","fold":false,"box":[{"title":"剪贴板·新","fold":false,"list":[{"prefix":"navigator.clipboard","tag":".read()","suffix":"","desc":"从剪贴板读取数据（比如图片），返回一个 Promise 对象。在检索到数据后，promise 将兑现一个 ClipboardItem 对象的数组来提供剪切板数据。","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard","dot":""},{"prefix":"navigator.clipboard","tag":".readText()","suffix":"","desc":"从操作系统读取文本；返回一个 Promise，在从剪切板中检索到文本后，promise 将兑现一个包含剪切板文本数据的 DOMString。","url":"","summary":"","reference":"","dot":""},{"prefix":"navigator.clipboard","tag":".write()","suffix":"","desc":"写入任意数据至操作系统剪贴板。这是一个异步操作，在操作完成后，返回的 promise 的将被兑现。","url":"","summary":"","reference":"","dot":""},{"prefix":"navigator.clipboard","tag":".writeText()","suffix":"","desc":"写入文本至操作系统剪贴板。返回一个 Promise，在文本被完全写入剪切板后，返回的 promise 将被兑现。","url":"","summary":"","reference":"","dot":""}]},{"title":"剪贴板·旧","fold":false,"list":[{"prefix":"","tag":"document.execCommand","suffix":"('copy')","desc":"1.先获取元素内的内容选择\n2.执行`copy`/`cut`/`paste`命令\n```js\n    var content = document.getElementById('textArea');\n    content.select();\n    document.execCommand('copy');\n```","url":"","summary":"","reference":"参考文档|https://www.delftstack.com/zh/howto/javascript/javascript-copy-to-clipboard/","dot":""},{"prefix":"document.on","tag":"copy","suffix":"","desc":"用户拷贝元素上的内容时触发（包括img）","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"cut","suffix":"","desc":"将选中的内容从文档中移除，加入剪贴板时触发\n对于不可编辑的元素，除非设置contenteditable 为 \"true\"","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"paste","suffix":"","desc":"用户粘贴元素内容时触发\n对于不可编辑的元素，除非设置contenteditable 为 \"true\"","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".clipboardData","suffix":"","desc":"该属性存放剪贴的数据,只读属性\n是一个 DataTransfer 对象","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"clipboard.js","suffix":"","desc":"","url":"https://github.com/zenorocha/clipboard.js","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Event","barcolor":"","fold":false,"box":[{"title":"事件","fold":false,"list":[{"prefix":"","tag":"new Event","suffix":"(type,[opt])","desc":"Event对象本身就是一个构造函数，可以用来生成新的实例。\n```\nnew Event('custom',{\n    'bubbles': true,  //默认false\n    'cancelable': true  //默认false\n}\n```","url":"","summary":"# 事件传播\n第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。\n第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。\n第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。\n# 事件代理\n由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。","reference":"参考资料|https://wangdoc.com/javascript/events/model.html","dot":""},{"prefix":"","tag":"new CustomEvent","suffix":"(type,opt)","desc":"自定义的事件实例\nopt.detail：表示事件的附带数据，默认为null。","url":"","summary":"","reference":"","dot":""},{"prefix":"target","tag":".dispatchEvent","suffix":"(evt)","desc":"在当前节点上触发指定事件，从而触发监听函数的执行,参数是**事件对象**。\n该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。","url":"","summary":"```\npara.addEventListener('click', hello, false);\nvar event = new Event('click');\npara.dispatchEvent(event);\n```","reference":"","dot":""}]},{"title":"监听","fold":false,"list":[{"prefix":"target","tag":".addEventListener","suffix":"(type,fn,[opt])","desc":"# `target.addEventListener(type,fn)`\n添加事件监听,监听函数内部的this，指向当前事件所在的那个对象\n+ type：事件名称，大小写敏感。\n+ listener：监听函数。事件发生时，会调用该监听函数。\n第二种属性的值是将会执行的代码，而不是一个函数\n+ useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。\n可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除\n+ 可以同时添加多个\n\n# `target.ontype = fn`\n它的值是函数名，只会在冒泡阶段触发。同一个事件只能定义一个监听函数\n只有一个生效\n\n# `ele ontype=\"fn()\"`\n属性的值是将会执行的代码，而不是一个函数。只会在冒泡阶段触发","url":"","summary":"第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象\n```\nbuttonElement.addEventListener('click', {\n  handleEvent: function (event) {\n    console.log('click');\n  }\n});\n```\n第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。\ncapture：布尔值，表示该事件是否在捕获阶段触发监听函数。\nonce：布尔值，表示监听函数是否只触发一次，然后就自动移除。\npassive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。","reference":"","dot":""},{"prefix":"target","tag":".removeEventListener","suffix":"(type,fn)","desc":"移除addEventListener方法添加的事件监听函数","url":"","summary":"","reference":"","dot":""}]},{"title":"事件对象","fold":false,"list":[{"prefix":"e","tag":".<prop>","suffix":"","desc":"+ type 返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。\n+ timeStamp 返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。\n+ isTrusted 返回一个布尔值，表示该事件是否由真实的用户行为产生","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".cancelable","suffix":"","desc":"是否可以被取消，即能否用Event.preventDefault()取消这个事件，默认为false\n一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。\n","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".preventDefault()","suffix":"","desc":"取消这个事件，阻止浏览器对该事件的默认行为,不会阻止事件的传播","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".bubbles","suffix":"","desc":"是否冒泡,不影响目标本身触发该事件,默认为false\n如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数\n`e.eventPhase` 事件的具体阶段","url":"","summary":"# Event.eventPhase\n0，事件目前没有发生。\n1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。\n2，事件到达目标节点，即Event.target属性指向的那个节点。\n3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。","reference":"","dot":""},{"prefix":"e","tag":".stopPropagation()","suffix":"","desc":"阻止冒泡.\n等同`e.cancelBubble = false`\niPhone默认阻止冒泡，故慎用事件委托，给指定元素添加手型样式可开启冒泡，让其认可该为一个可点击区域。","url":"","summary":"","reference":"","dot":""},{"prefix":"e.","tag":"stopImmediatePropagation()","suffix":"","desc":"彻底取消这个事件，使得后面绑定的所有监听函数都不再触发","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".target","suffix":"","desc":"`e.target` 返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。\n`e.currentTarget`属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。","url":"","summary":"事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的原始触发节点（Event.target），另一个是事件当前正在通过的节点（Event.currentTarget）。前者通常是后者的后代节点。","reference":"","dot":""},{"prefix":"e","tag":".composedPath()","suffix":"","desc":"返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"鼠标事件","barcolor":"","fold":false,"box":[{"title":"MouseEvent","fold":false,"list":[{"prefix":"","tag":"new MouseEvent","suffix":"(type,options)","desc":"```\nvar event = new MouseEvent('click', {\n    'bubbles': true,\n    'cancelable': true\n});\n```","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/events/mouse.html","dot":""},{"prefix":"e","tag":".<k>Key","suffix":"","desc":"+ ctrlKey：布尔值，是否同时按下了 Ctrl 键，默认值为false。\n+ shiftKey：布尔值，是否同时按下了 Shift 键，默认值为false。\n+ altKey：布尔值，是否同时按下 Alt 键，默认值为false。\n+ metaKey：布尔值，是否同时按下 Meta 键，默认值为false。","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".getModifierState","suffix":"(key)","desc":"返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示功能键的字符串。","url":"","summary":"```\ndocument.addEventListener('click', function (e) {\n  console.log(e.getModifierState('CapsLock'));\n}, false);\n```\n上面的代码可以了解用户是否按下了大写键。","reference":"","dot":""},{"prefix":"e","tag":".button","suffix":"[s]","desc":"button：数值，表示按下了哪一个鼠标按键，默认值为0，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；1表示按下辅助键（通常是鼠标的中间键），2表示按下次要键（通常是鼠标的右键）。\nbuttons：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为0（没有按下任何键）。1（二进制001）表示按下主键（通常是左键），2（二进制010）表示按下次要键（通常是右键），4（二进制100）表示按下辅助键（通常是中间键）。因此，如果返回3（二进制011）就表示同时按下了左键和右键。","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".relatedTarget","suffix":"","desc":"节点对象，表示事件的相关节点，默认为null。\n<table><thead><tr><th>事件名称</th><th>target 属性</th><th>relatedTarget 属性</th></tr></thead><tbody><tr><td>focusin</td><td>接受焦点的节点</td><td>丧失焦点的节点</td></tr><tr><td>focusout</td><td>丧失焦点的节点</td><td>接受焦点的节点</td></tr><tr><td>mouseenter</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>mouseleave</td><td>将要离开的节点</td><td>将要进入的节点</td></tr><tr><td>mouseout</td><td>将要离开的节点</td><td>将要进入的节点</td></tr><tr><td>mouseover</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>dragenter</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>dragexit</td><td>将要离开的节点</td><td>将要进入的节点</td></tr></tbody></table>","url":"","summary":"","reference":"","dot":""}]},{"title":"点击","fold":false,"list":[{"prefix":"ele.on","tag":"mousedown","suffix":"","desc":"按下鼠标键时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseup","suffix":"","desc":"释放按下的鼠标键时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"click","suffix":"","desc":"左|中键点击事件 onmousedown -> onmouseup -> onclick","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"contextmenu","suffix":"","desc":"右键点击事件 onmousedown -> onmouseup -> oncontextmenu\n指定return false，将不显示浏览器默认菜单","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"dblclick","suffix":"","desc":"左键双击事件 onmousedown -> onmouseup -> onclick -> dblclick","url":"","summary":"","reference":"","dot":""}]},{"title":"移动","fold":false,"list":[{"prefix":"ele.on","tag":"mouseenter","suffix":"","desc":"鼠标进入一个节点时触发，进入子节点不会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseleave","suffix":"","desc":"鼠标离开一个节点时触发，离开父节点不会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseover","suffix":"","desc":"mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。两者的区别是，mouseenter事件只触发一次，而只要鼠标在节点内部移动，mouseover事件会在子节点上触发多次。","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseout","suffix":"","desc":"鼠标离开一个节点时触发，离开父节点也会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mousemove","suffix":"","desc":"当鼠标在一个节点内部移动时触发。\n当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。","url":"","summary":"","reference":"","dot":""}]},{"title":"滚轮","fold":false,"list":[{"prefix":"ele.on","tag":"wheel","suffix":"","desc":"滚动鼠标的滚轮时触发\n+ deltaX：数值，表示滚轮的水平滚动量，默认值是 0.0。\n+ deltaY：数值，表示滚轮的垂直滚动量，默认值是 0.0。\n+ deltaZ：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。\n+ deltaMode：数值，表示相关的滚动事件的单位，适用于上面三个属性。0表示滚动单位为像素，1表示单位为行，2表示单位为页，默认为0。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"键盘事件","barcolor":"","fold":false,"box":[{"title":"KeyboardEvent","fold":false,"list":[{"prefix":"","tag":"new KeyboardEvent","suffix":"(type,options)","desc":"`new KeyboardEvent(type, options)`","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/events/keyboard.html","dot":""},{"prefix":"e","tag":".key","suffix":"","desc":"字符串，当前按下的键，默认为空字符串。例如“a”","url":"","summary":"","reference":"code|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values","dot":""},{"prefix":"e","tag":".repeat","suffix":"","desc":"返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发keydown和keypress事件，直到用户松开手为止。","url":"","summary":"","reference":"","dot":""},{"prefix":"e.","tag":"<key>Key","suffix":"","desc":"KeyboardEvent.altKey：是否按下 Alt 键\nKeyboardEvent.ctrlKey：是否按下 Ctrl 键\nKeyboardEvent.metaKey：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）\nKeyboardEvent.shiftKey：是否按下 Shift 键","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".getModifierState","suffix":"(key)","desc":"返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。\nAlt：Alt 键\nCapsLock：大写锁定键\nControl：Ctrl 键\nMeta：Meta 键\nNumLock：数字键盘开关键\nShift：Shift 键","url":"","summary":"","reference":"","dot":""}]},{"title":"按键","fold":false,"list":[{"prefix":"ele.on","tag":"keydown","suffix":"","desc":"按下键盘时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"keypress","suffix":"","desc":"按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。\n有值键 onkeydown -> onkeypress -> onkeyup\n无值键 onkeydown -> onkeyup\n按键不松 (onkeydown -> onkeypress)*n -> onkeyup","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"keyup","suffix":"","desc":"松开键盘时触发该事件","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"File","barcolor":"","fold":false,"box":[{"title":"路径","fold":false,"list":[{"prefix":"","tag":"file://","suffix":"url","desc":"本地文件系统里面的文件","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"data://","suffix":"value","desc":"URL 包含实际数据","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"blob://","suffix":"sign","desc":"表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象","url":"","summary":"浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。","reference":"","dot":""},{"prefix":"URL","tag":".createObjectURL","suffix":"(fileblob)","desc":"为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了File对象或Blob对象的 URL。","url":"","summary":"```\n// HTML 代码如下\n// <div id=\"display\"/>\n// <input\n//   type=\"file\"\n//   id=\"fileElem\"\n//   multiple\n//   accept=\"image/*\"\n//   onchange=\"handleFiles(this.files)\"\n//  >\nvar div = document.getElementById('display');\n\nfunction handleFiles(files) {\n  for (var i = 0; i < files.length; i++) {\n    var img = document.createElement('img');\n    img.src = window.URL.createObjectURL(files[i]);\n    div.appendChild(img);\n  }\n}\n```\n上面代码中，URL.createObjectURL()方法用来为上传的文件生成一个 URL 字符串，作为img元素的图片来源。\n该方法生成的 URL 就像下面的样子。\n`blob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1`","reference":"","dot":""},{"prefix":"URL","tag":".revokeObjectURL","suffix":"(src)","desc":"释放URL.createObjectURL()方法生成的 URL 实例。它的参数就是URL.createObjectURL()方法返回的 URL 字符串。","url":"","summary":"```\nvar div = document.getElementById('display');\n\nfunction handleFiles(files) {\n  for (var i = 0; i < files.length; i++) {\n    var img = document.createElement('img');\n    img.src = window.URL.createObjectURL(files[i]);\n    div.appendChild(img);\n    img.onload = function() {\n      window.URL.revokeObjectURL(this.src);\n    }\n  }\n}\n```\n上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在img.onload回调函数里面，通过URL.revokeObjectURL()方法卸载这个 URL 实例。","reference":"","dot":""},{"prefix":"FileSaver","tag":" ","suffix":"","desc":"","url":"https://github.com/eligrey/FileSaver.js","summary":"","reference":"","dot":""}]},{"title":"Blob","fold":false,"list":[{"prefix":"","tag":"new Blob","suffix":"(arr,opt)","desc":"表示一个二进制文件的数据内容 `new Blob(arr,{type:'text/html'})`\n第一个参数：数组，成员是字符串或二进制对象\n第二个参数，MIME类型","url":"","summary":"Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object （二进制大型对象）的缩写。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。\nBlob构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性type，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。","reference":"","dot":""},{"prefix":"blob","tag":".size","suffix":"","desc":"返回数据的大小\nUTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 \nUnicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。","url":"","summary":"","reference":"","dot":""},{"prefix":"blob","tag":".type","suffix":"","desc":"返回数据的类型","url":"","summary":"","reference":"","dot":""},{"prefix":"blob","tag":".slice","suffix":"[start,end)","desc":"拷贝原来的数据，返回的也是一个Blob实例","url":"","summary":"","reference":"","dot":""}]},{"title":"FileList","fold":false,"list":[{"prefix":"filelist","tag":".item","suffix":"(i)","desc":"FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象\nFile 实例对象是一个特殊的 Blob 实例\n+ 文件选择器 `ele.files[0]`\n+ 拖放 `dataTransfer.files[i]`","url":"","summary":"文件选择器`<input type=\"file\">`用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的value属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。\n文件选择器返回一个 FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了name和lastModifiedDate属性。\n除了文件选择器，拖放 API 的dataTransfer.files返回的也是一个FileList 对象，它的成员因此也是 File 实例对象","reference":"","dot":""},{"prefix":"fileblob","tag":".name","suffix":"","desc":"文件名，不含路径","url":"","summary":"","reference":"","dot":""},{"prefix":"fileblob","tag":".lastModifiedDate","suffix":"","desc":"文件的最后修改时间","url":"","summary":"","reference":"","dot":""}]},{"title":"FileReader","fold":false,"list":[{"prefix":"","tag":"new FileReader()","suffix":"","desc":"通过FileReader对象，读取 Blob 对象的内容，即文件内容","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsText","suffix":"(data,[encoding])","desc":"返回文本，需要指定文本编码，默认为 UTF-8。\n根据特殊的编码格式转化为内容(字符串形式),这个方法是异步的，也就是说，只有当执行完成后才能够查看到结果，如果直接查看是无结果的，并返回undefined","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsArrayBuffer","suffix":"(data)","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsDataURL","suffix":"(data)","desc":"开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".onload","suffix":" = fn","desc":"该事件在读取操作完成时触发\n+ onabort 在读取操作被中断时触发。\n+ onerror 在读取操作发生错误时触发。\n+ onload 在读取操作完成时触发。\n+ onloadstart 在读取操作开始时触发。\n+ onloadend 在读取操作结束时（要么成功，要么失败）触发。\n+ onprogress 在读取Blob时触发。\n+ readyState：整数，表示读取文件时的当前状态。一共有三种可能的状态，0表示尚未加载任何数据，1表示数据正在加载，2表示加载完成。","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader","dot":""},{"prefix":"reader","tag":".result","suffix":"","desc":"文件的内容,该属性仅在读取操作完成后才有效\n数据的格式取决于使用哪个方法来启动读取操作。","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".abort()","suffix":"","desc":"中止读取操作","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Drag","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"表单","barcolor":"","fold":false,"box":[{"title":"FormData","fold":false,"list":[{"prefix":"","tag":"new FormData","suffix":"(formele)","desc":"FormData()构造函数的参数是一个表单元素，这个参数是可选的。如果省略参数，就表示一个空的表单，否则就会处理表单元素里面的键值对。","url":"","summary":"```javascript\nvar myForm = document.getElementById('myForm');\nvar formData = new FormData(myForm);\n\n// 获取某个控件的值\nformData.get('username') // \"\"\n\n// 设置某个控件的值\nformData.set('username', '张三');\n```","reference":"HTML表单|https://www.runoob.com/html/html-forms.html","dot":""},{"prefix":"formdata","tag":".get|getAll","suffix":"(key)","desc":"+ get获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。\n+ getAll返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。","url":"","summary":"```javascript\nvar formData = new FormData();\n\nformData.set('username', '张三');\nformData.append('username', '李四');\nformData.get('username') // \"张三\"\nformData.getAll('username') // [\"张三\", \"李四\"]\n\nformData.append('userpic[]', myFileInput.files[0], 'user1.jpg');\nformData.append('userpic[]', myFileInput.files[1], 'user2.jpg');\n```","reference":"","dot":""},{"prefix":"formdata","tag":".set","suffix":"(key,val)","desc":"设置指定键名的键值，参数为键名。\n如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。\n如果第二个参数是文件，还可以使用第三个参数，表示文件名。","url":"","summary":"","reference":"","dot":""},{"prefix":"formdata","tag":".append","suffix":"(key,val)","desc":"添加一个键值对。\n如果键名重复，则会生成两个相同键名的键值对。\n如果第二个参数是文件，还可以使用第三个参数，表示文件名。","url":"","summary":"","reference":"","dot":""},{"prefix":"formdata","tag":".delete","suffix":"(key)","desc":"删除一个键值对，参数为键名。","url":"","summary":"","reference":"","dot":""},{"prefix":"formdata","tag":".has","suffix":"(key)","desc":"返回一个布尔值，表示是否具有该键名的键值对。","url":"","summary":"","reference":"","dot":""},{"prefix":"formdata","tag":".keys|values|entries()","suffix":"","desc":"返回一个遍历器对象","url":"","summary":"","reference":"","dot":""},{"prefix":"custom upload +","tag":" ","suffix":"axios upload","desc":"# 自定义上传组件\n```\n<input type=\"file\" id=\"fileInput\" />\n<button id=\"uploadBtn\">点我</button>\n<script>\n    // 原生file input\n    let fileInput = document.getElementById(\"fileInput\");\n    // 触发按钮\n    let uploadBtn = document.getElementById(\"uploadBtn\");\n    // 按钮监听点击事件\n    uploadBtn.addEventListener(\"click\", selectFile);\n    // 触发选择文件\n    function selectFile() {\n        fileInput.dispatchEvent(\n            new MouseEvent(\"click\", {\n                bubbles: true,\n                cancelable: true,\n            })\n        );\n    }\n</script>\n```\n\n# 自定义文件上传\n```\nlet formdata = new FormData();\nformdata.append(\"somefile\", file.raw);\nthis.$axios.post(API, fdata, {\n    headers: { \"Content-Type\": \"multipart/form-data\" },\n    withCredentials: true,\n});\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"InputEvent","fold":false,"list":[{"prefix":"","tag":"new InputEvent","suffix":"(type,options)","desc":"`new InputEvent(type, options)`\n# inputType 事件类型\n+ 手动插入文本：insertText\n+ 粘贴插入文本：insertFromPaste\n+ 向后删除：deleteContentBackward\n+ 向前删除：deleteContentForward\n\n# options额外可扩展属性\n+ data：字符串，表示插入的字符串。如果没有插入的字符串（比如删除操作），则返回null或空字符串。\n+ dataTransfer：返回一个 DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效。","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".data","suffix":"","desc":"返回一个字符串，表示变动的内容\n```\n// HTML 代码如下\n// <input type=\"text\" id=\"myInput\">\nvar input = document.getElementById('myInput');\ninput.addEventListener('input', myFunction, false);\n\nfunction myFunction(e) {\n  console.log(e.data);\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".inputType","suffix":"","desc":"返回一个字符串，表示字符串发生变更的类型","url":"","summary":"手动插入文本：insertText\n粘贴插入文本：insertFromPaste\n向后删除：deleteContentBackward\n向前删除：deleteContentForward","reference":"完整列表|https://w3c.github.io/input-events/index.html#dom-inputevent-inputtype","dot":""},{"prefix":"e","tag":".dataTransfer","suffix":"","desc":"返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（insertFromDrop）时才有效。","url":"","summary":"","reference":"","dot":""}]},{"title":"表单事件","fold":false,"list":[{"prefix":"on","tag":"input","suffix":"","desc":"+ input、select、textarea的值发生变化时触发\n+ radio、checkbox值发生改变时\n+ 打开contenteditable属性的元素，只要值发生变化","url":"","summary":"该事件跟change事件很像，不同之处在于input事件在元素的值发生变化后立即发生，而change在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，input事件会触发多次，而change事件只在失去焦点时触发一次。","reference":"","dot":""},{"prefix":"on","tag":"change","suffix":"","desc":"+ 激活单选框（radio）或复选框（checkbox）时触发。\n+ 用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。\n+ 当文本框或textarea元素的值发生改变，并且丧失焦点时触发。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"select","suffix":"","desc":"在input、textarea里面选中文本时触发\n选中的文本可以通过event.target元素的selectionDirection、selectionEnd、selectionStart和value属性拿到。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"invalid","suffix":"","desc":"用户提交表单时，如果表单元素的值不满足校验条件，就会触发invalid事件","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"reset","suffix":"","desc":"当表单重置（所有表单成员变回默认值）时触发\n发生在表单对象form上，而不是发生在表单的成员上。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"submit","suffix":"","desc":"当表单数据向服务器提交时触发。\n注意，submit事件的发生对象是form元素，而不是button元素，因为提交的是表单，而不是按钮。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"XHR","barcolor":"","fold":false,"box":[{"title":"范例","fold":true,"list":[{"prefix":"xhr = ","tag":"new XMLHttpRequest()","suffix":"","desc":"`var xhr = new XMLHttpRequest();`\n新建实例","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/xmlhttprequest.html\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest","dot":""},{"prefix":"xhr","tag":".open","suffix":"(method,url,true)","desc":"`xhr.open('GET', 'http://www.example.com/page.php', true);`\n使用 GET 方法，跟指定的服务器网址建立连接。第三个参数true，表示请求是异步的。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".setRequestHeader","suffix":"(key,val)","desc":"设置头信息","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".withCredentials","suffix":"","desc":"如果需要跨域 AJAX 请求发送 Cookie，需要withCredentials属性设为true。\n注意，同源的请求不需要设置这个属性。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".send","suffix":"(data)","desc":"`xhr.send(null);`\nsend()的参数为null，表示发送请求的时候，不带有数据体。如果发送的是 POST 请求，这里就需要指定数据体。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onreadystatechange","suffix":"= fn","desc":"旦XMLHttpRequest实例的状态发生变化，就会调用监听函数\n```javascript\nxhr.onreadystatechange = function(){\n  // 通信成功时，状态值为4\n  if (xhr.readyState === 4){\n    if (xhr.status === 200){\n      console.log(xhr.responseText);\n    } else {\n      console.error(xhr.statusText);\n    }\n  }\n};\n\nxhr.onerror = function (e) {\n  console.error(xhr.statusText);\n};\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".getResponseHeader","suffix":"(header)","desc":"`xhr.getResponseHeader(\"Last-Modified\")` 返回响应头指定信息\n`xhr.getAllResponseHeaders()` 返回响应头全部信息字符串（每个头信息之间使用CRLF分隔（回车+换行），如果没有收到服务器回应，该属性为null。如果发生网络错误，该属性为空字符串。）","url":"","summary":"```\nfunction getHeaderTime() {\n  console.log(this.getResponseHeader(\"Last-Modified\"));\n}\n\nvar xhr = new XMLHttpRequest();\nxhr.open('HEAD', 'yourpage.html');\nxhr.onload = getHeaderTime;\nxhr.send();\n```","reference":"","dot":""}]},{"title":"属性","fold":true,"list":[{"prefix":"xhr","tag":".readyState","suffix":"","desc":"返回一个整数，表示实例对象的当前状态\n+ 0，表示 XMLHttpRequest 实例已经生成，但是实例的open()方法还没有被调用。\n+ 1，表示open()方法已经调用，但是实例的send()方法还没有调用，仍然可以使用实例的setRequestHeader()方法，设定 HTTP 请求的头信息。\n+ 2，表示实例的send()方法已经调用，并且服务器返回的头信息和状态码已经收到。\n+ 3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的responseType属性等于text或者空字符串，responseText属性就会包含已经收到的部分信息。\n+ 4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".response","suffix":"","desc":"表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由XMLHttpRequest.responseType属性决定。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".responseType","suffix":"","desc":"服务器返回数据的类型\n+ \"（空字符串）：等同于text，表示服务器返回文本数据。\n+ \"arraybuffer\"：ArrayBuffer 对象，表示服务器返回二进制数组。\n+ \"blob\"：Blob 对象，表示服务器返回二进制对象。\n+ \"document\"：Document 对象，表示服务器返回一个文档对象。\n+ \"json\"：JSON 对象。\n+ \"text\"：字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".overrideMimeType","suffix":"(type)","desc":"`xhr.overrideMimeType('text/plain')`\n用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型","url":"","summary":"举例来说，服务器返回的数据类型是text/xml，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成text/plain，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。\n\n修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用responseType属性告诉服务器。只有在服务器无法返回某种数据类型时，才使用overrideMimeType()方法。","reference":"","dot":""},{"prefix":"xhr","tag":".responseURL","suffix":"","desc":"发送数据的服务器的网址","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".status","suffix":"","desc":"返回一个整数，表示服务器回应的 HTTP 状态码","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".timeout","suffix":"","desc":"返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".abort()","suffix":"","desc":"终止已经发出的 HTTP 请求。调用这个方法以后，readyState属性变为4，status属性变为0。","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":true,"list":[{"prefix":"xhr","tag":".onloadstart","suffix":"","desc":"loadstart 事件（HTTP 请求发出）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onprogress","suffix":"","desc":"progress事件（正在发送和加载数据）的监听函数","url":"","summary":"progress事件的监听函数有一个事件对象参数，该对象有三个属性：\n+ loaded属性返回已经传输的数据量\n+ total属性返回总的数据量\n+ lengthComputable属性返回一个布尔值，表示加载的进度是否可以计算。","reference":"","dot":""},{"prefix":"xhr","tag":".onabort","suffix":"","desc":"abort 事件（请求中止，比如用户调用了abort()方法）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onerror","suffix":"","desc":"error 事件（请求失败）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onload","suffix":"","desc":"load 事件（请求成功完成）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onloadend","suffix":"","desc":"loadend 事件（请求完成，不管成功或失败）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".ontimeout","suffix":"","desc":"设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。","url":"","summary":"","reference":"","dot":""}]},{"title":"beacon","fold":false,"list":[{"prefix":"Navigator","tag":".sendBeacon","suffix":"(url,data)","desc":"第一个参数是目标服务器的 URL，\n第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。\n返回值是一个布尔值，成功发送数据为true，否则为false。\n该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数。","url":"","summary":"","reference":"参考资料|http://www.ruanyifeng.com/blog/2019/04/user-tracking.html","dot":""}]},{"title":"axios","fold":false,"list":[{"prefix":"","tag":"Request Config","suffix":"","desc":"```javascript\n{\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data, headers) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // `headers` 是即将被发送的自定义请求头\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n\n  // `params` 是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // （快捷方法时无需）`url` 是用于请求的服务器 URL\n  url: '/user',\n\n  // （快捷方法时无需）`method` 是创建请求时使用的方法\n  method: 'get', // default\n\n  // （快捷方法时无需）`data` 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // （通过实例配置设置）`timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n   // `withCredentials` 表示跨域请求时是否需要使用凭证\n  withCredentials: false, // default\n\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n   // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // default\n  \n   // 编码\n  responseEncoding: 'utf8', // default\n\n   // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n   // `onUploadProgress` 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n   // `maxContentLength` 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // default\n\n  // `socketPath` defines a UNIX Socket to be used in node.js.\n  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n  // Only either `socketPath` or `proxy` can be specified.\n  // If both are specified, `socketPath` is used.\n  socketPath: null, // default\n\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` 指定用于取消请求的 cancel token\n  // （查看后面的 Cancellation 这节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Response Schema","suffix":"","desc":"```javascript\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n   // `config` 是为请求提供的配置信息\n  config: {},\n  // 'request'\n  // `request` is the request that generated this response\n  // It is the last ClientRequest instance in node.js (in redirects)\n  // and an XMLHttpRequest instance the browser\n  request: {}\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"axios.defaults.","suffix":"config","desc":"全局默认值设置\n```\naxios.defaults.baseURL = 'https://api.example.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\naxios.defaults.timeout =  10000; //单位毫秒\naxios.defaults.withCredentials = true;\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"axios","tag":".verb","suffix":"(url,[data],config)","desc":"当使用快捷方法是,url,method,data不需要放置在config中","url":"","summary":"","reference":"github|https://github.com/axios/axios","dot":""},{"prefix":"axios","tag":".create","suffix":"(config)","desc":"按自定义配置定义个实例，会被合并\n```\naxios.create({\n  baseURL: 'https://some-domain.com/api/',\n  timeout: 1000,\n  headers: {'X-Custom-Header': 'foobar'}\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"axios","tag":".all","suffix":"(iterable)","desc":"同时发起多个请求","url":"","summary":"","reference":"","dot":""},{"prefix":"axios","tag":".spread","suffix":"(fn(result,..))","desc":"并在请求都结束后，输出结果","url":"","summary":"```\nvar me = this; \nthis.$axios.all([me.getAllTask(),me.getAllCity()])\n    .then(me.$axios.spread(function(allTask, allCity){\n        console.log('所有请求完成')\n        console.log('请求1结果',allTask)\n        console.log('请求2结果',allCity)\n\n    }))\n```","reference":"参考资料|https://segmentfault.com/a/1190000019882188","dot":""}]}]},{"title":"Fetch","barcolor":"","fold":false,"box":[{"title":"fetch","fold":false,"list":[{"prefix":"","tag":"fetch","suffix":"(url/req,opt)","desc":"+ url/req：一个 USVString 字符串，包含要获取资源的 URL或Request对象。\n+ opt：配置项\n    + `method`: 请求使用的方法，如 GET、POST。\n    + `headers`: 请求的头信息，形式为 Headers 的对象或包含 ByteString 值的对象字面量。\n    + `body`: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。\n    + `mode`: 请求的模式，如 cors、no-cors 或者 same-origin。\n    + `credentials`: 请求的 credentials，如 omit、same-origin 或者 include。为了在当前域名内自动发送 cookie，必须提供这个选项，从 Chrome 50 开始，这个属性也可以接受 FederatedCredential (en-US) 实例或是一个 PasswordCredential (en-US) 实例。\n    + `cache`:  请求的 cache 模式：default、 no-store、 reload 、 no-cache、 force-cache 或者 only-if-cached。\n    + `redirect`: 可用的 redirect 模式：follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误），或者 manual (手动处理重定向)。在 Chrome 中默认使用 follow（Chrome 47 之前的默认值是 manual）。\n    + `referrer`: 一个 USVString 可以是 no-referrer、client 或一个 URL。默认是 client。\n    + `referrerPolicy`: 指定了 HTTP 头部 referer 字段的值。可能为以下值之一：no-referrer、 no-referrer-when-downgrade、origin、origin-when-cross-origin、 unsafe-url。\n    + `integrity`: 包括请求的 subresource integrity 值（例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。","url":"","summary":"## 示例\n```js\n// 获取 some.json 资源\nfetch('some.json')\n  .then(function(response) {\n    return response.json();\n  })\n  .then(function(data) {\n    console.log('data', data);\n  })\n  .catch(function(error) {\n    console.log('Fetch Error: ', error);\n  });\n```","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch","dot":""},{"prefix":"","tag":"new AbortController()","suffix":"","desc":"```js\nvar controller = new AbortController();\nvar signal = controller.signal;\n\nvar downloadBtn = document.querySelector('.download');\nvar abortBtn = document.querySelector('.abort');\n\ndownloadBtn.addEventListener('click', fetchVideo);\n\nabortBtn.addEventListener('click', function() {\n  controller.abort();\n  console.log('Download aborted');\n});\n\nfunction fetchVideo() {\n  ...\n  fetch(url, {signal}).then(function(response) {\n    ...\n  }).catch(function(e) {\n    reports.textContent = 'Download error: ' + e.message;\n  })\n}\n```","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal","dot":""}]},{"title":"Request","fold":true,"list":[{"prefix":"","tag":"new Request","suffix":"(input,opt)","desc":"+ method: 请求的方法，例如：GET, POST。\n+ headers: 任何你想加到请求中的头，其被放在Headers对象或内部值为ByteString 的对象字面量中。\n+ body: 任何你想加到请求中的body，可以是Blob, BufferSource, FormData, URLSearchParams, 或 USVString对象。注意GET 和 HEAD请求没有body。\n+ mode: 请求的模式, 比如 cors, no-cors, same-origin, 或 navigate。默认值应该为 cors。但在Chrome中，Chrome 47 之前的版本默认值为 no-cors ，自Chrome 47起，默认值为same-origin。\n+ credentials: 想要在请求中使用的credentials：: omit, same-origin, 或 include。默认值应该为omit。但在Chrome中，Chrome 47 之前的版本默认值为 same-origin ，自Chrome 47起，默认值为include。\n+ cache: 请求中想要使用的cache mode \n+ redirect: 对重定向处理的模式： follow, error, or manual。在Chrome中，Chrome 47 之前的版本默认值为 manual ，自Chrome 47起，默认值为follow。\n+ referrer: 一个指定了no-referrer, client, 或一个 URL的 USVString 。默认值是client.\n+ integrity: 包括请求的 subresource integrity 值 (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".method","suffix":"","desc":"包含请求的方法 (GET, POST, 等.)","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".url","suffix":"","desc":"包含这个请求的URL","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".headers ","suffix":"","desc":"包含请求相关的Headers对象","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".mode","suffix":"","desc":"包含请求的模式 (例如： cors, no-cors, same-origin, navigate).","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".credentials ","suffix":"","desc":"包含请求的证书(例如： omit, same-origin).","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".cache","suffix":"","desc":"包含请求的缓存模式 (例如： default, reload, no-cache).","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".clone()","suffix":"","desc":"创建一个当前Request 对象的副本","url":"","summary":"","reference":"","dot":""}]},{"title":"Headers","fold":true,"list":[{"prefix":"","tag":"new Headers","suffix":"(obj)","desc":"创建一个新的Headers对象.","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".get","suffix":"(name)","desc":"获取指定key的值\n```\nmyHeaders.append('Accept-Encoding', 'deflate');\nmyHeaders.append('Accept-Encoding', 'gzip');\nmyHeaders.get('Accept-Encoding'); // Returns \"deflate,gzip\"\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".entries|keys|values()","suffix":"","desc":"以 迭代器 的形式返回Headers对象中所有的键值对","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".set","suffix":"(name,val)","desc":"替换现有的header的值, 或者添加一个未存在的header并赋值.","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".append","suffix":"(name,val)","desc":"给现有的header添加一个值, 或者添加一个未存在的header并赋值.","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".delete","suffix":"(name)","desc":"从Headers对象中删除指定header.","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".has","suffix":"(name)","desc":"以布尔值的形式从Headers对象中返回是否存在指定的header.","url":"","summary":"","reference":"","dot":""}]},{"title":"Response","fold":true,"list":[{"prefix":"","tag":"new Response","suffix":"(body,opt)","desc":"创建一个 Response 对象","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".headers","suffix":"","desc":"包含此 Response 所关联的 Headers 对象","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".ok","suffix":"","desc":"包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".redirected ","suffix":"","desc":"表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".status","suffix":"","desc":"包含 Response 的状态码 （例如 200 表示成功）","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".statusText","suffix":"","desc":"包含了与该 Response 状态码一致的状态信息（例如，OK对应 200）","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".type ","suffix":"","desc":"包含 Response 的类型（例如，basic、cors）。","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".url ","suffix":"","desc":"包含 Response 的URL。","url":"","summary":"","reference":"","dot":""}]},{"title":"Body API","fold":false,"list":[{"prefix":"","tag":"body","suffix":"=>response|request","desc":"一个简单的getter用于暴露一个ReadableStream类型的主体内容。","url":"","summary":"Body被Request 和Response实现，并为这些对象提供了一个相关联的主体（字节流），一个已使用的标志（最初未设置）和一个MIME类型（最初为空字节序列）。","reference":"","dot":""},{"prefix":"body","tag":".bodyUsed ","suffix":"","desc":"一个Boolean 值指示是否body已经被标记读取。","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".arrayBuffer()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是ArrayBuffer。此操作会将bodyUsed状态改为已使用（true）","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".blob()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是Blob。此操作会将bodyUsed状态改为已使用（true）。","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".formData()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是FormData表单。此操作会将bodyUsed状态改为已使用（true）。","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".json()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是使用JSON解析body文本的结果。此操作会将bodyUsed状态改为已使用（true）。","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".text()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是USVString（文本）。此操作会将bodyUsed状态改为已使用（true）。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Storage","barcolor":"","fold":false,"box":[{"title":"基础","fold":false,"list":[{"prefix":"","tag":"sessionStorage","suffix":"","desc":"保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空；","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"localStorage","suffix":"","desc":"保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"storage","suffix":"","desc":"Storage 接口储存的数据发生变化时，会触发 storage 事件","url":"","summary":"+ StorageEvent.key：字符串，表示发生变动的键名。如果 storage 事件是由clear()方法引起，该属性返回null。\n+ StorageEvent.newValue：字符串，表示新的键值。如果 storage 事件是由clear()方法或删除该键值对引发的，该属性返回null。\n+ StorageEvent.oldValue：字符串，表示旧的键值。如果该键值对是新增的，该属性返回null。\n+ StorageEvent.storageArea：对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。\n+ StorageEvent.url：字符串，表示原始触发 storage 事件的那个网页的网址。\n\n注意，该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在同一个域名的其他窗口触发。也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。","reference":"","dot":""}]},{"title":"CURD","fold":false,"list":[{"prefix":"storage","tag":".setItem","suffix":"(key,val)","desc":"+ 存入数据\n+ 如果键名已经存在，该方法会更新已有的键值；\n+ 如果储存空间已满，该方法会抛错。\n+ 返回值：无\n**两个参数都是字符串。如果不是字符串，会自动转成字符串，再存入浏览器。对象需预先自行转json**\n","url":"","summary":"","reference":"","dot":""},{"prefix":"storage","tag":".getItem","suffix":"(key)","desc":"+ 获取数据\n+ 如果键名不存在，该方法返回null。","url":"","summary":"","reference":"","dot":""},{"prefix":"storage","tag":".removeItem","suffix":"(key)","desc":"+ 删除数据\n+ 如果键名不存在，该方法不会做任何事情。","url":"","summary":"","reference":"","dot":""},{"prefix":"storage","tag":".clear()","suffix":"","desc":"+ 清除所有保存的数据。\n+ 该方法的返回值是undefined。","url":"","summary":"","reference":"","dot":""}]},{"title":"遍历","fold":false,"list":[{"prefix":"storage","tag":".key","suffix":"(i)","desc":"接受一个整数作为参数（从零开始），返回该位置对应的键值\n结合使用Storage.length属性和Storage.key()方法，可以遍历所有的键。","url":"","summary":"","reference":"","dot":""},{"prefix":"storage","tag":".length","suffix":"","desc":"返回保存的数据项个数","url":"","summary":"```\nfor (var i = 0; i < window.localStorage.length; i++) {\n  console.log(localStorage.key(i));\n}\n```","reference":"","dot":""}]}]},{"title":"IndexedDB","barcolor":"","fold":false,"box":[{"title":"数据库","fold":false,"list":[{"prefix":"idb = ","tag":"indexedDB.open","suffix":"(dbname,version)","desc":"返回一个 IDBRequest 对象\n`var request = window.indexedDB.open(databaseName, version);`\n不存在时新建,新建时版本号为1\n每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/indexeddb.html","dot":""},{"prefix":"idb.on","tag":"error","suffix":"","desc":"表示打开数据库失败\n```\nrequest.onerror = function (event) {\n  console.log('数据库打开报错');\n};\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"idb.on","tag":"success","suffix":"","desc":"成功打开数据库\n```\nvar db;\n\nrequest.onsuccess = function (event) {\n  db = request.result;\n  console.log('数据库打开成功');\n};\n```\n通过request对象的result属性拿到数据库对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"idb.on","tag":"upgradeneeded","suffix":"","desc":"更新数据库（新建数据库，后续操作应在此方法内执行。）\n```\nvar db;\n\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n}\n```\n如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded。\n新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"idb.on","tag":"blocked","suffix":"","desc":"上一次的数据库连接还未关闭","url":"","summary":"","reference":"","dot":""},{"prefix":"db = ","tag":"result","suffix":"","desc":"指代数据库\n新建/升级：`db = event.target.result;`\n链接：`db = request.result;`","url":"","summary":"","reference":"","dot":""}]},{"title":"数据表-对象仓库","fold":false,"list":[{"prefix":"db","tag":".createObjectStore","suffix":"(tabel,opt)","desc":"新建对象仓库（即新建表）,通过keyPath设置主键\n```\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n  var objectStore;\n  if (!db.objectStoreNames.contains('person')) {\n    objectStore = db.createObjectStore('person', { keyPath: 'id' });\n  }\n}\n```","url":"","summary":"如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。\n```\nvar objectStore = db.createObjectStore(\n  'person',\n  { autoIncrement: true }\n);\n```","reference":"","dot":""}]},{"title":"索引","fold":false,"list":[{"prefix":"table","tag":".createIndex ","suffix":"(key,val,opt)","desc":"新建索引:索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）\n```\nrequest.onupgradeneeded = function(event) {\n  db = event.target.result;\n  var objectStore = db.createObjectStore('person', { keyPath: 'id' });\n  objectStore.createIndex('name', 'name', { unique: false });\n  objectStore.createIndex('email', 'email', { unique: true });\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"index = ","tag":"table.index","suffix":"('name')","desc":"使用索引查找数据\n```\nvar transaction = db.transaction(['person'], 'readonly');\nvar store = transaction.objectStore('person');\nvar index = store.index('name');\nvar request = index.get('李四');\n\nrequest.onsuccess = function (e) {\n  var result = e.target.result;\n  if (result) {\n    // ...\n  } else {\n    // ...\n  }\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"数据行-CURD","fold":false,"list":[{"prefix":"t_table","tag":".add","suffix":"(obj)","desc":"新增数据\n```\nfunction add() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });\n\n  request.onsuccess = function (event) {\n    console.log('数据写入成功');\n  };\n\n  request.onerror = function (event) {\n    console.log('数据写入失败');\n  }\n}\n\nadd();\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"t_table|index","tag":".get","suffix":"(pkv)","desc":"读取数据(参数是主键的值)\n```\nfunction read() {\n   var transaction = db.transaction(['person']);\n   var objectStore = transaction.objectStore('person');\n   var request = objectStore.get(1);\n\n   request.onerror = function(event) {\n     console.log('事务失败');\n   };\n\n   request.onsuccess = function( event) {\n      if (request.result) {\n        console.log('Name: ' + request.result.name);\n        console.log('Age: ' + request.result.age);\n        console.log('Email: ' + request.result.email);\n      } else {\n        console.log('未获得数据记录');\n      }\n   };\n}\n\nread();\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"t_table","tag":".put","suffix":"(obj)","desc":"更新数据\n```\nfunction update() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });\n\n  request.onsuccess = function (event) {\n    console.log('数据更新成功');\n  };\n\n  request.onerror = function (event) {\n    console.log('数据更新失败');\n  }\n}\n\nupdate();\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"t_table","tag":".delete","suffix":"(pkv)","desc":"删除记录，pkv=主键值","url":"","summary":"","reference":"","dot":""}]},{"title":"遍历","fold":false,"list":[{"prefix":"t_table","tag":".openCursor()","suffix":".onsuccess","desc":"遍历数据表格的所有记录，要使用指针对象 IDBCursor。\n```\nfunction readAll() {\n  var objectStore = db.transaction('person').objectStore('person');\n\n   objectStore.openCursor().onsuccess = function (event) {\n     var cursor = event.target.result;\n\n     if (cursor) {\n       console.log('Id: ' + cursor.key);\n       console.log('Name: ' + cursor.value.name);\n       console.log('Age: ' + cursor.value.age);\n       console.log('Email: ' + cursor.value.email);\n       cursor.continue();\n    } else {\n      console.log('没有更多数据了！');\n    }\n  };\n}\n\nreadAll();\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"Misc","fold":false,"list":[{"prefix":"","tag":"localforage","suffix":"","desc":"","url":"https://localforage.docschina.org/","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Web Worker","barcolor":"","fold":false,"box":[{"title":"主线程","fold":false,"list":[{"prefix":"","tag":"new Worker","suffix":"(path.js,[opt])","desc":"新建一个 Worker 线程,必须同源\n也可以是一个blob url","url":"","summary":"通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。\n```\n<script id=\"worker\" type=\"app/worker\">\n  addEventListener('message', function () {\n    postMessage('some message');\n  }, false);\n</script>\n```\n上面是一段嵌入网页的脚本，注意必须指定<script>标签的type属性是一个浏览器不认识的值，上例是app/worker。\n然后，读取这一段嵌入页面的脚本，用 Worker 来处理。\n```\nvar blob = new Blob([document.querySelector('#worker').textContent]);\nvar url = window.URL.createObjectURL(blob);\nvar worker = new Worker(url);\n\nworker.onmessage = function (e) {\n  // e.data === 'some message'\n};\n```","reference":"","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(data)","desc":"参数可以是各种数据类型，包括二进制数据。\n这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(buf,[buf])","desc":"快速转移arrayBuffer数据，主线程将失去控制权，非拷贝方式。\n```\nvar a = new ArrayBuffer(1);\nworker.postMessage(a, [a]);\nvar b = new Uint8Array(1);\nworker.postMessage({x:y,b:b.buffer}, [b.buffer])\n```","url":"","summary":"拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。","reference":"","dot":""},{"prefix":"worker","tag":".onmessage","suffix":"","desc":"主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息\ne.data 获取数据","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".terminate()","suffix":"","desc":"关闭worker线程","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".onerror","suffix":"","desc":"线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件\nWorker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"Worker线程","fold":false,"list":[{"prefix":"","tag":"self","suffix":"","desc":"代表子线程自身，即子线程的全局对象\n无法使用document、window、parent这些对象,但是，Worker 线程可以使用navigator对象和location对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".postMessage","suffix":"(data)","desc":"向产生这个 Worker 线程发送消息","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".onmessage","suffix":"","desc":"根据主线程发来的数据，Worker 线程可以调用不同的方法","url":"","summary":"```\nself.addEventListener('message', function (e) {\n  var data = e.data;\n  switch (data.cmd) {\n    case 'start':\n      self.postMessage('WORKER STARTED: ' + data.msg);\n      break;\n    case 'stop':\n      self.postMessage('WORKER STOPPED: ' + data.msg);\n      self.close(); // Terminates the worker.\n      break;\n    default:\n      self.postMessage('Unknown command: ' + data.msg);\n  };\n}, false);\n```","reference":"","dot":""},{"prefix":"","tag":"importScripts","suffix":"(mod.js,..)","desc":"加载其他脚本","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".close()","suffix":"","desc":"在 Worker 内部关闭自身","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Perfomance","barcolor":"","fold":false,"box":[{"title":"重排回调","fold":false,"list":[{"prefix":"window","tag":".requestAnimationFrame","suffix":"(fn)","desc":"在下次重绘之前调用指定的回调函数更新动画，返回一个ID。\n该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同，它表示requestAnimationFrame() 开始去执行回调函数的时刻。","url":"","summary":"window.requestAnimationFrame()方法跟setTimeout类似，都是推迟某个函数的执行。不同之处在于，setTimeout必须指定推迟的时间，window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，requestAnimationFrame()会暂停执行。","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame","dot":""},{"prefix":"window","tag":".cancelAnimationFrame","suffix":"(id)","desc":"取消回调函数的执行","url":"","summary":"","reference":"MDN参考|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame","dot":""}]},{"title":"空闲回调","fold":false,"list":[{"prefix":"window","tag":".requestIdleCallback","suffix":"(fn,deadline)","desc":"将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行\n`requestIdleCallback(callback, { timeout: 2000 });` 设定最大死线","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".cancelIdleCallback","suffix":"(id)","desc":"取消回调函数","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Web Socket","barcolor":"","fold":false,"box":[{"title":"基础","fold":false,"list":[{"prefix":"new ","tag":"WebSocket","suffix":"(url[, protocols])","desc":"","url":"","summary":"```\n// Create WebSocket connection.\nconst socket = new WebSocket('ws://localhost:8080');\n\n// Connection opened\nsocket.addEventListener('open', function (event) {\n    socket.send('Hello Server!');\n});\n\n// Listen for messages\nsocket.addEventListener('message', function (event) {\n    console.log('Message from server ', event.data);\n});\n```","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket","dot":""},{"prefix":"ws.","tag":"binaryType","suffix":"","desc":"+ `blob`如果传输的是 Blob 类型的数据。\n+ `arraybuffer`如果传输的是 ArrayBuffer 类型的数据。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"readyState","suffix":"","desc":"0 (WebSocket.CONNECTING) 正在链接中\n1 (WebSocket.OPEN)已经链接并且可以通讯\n2 (WebSocket.CLOSING)连接正在关闭\n3 (WebSocket.CLOSED)连接已关闭或者没有链接成功","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"bufferedAmount","suffix":"","desc":"是一个只读属性，用于返回已经被send()方法放入队列中但还没有被发送到网络中的数据的字节数。一旦队列中的所有数据被发送至网络，则该属性值将被重置为 0。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"extensions","suffix":"","desc":"返回服务器已选择的扩展值","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"protocol/url","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"方法","fold":false,"list":[{"prefix":"ws.","tag":"close()","suffix":"","desc":"关闭连接","url":"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/close","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"send","suffix":"(data)","desc":"+ `USVString`文本字符串。字符串将以 UTF-8 格式添加到缓冲区，并且 bufferedAmount 将加上该字符串以 UTF-8 格式编码时的字节数的值。\n\n+ `ArrayBuffer`您可以使用一有类型的数组对象发送底层二进制数据；其二进制数据内存将被缓存于缓冲区，bufferedAmount 将加上所需字节数的值。\n\n+ `Blob`Blob 类型将队列 blob 中的原始数据以二进制中传输。 bufferedAmount 将加上原始数据的字节数的值。\n\n+ `ArrayBufferView`您可以以二进制帧的形式发送任何 JavaScript 类数组对象 ；其二进制数据内容将被队列于缓冲区中。值 bufferedAmount 将加上必要字节数的值。","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"","tag":"message","suffix":"","desc":"接收到新消息时被触发\n```\n// 监听消息\nsocket.addEventListener('message', function (event) {\n    console.log('Message from server ', event.data);\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"open","suffix":"","desc":"建立成功时\n```\naWebSocket.onopen = function(event) {\n  console.log(\"WebSocket is open now.\");\n};\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"close","suffix":"","desc":"```\nWebSocket.onclose = function(event) {\n  console.log(\"WebSocket is closed now.\");\n};\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"error","suffix":"","desc":"```\nsocket.addEventListener('error', function (event) {\n  console.log('WebSocket error: ', event);\n});\n```","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[]}]}