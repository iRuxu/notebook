{"version":1585048658556,"name":"bom","data":[{"column":[{"title":"Navigator","barcolor":"","fold":false,"box":[{"title":"代理","fold":false,"list":[{"prefix":"navigator","tag":".userAgent","suffix":"","desc":"返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。","url":"","summary":"","reference":"","dot":""},{"prefix":"navigator","tag":".platform","suffix":"","desc":"返回用户的操作系统信息，比如MacIntel、Win32、Linux x86_64等 。","url":"","summary":"","reference":"","dot":""},{"prefix":"navigator","tag":".language","suffix":"","desc":"浏览器的首选语言。该属性只读。\nnavigator.languages属性返回一个数组，表示用户可以接受的语言","url":"","summary":"","reference":"","dot":""}]},{"title":"地理","fold":false,"list":[{"prefix":"navigator","tag":".geolocation","suffix":"","desc":"返回一个 Geolocation 对象，包含用户地理位置的信息","url":"","summary":"","reference":"","dot":""},{"prefix":"geo","tag":".getCurrentPosition","suffix":"(suc(pos),fail(err),opt)","desc":"得到用户的当前位置","url":"","summary":"# opt\n+ enableHighAccuracy：布尔值，是否返回高精度结果。如果设为true，可能导致响应时间变慢或（移动设备的）功耗增加；反之，如果设为false，设备可以更快速地响应。默认值为false。\n+ timeout：正整数，表示等待查询的最长时间，单位为毫秒。默认值为Infinity。\n+ maximumAge：正整数，表示可接受的缓存最长时间，单位为毫秒。如果设为0，表示不返回缓存值，必须查询当前的实际位置；如果设为Infinity，必须返回缓存值，不管缓存了多少时间。默认值为0。","reference":"参考资料|https://wangdoc.com/webapi/geolocation.html","dot":""},{"prefix":"geo","tag":".watchPosition","suffix":"(suc(pos),fail(err),opt)","desc":"监听用户位置变化,返回一个id","url":"","summary":"","reference":"","dot":""},{"prefix":"geo","tag":".clearWatch","suffix":"(id)","desc":"取消watchPosition()方法指定的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"pos","tag":".coords","suffix":"","desc":"coords属性指向一个对象，包含了用户的位置信息\ncoords.latitude：纬度\ncoords.longitude：经度\ncoords.accuracy：精度\ncoords.altitude：海拔\ncoords.altitudeAccuracy：海拔精度（单位：米）\ncoords.heading：以360度表示的方向\ncoords.speed：每秒的速度（单位：米）\n大多数桌面浏览器不提供上面列表的后四个值。","url":"","summary":"","reference":"","dot":""},{"prefix":"pos","tag":".timestamp","suffix":"","desc":"返回获得位置信息的具体时间","url":"","summary":"","reference":"","dot":""},{"prefix":"err.","tag":"code","suffix":"","desc":"geoError的参数也是一个event对象。event.code属性表示错误类型，有四个值\n0：未知错误，浏览器没有提示出错的原因，相当于常量event.UNKNOWN\\_ERROR。\n1：用户拒绝授权，相当于常量event.PERMISSION_DENIED。\n2：没有得到位置，GPS或其他定位机制无法定位，相当于常量event.POSITION\\_UNAVAILABLE。\n3：超时，GPS没有在指定时间内返回结果，相当于常量event.TIMEOUT。","url":"","summary":"","reference":"","dot":""},{"prefix":"err","tag":".message","suffix":"","desc":"字符串，表示错误的描述。","url":"","summary":"","reference":"","dot":""}]},{"title":"状态","fold":true,"list":[{"prefix":"navigator","tag":".onLine","suffix":"","desc":"返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。\n有时，浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的onLine属性会返回true，所以不能假定只要是true，用户就一定能访问互联网。不过，如果是false，可以断定用户一定离线。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"offline","suffix":"","desc":"离线事件","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"online","suffix":"","desc":"上线事件","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Location","barcolor":"","fold":false,"box":[{"title":"location","fold":false,"list":[{"prefix":"window","tag":".isSecureContext","suffix":"","desc":"返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是true，否则就是false。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".<prop>","suffix":"","desc":"+ location.href：整个 URL。\n+ location.origin：URL 的协议、主机名和端口。\n+ location.protocol：当前 URL 的协议，包括冒号（:）。\n+ location.host：主机。如果端口不是协议默认的80和433，则还会包括冒号（:）和端口。\n+ location.hostname：主机名，不包括端口。\n+ location.port：端口号。\n+ location.pathname：URL 的路径部分，从根路径/开始。\n+ location.search：查询字符串部分，从问号?开始。\n+ location.hash：片段字符串部分，从#开始。\n+ location.username：域名前面的用户名。\n+ location.password：域名前面的密码。\n只有origin属性是只读的，其他属性都可写\n","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".assign","suffix":"(url)","desc":"立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".replace","suffix":"(url)","desc":"浏览器立刻跳转到新的 URL。\nreplace会在浏览器的浏览历史History里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".reload","suffix":"([true])","desc":"重新加载当前网址，相当于按下浏览器的刷新按钮。\n它接受一个布尔值作为参数。如果参数为true，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即scrollTop === 0）。如果参数是false或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"hashchange","suffix":"","desc":"变更锚点#","url":"","summary":"","reference":"","dot":""}]},{"title":"URL","fold":false,"list":[{"prefix":"","tag":"new URL","suffix":"(url)","desc":"创建一个url实例","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/location.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95","dot":""}]},{"title":"URLSearchParams","fold":false,"list":[{"prefix":"","tag":"new URLSearchParams","suffix":"(val)","desc":"构造、解析和处理 URL 的查询字符串.\n对查询字符串自动编码","url":"","summary":"```\n// 方法一：传入字符串\nvar params = new URLSearchParams('?foo=1&bar=2');\n// 等同于\nvar params = new URLSearchParams(document.location.search);\n\n// 方法二：传入数组\nvar params = new URLSearchParams([['foo', 1], ['bar', 2]]);\n\n// 方法三：传入对象\nvar params = new URLSearchParams({'foo' : 1 , 'bar' : 2});\n```","reference":"参考资料|https://wangdoc.com/javascript/bom/location.html#urlsearchparams-%E5%AF%B9%E8%B1%A1\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams","dot":""},{"prefix":"params","tag":".toString()","suffix":"","desc":"返回实例的字符串形式","url":"","summary":"```\nvar params = new URLSearchParams({version: 2.0});\nwindow.location.href = location.pathname + '?' + params;\n```\n上面代码中，location.href赋值时，可以直接使用params对象。这时就会自动调用toString方法。","reference":"","dot":""},{"prefix":"params","tag":".get","suffix":"(key)","desc":"读取查询字符串里面的指定键,不存在返回null\n`params.getAll()` 方法返回一个数组，成员是指定键的所有键值。\n","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".has","suffix":"(key)","desc":"返回一个布尔值，表示查询字符串是否包含指定的键名","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".append","suffix":"(key,val)","desc":"追加一个查询参数,没有返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".set","suffix":"(key,val)","desc":"设置查询字符串的键值.如果是已经存在的键，键值会被改写，否则会被追加。","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".delete","suffix":"(key)","desc":"删除指定的查询参数","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".sort()","suffix":"","desc":"对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".entries()","suffix":"","desc":"URLSearchParams实例有遍历器接口，可以用for...of循环遍历\nparams.keys()\nparams.values()\nparams.entries()","url":"","summary":"```\nvar params = new URLSearchParams({'foo': 1 , 'bar': 2});\n\nfor (var p of params) {\n  console.log(p[0] + ': ' + p[1]);\n}\n// foo: 1\n// bar: 2\n```","reference":"","dot":""}]}]},{"title":"History","barcolor":"","fold":false,"box":[{"title":"访问","fold":false,"list":[{"prefix":"history","tag":".length","suffix":"","desc":"当前窗口一共访问过的网址个数","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".back()","suffix":"","desc":"等同`history.go(-1)`\n移动到上一个网址，等同于点击浏览器的后退键。\n注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".forward()","suffix":"","desc":"移动到下一个网址，等同于点击浏览器的前进键。","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".go","suffix":"(n)","desc":"接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如go(1)相当于forward()，go(-1)相当于back()。如果不指定参数，默认参数为0，相当于刷新当前页面。","url":"","summary":"","reference":"","dot":""}]},{"title":"记录","fold":false,"list":[{"prefix":"history","tag":".state","suffix":"","desc":"history 堆栈最上层的状态值","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/history.html\nVue|https://juejin.im/post/5ceedf8ff265da1b80202841","dot":""},{"prefix":"history","tag":".pushState","suffix":"(state,title,path)","desc":"使用pushState()方法在浏览记录（History 对象）中添加一个新记录。\n不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。\n```\nvar stateObj = { foo: 'bar' };\nhistory.pushState(stateObj, 'page 2', '2.html');\n```","url":"","summary":"如果pushState的 URL 参数设置了一个新的锚点值（即hash），并不会触发hashchange事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。","reference":"","dot":""},{"prefix":"history","tag":".replaceState","suffix":"(state,title,path)","desc":"修改 History 对象的当前记录，其他都与pushState()方法一模一样","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"popstate","suffix":"","desc":"每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。","url":"","summary":"注意，仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。\n\n回调函数的参数是一个event事件对象，它的state属性指向pushState和replaceState方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的event.state，就是通过pushState和replaceState方法，为当前 URL 绑定的state对象。","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"window.on","tag":"pageshow","suffix":"","desc":"即使从缓存中加载也会触发该事件\npageshow 事件有一个persisted属性，返回一个布尔值。\n页面第一次加载时，这个属性是false；当页面从缓存加载时，这个属性是true。","url":"","summary":"注意，这两个事件只在浏览器的history对象发生变化时触发，跟网页是否可见没有关系。","reference":"","dot":""},{"prefix":"window.on","tag":"pagehide","suffix":"","desc":"pagehide事件实例也有一个persisted属性\n将这个属性设为true，就表示页面要保存在缓存中；\n设为false，表示网页不保存在缓存中","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Window","barcolor":"","fold":false,"box":[{"title":"事件","fold":false,"list":[{"prefix":"window.on","tag":"load","suffix":"","desc":"文档和资源浏览器窗口加载完毕时\n注意，页面或资源从浏览器缓存加载，并不会触发load事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"beforeunload","suffix":"","desc":"在窗口、文档、各种资源将要卸载前触发\n它可以用来防止用户不小心卸载资源","url":"","summary":"如果该事件对象的returnValue属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。\n```\nwindow.addEventListener('beforeunload', function (e) {\n  var confirmationMessage = '确认关闭窗口？';\n\n  e.returnValue = confirmationMessage;\n  return confirmationMessage;\n});\n```","reference":"","dot":""},{"prefix":"window.on","tag":"focus","suffix":"","desc":"激活窗口，获得焦点","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"blur","suffix":"","desc":"失去焦点","url":"","summary":"","reference":"","dot":""}]},{"title":"窗口","fold":false,"list":[{"prefix":"window.","tag":"name","suffix":"","desc":"当前浏览器窗口的名字","url":"","summary":"只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问a.com时，该页面的脚本设置了window.name，接下来在同一个窗口里面载入了b.com，新页面的脚本可以读到上一个网页设置的window.name。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。","reference":"","dot":""},{"prefix":"window.","tag":"closed","suffix":"","desc":"检查当前窗口是否关闭\n`(popup !== null) && !popup.closed`","url":"","summary":"","reference":"","dot":""},{"prefix":"window.","tag":"opener","suffix":"","desc":"打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回null。","url":"","summary":"通过opener属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况，且其中一个窗口由另一个打开。a元素添加rel=\"noopener\"属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。","reference":"","dot":""},{"prefix":"window","tag":".open","suffix":"(url,name,opt)","desc":"打开一个新窗口,如果无法新建窗口，则返回null\n`var newWin = window.open('example.html', 'newWindow', 'height=400,width=400');`","url":"","summary":"strWindowFeatures是一个字符串值，这个值列出了将要打开的窗口的一些特性(窗口功能和工具栏) 。 字符串中不能包含任何空白字符，特性之间用逗号分隔开。对于那些可以打开和关闭的属性，设为yes或1或不设任何值就表示打开\n\nleft：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。\ntop：新窗口距离屏幕最顶部的距离（单位像素）。\nheight：新窗口内容区域的高度（单位像素），不得小于100。\nwidth：新窗口内容区域的宽度（单位像素），不得小于100。\nouterHeight：整个浏览器窗口的高度（单位像素），不得小于100。\nouterWidth：整个浏览器窗口的宽度（单位像素），不得小于100。\nmenubar：是否显示菜单栏。\ntoolbar：是否显示工具栏。\nlocation：是否显示地址栏。\npersonalbar：是否显示用户自己安装的工具栏。\nstatus：是否显示状态栏。\ndependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。\nminimizable：是否有最小化按钮，前提是dialog=yes。\nnoopener：新窗口将与父窗口切断联系，即新窗口的window.opener属性返回null，父窗口的window.open()方法也返回null。\nresizable：新窗口是否可以调节大小。\nscrollbars：是否允许新窗口出现滚动条。\ndialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。\ntitlebar：新窗口是否显示标题栏。\nalwaysRaised：是否显示在所有窗口的顶部。\nalwaysLowered：是否显示在父窗口的底下。\nclose：新窗口是否显示关闭按钮。","reference":"MDN参考|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open","dot":""},{"prefix":"window","tag":".close()","suffix":"","desc":"关闭当前窗口，一般只用来关闭window.open方法新建的窗口。\n`popup.close()`\n该方法只对顶层窗口有效，iframe框架之中的窗口使用该方法无效。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".stop()","suffix":"","desc":"完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。","url":"","summary":"","reference":"","dot":""}]},{"title":"视口","fold":false,"list":[{"prefix":"ele.on","tag":"scroll","suffix":"","desc":"页面或元素滚动时，会触发scroll事件，导致执行onscroll()","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/events/common.html","dot":""},{"prefix":"ele.on","tag":"resize","suffix":"","desc":"改变大小时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"fullscreenchange","suffix":"","desc":"进入或退出全屏状态时触发\nfullscreenerror事件在浏览器无法切换到全屏状态时触发","url":"","summary":"","reference":"","dot":""}]},{"title":"组件","fold":false,"list":[{"prefix":"window","tag":".print()","suffix":"","desc":"跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。\n桌面设备（比如手机）可能没有打印功能，这时可以这样判断。\n`typeof window.print === 'function'`","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".alert","suffix":"(msg)","desc":"弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。","url":"","summary":"用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。参数只能是字符串，没法使用 CSS 样式，但是可以用\\n指定换行。","reference":"","dot":""},{"prefix":"window","tag":".prompt","suffix":"(msg,default)","desc":"弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。\n# 返回值\n+ 用户输入信息，并点击“确定”，则用户输入的信息就是返回值。\n+ 用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。\n+ 用户点击了“取消”（或者按了 ESC 按钮），则返回值是null。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".confirm","suffix":"(msg)","desc":"弹出一个对话框\n返回一个布尔值，如果用户点击“确定”，返回true；如果用户点击“取消”，则返回false。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Frame","barcolor":"","fold":false,"box":[{"title":"父框架","fold":false,"list":[{"prefix":"window","tag":".self","suffix":"","desc":"window.self和window.window属性都指向窗口本身。这两个属性只读。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".frames","suffix":"","desc":"返回一个类似数组的对象，成员为页面内所有框架窗口，包括frame元素和iframe元素。\n`window.frames[0]`表示页面中第一个框架窗口,是一个window对象","url":"","summary":"如果iframe元素设置了id或name属性，那么就可以用属性值，引用这个iframe窗口。比如`<iframe name=\"myIFrame\">`可以用frames['myIFrame']或者frames.myIFrame来引用。","reference":"","dot":""},{"prefix":"frame","tag":".contentWindow","suffix":"","desc":"获得iframe节点包含的window对象\n在满足同源限制的情况下，可以读取子窗口内部的属性。","url":"","summary":"","reference":"","dot":""},{"prefix":"frame","tag":".contentDocument","suffix":"","desc":"子窗口的document对象","url":"","summary":"","reference":"","dot":""}]},{"title":"子框架","fold":false,"list":[{"prefix":"window","tag":".parent","suffix":"","desc":"指向父窗口,如果当前窗口没有父窗口，window.parent指向自身。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".top","suffix":"","desc":"指向最顶层窗口","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".frameElement","suffix":"","desc":"返回当前窗口所被嵌入的那个元素节点\n对于非嵌入的窗口，该属性等于null。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"postMessage","barcolor":"","fold":false,"box":[{"title":"postMessage","fold":false,"list":[{"prefix":"window","tag":".postMessage","suffix":"(val)","desc":"向window发送信息,不限制同源","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"message","suffix":"","desc":"双方监听消息事件","url":"","summary":"","reference":"","dot":""},{"prefix":"event","tag":".<prop>","suffix":"","desc":"event.data: 消息内容\nevent.source：发送消息的窗口\nevent.origin: 消息发向的网址","url":"","summary":"","reference":"","dot":""}]},{"title":"旧方案","fold":false,"list":[{"prefix":"iframe","tag":"#hash","suffix":"","desc":"片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Document","barcolor":"","fold":false,"box":[{"title":"文档","fold":false,"list":[{"prefix":"document.on","tag":"DOMContentLoaded","suffix":"","desc":"DOMContentLoaded事件只有在 DOM 结构生成之后才会触发\n```\ndocument.addEventListener(\"DOMContentLoaded\", function(event) {\n    console.log(document.body.innerHTML);\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"readystatechange","suffix":"","desc":"当 Document 对象和 XMLHttpRequest 对象的readyState属性发生变化时触发。\n+ loading（网页正在加载）、\n+ interactive（网页已经解析完成，但是外部资源仍然处在加载状态）\n+ complete（网页和所有外部资源已经结束加载，load事件即将触发）。","url":"","summary":"","reference":"","dot":""},{"prefix":"window.","tag":"document","suffix":"","desc":"只有来自同源的脚本才能读取这个属性","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Source","barcolor":"","fold":false,"box":[{"title":"状态","fold":false,"list":[{"prefix":"source","tag":".complete","suffix":"","desc":"完成状态\n有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能load和error事件的监听函数根本不会执行。所以，比较可靠的方式，是用complete属性先判断一下是否加载完成。","url":"","summary":"","reference":"","dot":""}]},{"title":"进度","fold":false,"list":[{"prefix":"source.on","tag":"load","suffix":"","desc":"资源加载成功时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"loadstart","suffix":"","desc":"外部资源开始加载时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"progress","suffix":"","desc":"部资源加载过程中不断触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"loadend","suffix":"","desc":"外部资源停止加载时触发，发生顺序排在error、abort、load等事件的后面\n类似finally性质","url":"","summary":"","reference":"","dot":""}]},{"title":"异常","fold":false,"list":[{"prefix":"source.on","tag":"abort","suffix":"","desc":"资源中止加载时（比如用户取消）触发。\n如果发生错误导致中止，不会触发该事件。","url":"","summary":"ProgressEvent接口主要用来描述外部资源加载的进度，比如 AJAX 加载、img、video、style、link等外部资源加载。进度相关的事件都继承了这个接口。\n+ lengthComputable：布尔值，表示加载的总量是否可以计算，默认是false。\n+ loaded：整数，表示已经加载的量，默认是0。\n+ total：整数，表示需要加载的总量，默认是0。","reference":"","dot":""},{"prefix":"source.on","tag":"error","suffix":"","desc":"由于错误导致资源无法加载时触发。\nerror事件有一个特殊的性质，就是不会冒泡。所以，子元素的error事件，不会触发父元素的error事件监听函数。","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"timeout","suffix":"","desc":"加载超时时触发","url":"","summary":"","reference":"","dot":""}]}]},{"title":"交互事件","barcolor":"","fold":false,"box":[{"title":"编辑","fold":false,"list":[{"prefix":"ele","tag":".contenteditable","suffix":"","desc":"允许用户修改内容\n+ true或空字符串：内容可以编辑\n+ false：不可以编辑","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".getSelection()","suffix":"","desc":"返回一个Selection对象，表示用户现在选中的文本\n`selection.toString()` 得到选中的文本","url":"","summary":"","reference":"","dot":""}]},{"title":"解析","fold":false,"list":[]},{"title":"剪贴板","fold":false,"list":[{"prefix":"document.on","tag":"copy","suffix":"","desc":"用户拷贝元素上的内容时触发（包括img）","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"cut","suffix":"","desc":"将选中的内容从文档中移除，加入剪贴板时触发\n对于不可编辑的元素，除非设置contenteditable 为 \"true\"","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"paste","suffix":"","desc":"用户粘贴元素内容时触发\n对于不可编辑的元素，除非设置contenteditable 为 \"true\"","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".clipboardData","suffix":"","desc":"该属性存放剪贴的数据,只读属性\n是一个 DataTransfer 对象","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"clipboard.js","suffix":"","desc":"","url":"https://github.com/zenorocha/clipboard.js","summary":"","reference":"","dot":""}]},{"title":"焦点","fold":false,"list":[{"prefix":"ele.on","tag":"focus","suffix":"","desc":"获得焦点时,该事件不会冒泡,**只能在捕获阶段触发**\nfocusin：元素节点将要获得焦点时触发，发生在focus事件之前。该事件会冒泡。","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"blur","suffix":"","desc":"失去焦点时,该事件不会冒泡,只能在捕获阶段触发\nfocusout：元素节点将要失去焦点时触发，发生在blur事件之前。该事件会冒泡。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Event","barcolor":"","fold":false,"box":[{"title":"事件","fold":false,"list":[{"prefix":"","tag":"new Event","suffix":"(type,[opt])","desc":"Event对象本身就是一个构造函数，可以用来生成新的实例。\n```\nnew Event('custom',{\n    'bubbles': true,\n    'cancelable': true\n}\n```","url":"","summary":"# 事件传播\n第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。\n第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。\n第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。\n# 事件代理\n由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。","reference":"参考资料|https://wangdoc.com/javascript/events/model.html","dot":""},{"prefix":"","tag":"new CustomEvent","suffix":"(type,opt)","desc":"自定义的事件实例\nopt.detail：表示事件的附带数据，默认为null。","url":"","summary":"","reference":"","dot":""},{"prefix":"target","tag":".dispatchEvent","suffix":"(evt)","desc":"在当前节点上触发指定事件，从而触发监听函数的执行,参数是**事件对象**。\n该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。","url":"","summary":"```\npara.addEventListener('click', hello, false);\nvar event = new Event('click');\npara.dispatchEvent(event);\n```","reference":"","dot":""}]},{"title":"监听","fold":false,"list":[{"prefix":"target","tag":".addEventListener","suffix":"(type,fn,[opt])","desc":"# `target.addEventListener(type,fn)`\n添加事件监听,监听函数内部的this，指向当前事件所在的那个对象\n+ type：事件名称，大小写敏感。\n+ listener：监听函数。事件发生时，会调用该监听函数。\n第二种属性的值是将会执行的代码，而不是一个函数\n+ useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。\n可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除\n\n# `target.ontype = fn`\n它的值是函数名，只会在冒泡阶段触发。同一个事件只能定义一个监听函数\n\n# `ele ontype=\"fn()\"`\n属性的值是将会执行的代码，而不是一个函数。只会在冒泡阶段触发","url":"","summary":"第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象\n```\nbuttonElement.addEventListener('click', {\n  handleEvent: function (event) {\n    console.log('click');\n  }\n});\n```\n第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。\ncapture：布尔值，表示该事件是否在捕获阶段触发监听函数。\nonce：布尔值，表示监听函数是否只触发一次，然后就自动移除。\npassive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。","reference":"","dot":""},{"prefix":"target","tag":".removeEventListener","suffix":"(type,fn)","desc":"移除addEventListener方法添加的事件监听函数","url":"","summary":"","reference":"","dot":""}]},{"title":"事件对象","fold":false,"list":[{"prefix":"e","tag":".<prop>","suffix":"","desc":"+ type 返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。\n+ timeStamp 返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。\n+ isTrusted 返回一个布尔值，表示该事件是否由真实的用户行为产生","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".cancelable","suffix":"","desc":"是否可以被取消，即能否用Event.preventDefault()取消这个事件，默认为false\n一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。\n","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".preventDefault()","suffix":"","desc":"取消这个事件，阻止浏览器对该事件的默认行为,不会阻止事件的传播","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".bubbles","suffix":"","desc":"是否冒泡,不影响目标本身触发该事件,默认为false\n如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数\n`e.eventPhase` 事件的具体阶段","url":"","summary":"# Event.eventPhase\n0，事件目前没有发生。\n1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。\n2，事件到达目标节点，即Event.target属性指向的那个节点。\n3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。","reference":"","dot":""},{"prefix":"e","tag":".stopPropagation()","suffix":"","desc":"阻止冒泡.\n等同`e.cancelBubble = false`\niPhone默认阻止冒泡，故慎用事件委托，给指定元素添加手型样式可开启冒泡，让其认可该为一个可点击区域。","url":"","summary":"","reference":"","dot":""},{"prefix":"e.","tag":"stopImmediatePropagation()","suffix":"","desc":"彻底取消这个事件，使得后面绑定的所有监听函数都不再触发","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".target","suffix":"","desc":"`e.target` 返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。\n`e.currentTarget`属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。","url":"","summary":"事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的原始触发节点（Event.target），另一个是事件当前正在通过的节点（Event.currentTarget）。前者通常是后者的后代节点。","reference":"","dot":""},{"prefix":"e","tag":".composedPath()","suffix":"","desc":"返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"鼠标事件","barcolor":"","fold":false,"box":[{"title":"点击","fold":false,"list":[{"prefix":"ele.on","tag":"mousedown","suffix":"","desc":"按下鼠标键时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseup","suffix":"","desc":"释放按下的鼠标键时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"click","suffix":"","desc":"左|中键点击事件 onmousedown -> onmouseup -> onclick","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"contextmenu","suffix":"","desc":"右键点击事件 onmousedown -> onmouseup -> oncontextmenu\n指定return false，将不显示浏览器默认菜单","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"dblclick","suffix":"","desc":"左键双击事件 onmousedown -> onmouseup -> onclick -> dblclick","url":"","summary":"","reference":"","dot":""}]},{"title":"移动","fold":false,"list":[{"prefix":"ele.on","tag":"mouseenter","suffix":"","desc":"鼠标进入一个节点时触发，进入子节点不会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseleave","suffix":"","desc":"鼠标离开一个节点时触发，离开父节点不会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseover","suffix":"","desc":"mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。两者的区别是，mouseenter事件只触发一次，而只要鼠标在节点内部移动，mouseover事件会在子节点上触发多次。","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseout","suffix":"","desc":"鼠标离开一个节点时触发，离开父节点也会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mousemove","suffix":"","desc":"当鼠标在一个节点内部移动时触发。\n当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。","url":"","summary":"","reference":"","dot":""}]},{"title":"MouseEvent","fold":false,"list":[{"prefix":"e","tag":".<k>Key","suffix":"","desc":"+ ctrlKey：布尔值，是否同时按下了 Ctrl 键，默认值为false。\n+ shiftKey：布尔值，是否同时按下了 Shift 键，默认值为false。\n+ altKey：布尔值，是否同时按下 Alt 键，默认值为false。\n+ metaKey：布尔值，是否同时按下 Meta 键，默认值为false。","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".getModifierState","suffix":"(key)","desc":"返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示功能键的字符串。","url":"","summary":"```\ndocument.addEventListener('click', function (e) {\n  console.log(e.getModifierState('CapsLock'));\n}, false);\n```\n上面的代码可以了解用户是否按下了大写键。","reference":"","dot":""},{"prefix":"e","tag":".button","suffix":"[s]","desc":"button：数值，表示按下了哪一个鼠标按键，默认值为0，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；1表示按下辅助键（通常是鼠标的中间键），2表示按下次要键（通常是鼠标的右键）。\nbuttons：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为0（没有按下任何键）。1（二进制001）表示按下主键（通常是左键），2（二进制010）表示按下次要键（通常是右键），4（二进制100）表示按下辅助键（通常是中间键）。因此，如果返回3（二进制011）就表示同时按下了左键和右键。","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".relatedTarget","suffix":"","desc":"节点对象，表示事件的相关节点，默认为null。\n<table><thead><tr><th>事件名称</th><th>target 属性</th><th>relatedTarget 属性</th></tr></thead><tbody><tr><td>focusin</td><td>接受焦点的节点</td><td>丧失焦点的节点</td></tr><tr><td>focusout</td><td>丧失焦点的节点</td><td>接受焦点的节点</td></tr><tr><td>mouseenter</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>mouseleave</td><td>将要离开的节点</td><td>将要进入的节点</td></tr><tr><td>mouseout</td><td>将要离开的节点</td><td>将要进入的节点</td></tr><tr><td>mouseover</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>dragenter</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>dragexit</td><td>将要离开的节点</td><td>将要进入的节点</td></tr></tbody></table>","url":"","summary":"","reference":"","dot":""}]},{"title":"滚轮","fold":false,"list":[{"prefix":"ele.on","tag":"wheel","suffix":"","desc":"滚动鼠标的滚轮时触发\n+ deltaX：数值，表示滚轮的水平滚动量，默认值是 0.0。\n+ deltaY：数值，表示滚轮的垂直滚动量，默认值是 0.0。\n+ deltaZ：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。\n+ deltaMode：数值，表示相关的滚动事件的单位，适用于上面三个属性。0表示滚动单位为像素，1表示单位为行，2表示单位为页，默认为0。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"键盘事件","barcolor":"","fold":false,"box":[{"title":"按键","fold":false,"list":[{"prefix":"ele.on","tag":"keydown","suffix":"","desc":"按下键盘时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"keypress","suffix":"","desc":"按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。\n有值键 onkeydown -> onkeypress -> onkeyup\n无值键 onkeydown -> onkeyup\n按键不松 (onkeydown -> onkeypress)*n -> onkeyup","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"keyup","suffix":"","desc":"松开键盘时触发该事件","url":"","summary":"","reference":"","dot":""}]},{"title":"KeyboardEvent","fold":false,"list":[{"prefix":"e","tag":".key","suffix":"","desc":"字符串，当前按下的键，默认为空字符串。例如“a”","url":"","summary":"","reference":"code|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values","dot":""},{"prefix":"e","tag":".repeat","suffix":"","desc":"返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发keydown和keypress事件，直到用户松开手为止。","url":"","summary":"","reference":"","dot":""},{"prefix":"e.","tag":"<key>Key","suffix":"","desc":"KeyboardEvent.altKey：是否按下 Alt 键\nKeyboardEvent.ctrlKey：是否按下 Ctrl 键\nKeyboardEvent.metaKey：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）\nKeyboardEvent.shiftKey：是否按下 Shift 键","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".getModifierState","suffix":"(key)","desc":"返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。\nAlt：Alt 键\nCapsLock：大写锁定键\nControl：Ctrl 键\nMeta：Meta 键\nNumLock：数字键盘开关键\nShift：Shift 键","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"File","barcolor":"","fold":false,"box":[{"title":"路径","fold":false,"list":[{"prefix":"","tag":"file://","suffix":"url","desc":"本地文件系统里面的文件","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"data://","suffix":"value","desc":"URL 包含实际数据","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"blob://","suffix":"sign","desc":"表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象","url":"","summary":"浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。","reference":"","dot":""},{"prefix":"URL","tag":".createObjectURL","suffix":"(fileblob)","desc":"为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了File对象或Blob对象的 URL。","url":"","summary":"```\n// HTML 代码如下\n// <div id=\"display\"/>\n// <input\n//   type=\"file\"\n//   id=\"fileElem\"\n//   multiple\n//   accept=\"image/*\"\n//   onchange=\"handleFiles(this.files)\"\n//  >\nvar div = document.getElementById('display');\n\nfunction handleFiles(files) {\n  for (var i = 0; i < files.length; i++) {\n    var img = document.createElement('img');\n    img.src = window.URL.createObjectURL(files[i]);\n    div.appendChild(img);\n  }\n}\n```\n上面代码中，URL.createObjectURL()方法用来为上传的文件生成一个 URL 字符串，作为img元素的图片来源。\n该方法生成的 URL 就像下面的样子。\n`blob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1`","reference":"","dot":""},{"prefix":"URL","tag":".revokeObjectURL","suffix":"(src)","desc":"释放URL.createObjectURL()方法生成的 URL 实例。它的参数就是URL.createObjectURL()方法返回的 URL 字符串。","url":"","summary":"```\nvar div = document.getElementById('display');\n\nfunction handleFiles(files) {\n  for (var i = 0; i < files.length; i++) {\n    var img = document.createElement('img');\n    img.src = window.URL.createObjectURL(files[i]);\n    div.appendChild(img);\n    img.onload = function() {\n      window.URL.revokeObjectURL(this.src);\n    }\n  }\n}\n```\n上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在img.onload回调函数里面，通过URL.revokeObjectURL()方法卸载这个 URL 实例。","reference":"","dot":""},{"prefix":"FileSaver","tag":" ","suffix":"","desc":"","url":"https://github.com/eligrey/FileSaver.js","summary":"","reference":"","dot":""}]},{"title":"Blob","fold":false,"list":[{"prefix":"","tag":"new Blob","suffix":"(arr,opt)","desc":"表示一个二进制文件的数据内容 `new Blob(arr,{type:'text/html'})`\n第一个参数：数组，成员是字符串或二进制对象\n第二个参数，MIME类型","url":"","summary":"Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object （二进制大型对象）的缩写。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。\nBlob构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性type，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。","reference":"","dot":""},{"prefix":"blob","tag":".size","suffix":"","desc":"返回数据的大小\nUTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 \nUnicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。","url":"","summary":"","reference":"","dot":""},{"prefix":"blob","tag":".type","suffix":"","desc":"返回数据的类型","url":"","summary":"","reference":"","dot":""},{"prefix":"blob","tag":".slice","suffix":"[start,end)","desc":"拷贝原来的数据，返回的也是一个Blob实例","url":"","summary":"","reference":"","dot":""}]},{"title":"FileList","fold":false,"list":[{"prefix":"filelist","tag":".item","suffix":"(i)","desc":"FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象\nFile 实例对象是一个特殊的 Blob 实例\n+ 文件选择器 `ele.files[0]`\n+ 拖放 `dataTransfer.files[i]`","url":"","summary":"文件选择器`<input type=\"file\">`用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的value属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。\n文件选择器返回一个 FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了name和lastModifiedDate属性。\n除了文件选择器，拖放 API 的dataTransfer.files返回的也是一个FileList 对象，它的成员因此也是 File 实例对象","reference":"","dot":""},{"prefix":"fileblob","tag":".name","suffix":"","desc":"文件名，不含路径","url":"","summary":"","reference":"","dot":""},{"prefix":"fileblob","tag":".lastModifiedDate","suffix":"","desc":"文件的最后修改时间","url":"","summary":"","reference":"","dot":""}]},{"title":"FileReader","fold":false,"list":[{"prefix":"","tag":"new FileReader()","suffix":"","desc":"通过FileReader对象，读取 Blob 对象的内容，即文件内容","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsText","suffix":"(data,[encoding])","desc":"返回文本，需要指定文本编码，默认为 UTF-8。\n根据特殊的编码格式转化为内容(字符串形式),这个方法是异步的，也就是说，只有当执行完成后才能够查看到结果，如果直接查看是无结果的，并返回undefined","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsArrayBuffer","suffix":"(data)","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsDataURL","suffix":"(data)","desc":"开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".onload","suffix":" = fn","desc":"该事件在读取操作完成时触发\n+ onabort 在读取操作被中断时触发。\n+ onerror 在读取操作发生错误时触发。\n+ onload 在读取操作完成时触发。\n+ onloadstart 在读取操作开始时触发。\n+ onloadend 在读取操作结束时（要么成功，要么失败）触发。\n+ onprogress 在读取Blob时触发。\n+ readyState：整数，表示读取文件时的当前状态。一共有三种可能的状态，0表示尚未加载任何数据，1表示数据正在加载，2表示加载完成。","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader","dot":""},{"prefix":"reader","tag":".result","suffix":"","desc":"文件的内容,该属性仅在读取操作完成后才有效\n数据的格式取决于使用哪个方法来启动读取操作。","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".abort()","suffix":"","desc":"中止读取操作","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Drag","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"表单","barcolor":"","fold":false,"box":[{"title":"FormData","fold":true,"list":[{"prefix":"","tag":"new FormData","suffix":"(formele)","desc":"FormData()构造函数的参数是一个表单元素，这个参数是可选的。如果省略参数，就表示一个空的表单，否则就会处理表单元素里面的键值对。","url":"","summary":"```javascript\nvar myForm = document.getElementById('myForm');\nvar formData = new FormData(myForm);\n\n// 获取某个控件的值\nformData.get('username') // \"\"\n\n// 设置某个控件的值\nformData.set('username', '张三');\n```","reference":"HTML表单|https://www.runoob.com/html/html-forms.html","dot":""},{"prefix":"formdata","tag":".get|getAll","suffix":"(key)","desc":"+ get获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。\n+ getAll返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。","url":"","summary":"```javascript\nvar formData = new FormData();\n\nformData.set('username', '张三');\nformData.append('username', '李四');\nformData.get('username') // \"张三\"\nformData.getAll('username') // [\"张三\", \"李四\"]\n\nformData.append('userpic[]', myFileInput.files[0], 'user1.jpg');\nformData.append('userpic[]', myFileInput.files[1], 'user2.jpg');\n```","reference":"","dot":""},{"prefix":"formdata","tag":".set","suffix":"(key,val)","desc":"设置指定键名的键值，参数为键名。\n如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。\n如果第二个参数是文件，还可以使用第三个参数，表示文件名。","url":"","summary":"","reference":"","dot":""},{"prefix":"formdata","tag":".append","suffix":"(key,val)","desc":"添加一个键值对。\n如果键名重复，则会生成两个相同键名的键值对。\n如果第二个参数是文件，还可以使用第三个参数，表示文件名。","url":"","summary":"","reference":"","dot":""},{"prefix":"formdata","tag":".delete","suffix":"(key)","desc":"删除一个键值对，参数为键名。","url":"","summary":"","reference":"","dot":""},{"prefix":"formdata","tag":".has","suffix":"(key)","desc":"返回一个布尔值，表示是否具有该键名的键值对。","url":"","summary":"","reference":"","dot":""},{"prefix":"formdata","tag":".keys|values|entries()","suffix":"","desc":"返回一个遍历器对象","url":"","summary":"","reference":"","dot":""}]},{"title":"表单事件","fold":false,"list":[{"prefix":"on","tag":"input","suffix":"","desc":"+ input、select、textarea的值发生变化时触发\n+ radio、checkbox值发生改变时\n+ 打开contenteditable属性的元素，只要值发生变化","url":"","summary":"该事件跟change事件很像，不同之处在于input事件在元素的值发生变化后立即发生，而change在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，input事件会触发多次，而change事件只在失去焦点时触发一次。","reference":"","dot":""},{"prefix":"on","tag":"change","suffix":"","desc":"+ 激活单选框（radio）或复选框（checkbox）时触发。\n+ 用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。\n+ 当文本框或textarea元素的值发生改变，并且丧失焦点时触发。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"select","suffix":"","desc":"在input、textarea里面选中文本时触发\n选中的文本可以通过event.target元素的selectionDirection、selectionEnd、selectionStart和value属性拿到。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"invalid","suffix":"","desc":"用户提交表单时，如果表单元素的值不满足校验条件，就会触发invalid事件","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"reset","suffix":"","desc":"当表单重置（所有表单成员变回默认值）时触发\n发生在表单对象form上，而不是发生在表单的成员上。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"submit","suffix":"","desc":"当表单数据向服务器提交时触发。\n注意，submit事件的发生对象是form元素，而不是button元素，因为提交的是表单，而不是按钮。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"XHR","barcolor":"","fold":false,"box":[{"title":"范例","fold":false,"list":[{"prefix":"xhr = ","tag":"new XMLHttpRequest()","suffix":"","desc":"`var xhr = new XMLHttpRequest();`\n新建实例","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/xmlhttprequest.html\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest","dot":""},{"prefix":"xhr","tag":".open","suffix":"(method,url,true)","desc":"`xhr.open('GET', 'http://www.example.com/page.php', true);`\n使用 GET 方法，跟指定的服务器网址建立连接。第三个参数true，表示请求是异步的。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".setRequestHeader","suffix":"(key,val)","desc":"设置头信息","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".withCredentials","suffix":"","desc":"如果需要跨域 AJAX 请求发送 Cookie，需要withCredentials属性设为true。\n注意，同源的请求不需要设置这个属性。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".send","suffix":"(data)","desc":"`xhr.send(null);`\nsend()的参数为null，表示发送请求的时候，不带有数据体。如果发送的是 POST 请求，这里就需要指定数据体。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onreadystatechange","suffix":"= fn","desc":"旦XMLHttpRequest实例的状态发生变化，就会调用监听函数\n```javascript\nxhr.onreadystatechange = function(){\n  // 通信成功时，状态值为4\n  if (xhr.readyState === 4){\n    if (xhr.status === 200){\n      console.log(xhr.responseText);\n    } else {\n      console.error(xhr.statusText);\n    }\n  }\n};\n\nxhr.onerror = function (e) {\n  console.error(xhr.statusText);\n};\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".getResponseHeader","suffix":"(header)","desc":"`xhr.getResponseHeader(\"Last-Modified\")` 返回响应头指定信息\n`xhr.getAllResponseHeaders()` 返回响应头全部信息字符串（每个头信息之间使用CRLF分隔（回车+换行），如果没有收到服务器回应，该属性为null。如果发生网络错误，该属性为空字符串。）","url":"","summary":"```\nfunction getHeaderTime() {\n  console.log(this.getResponseHeader(\"Last-Modified\"));\n}\n\nvar xhr = new XMLHttpRequest();\nxhr.open('HEAD', 'yourpage.html');\nxhr.onload = getHeaderTime;\nxhr.send();\n```","reference":"","dot":""}]},{"title":"属性","fold":true,"list":[{"prefix":"xhr","tag":".readyState","suffix":"","desc":"返回一个整数，表示实例对象的当前状态\n+ 0，表示 XMLHttpRequest 实例已经生成，但是实例的open()方法还没有被调用。\n+ 1，表示open()方法已经调用，但是实例的send()方法还没有调用，仍然可以使用实例的setRequestHeader()方法，设定 HTTP 请求的头信息。\n+ 2，表示实例的send()方法已经调用，并且服务器返回的头信息和状态码已经收到。\n+ 3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的responseType属性等于text或者空字符串，responseText属性就会包含已经收到的部分信息。\n+ 4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".response","suffix":"","desc":"表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由XMLHttpRequest.responseType属性决定。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".responseType","suffix":"","desc":"服务器返回数据的类型\n+ \"（空字符串）：等同于text，表示服务器返回文本数据。\n+ \"arraybuffer\"：ArrayBuffer 对象，表示服务器返回二进制数组。\n+ \"blob\"：Blob 对象，表示服务器返回二进制对象。\n+ \"document\"：Document 对象，表示服务器返回一个文档对象。\n+ \"json\"：JSON 对象。\n+ \"text\"：字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".overrideMimeType","suffix":"(type)","desc":"`xhr.overrideMimeType('text/plain')`\n用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型","url":"","summary":"举例来说，服务器返回的数据类型是text/xml，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成text/plain，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。\n\n修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用responseType属性告诉服务器。只有在服务器无法返回某种数据类型时，才使用overrideMimeType()方法。","reference":"","dot":""},{"prefix":"xhr","tag":".responseURL","suffix":"","desc":"发送数据的服务器的网址","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".status","suffix":"","desc":"返回一个整数，表示服务器回应的 HTTP 状态码","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".timeout","suffix":"","desc":"返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".abort()","suffix":"","desc":"终止已经发出的 HTTP 请求。调用这个方法以后，readyState属性变为4，status属性变为0。","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":true,"list":[{"prefix":"xhr","tag":".onloadstart","suffix":"","desc":"loadstart 事件（HTTP 请求发出）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onprogress","suffix":"","desc":"progress事件（正在发送和加载数据）的监听函数","url":"","summary":"progress事件的监听函数有一个事件对象参数，该对象有三个属性：\n+ loaded属性返回已经传输的数据量\n+ total属性返回总的数据量\n+ lengthComputable属性返回一个布尔值，表示加载的进度是否可以计算。","reference":"","dot":""},{"prefix":"xhr","tag":".onabort","suffix":"","desc":"abort 事件（请求中止，比如用户调用了abort()方法）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onerror","suffix":"","desc":"error 事件（请求失败）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onload","suffix":"","desc":"load 事件（请求成功完成）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".onloadend","suffix":"","desc":"loadend 事件（请求完成，不管成功或失败）的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"xhr","tag":".ontimeout","suffix":"","desc":"设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Beacon","barcolor":"","fold":false,"box":[{"title":"beacon","fold":false,"list":[{"prefix":"Navigator","tag":".sendBeacon","suffix":"(url,data)","desc":"第一个参数是目标服务器的 URL，\n第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。\n返回值是一个布尔值，成功发送数据为true，否则为false。\n该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数。","url":"","summary":"","reference":"参考资料|http://www.ruanyifeng.com/blog/2019/04/user-tracking.html","dot":""}]}]},{"title":"XHR封装","barcolor":"","fold":false,"box":[{"title":"axios","fold":false,"list":[{"prefix":"axios","tag":".verb","suffix":"(url,[data],config)","desc":"当使用快捷方法是,url,method,data不需要放置在config中","url":"","summary":"","reference":"github|https://github.com/axios/axios","dot":""},{"prefix":"axios","tag":".create","suffix":"(config)","desc":"按自定义配置定义个实例，会被合并\n```\naxios.create({\n  baseURL: 'https://some-domain.com/api/',\n  timeout: 1000,\n  headers: {'X-Custom-Header': 'foobar'}\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"axios","tag":".all","suffix":"(iterable)","desc":"同时发起多个请求","url":"","summary":"","reference":"","dot":""},{"prefix":"axios","tag":".spread","suffix":"(fn(result,..))","desc":"并在请求都结束后，输出结果","url":"","summary":"```\nvar me = this; \nthis.$axios.all([me.getAllTask(),me.getAllCity()])\n    .then(me.$axios.spread(function(allTask, allCity){\n        console.log('所有请求完成')\n        console.log('请求1结果',allTask)\n        console.log('请求2结果',allCity)\n\n    }))\n```","reference":"参考资料|https://segmentfault.com/a/1190000019882188","dot":""},{"prefix":"","tag":"Request Config","suffix":"","desc":"```javascript\n{\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data, headers) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // `headers` 是即将被发送的自定义请求头\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n\n  // `params` 是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // （快捷方法时无需）`url` 是用于请求的服务器 URL\n  url: '/user',\n\n  // （快捷方法时无需）`method` 是创建请求时使用的方法\n  method: 'get', // default\n\n  // （快捷方法时无需）`data` 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // （通过实例配置设置）`timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n   // `withCredentials` 表示跨域请求时是否需要使用凭证\n  withCredentials: false, // default\n\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n   // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // default\n  \n   // 编码\n  responseEncoding: 'utf8', // default\n\n   // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n   // `onUploadProgress` 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n   // `maxContentLength` 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // default\n\n  // `socketPath` defines a UNIX Socket to be used in node.js.\n  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n  // Only either `socketPath` or `proxy` can be specified.\n  // If both are specified, `socketPath` is used.\n  socketPath: null, // default\n\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` 指定用于取消请求的 cancel token\n  // （查看后面的 Cancellation 这节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Response Schema","suffix":"","desc":"```javascript\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n   // `config` 是为请求提供的配置信息\n  config: {},\n  // 'request'\n  // `request` is the request that generated this response\n  // It is the last ClientRequest instance in node.js (in redirects)\n  // and an XMLHttpRequest instance the browser\n  request: {}\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"axios.defaults.","suffix":"config","desc":"全局默认值设置\n```\naxios.defaults.baseURL = 'https://api.example.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\naxios.defaults.timeout =  10000; //单位毫秒\naxios.defaults.withCredentials = true;\n```","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Fetch API","barcolor":"","fold":false,"box":[{"title":"fetch","fold":false,"list":[{"prefix":"","tag":"fetch","suffix":"(url/req,opt)","desc":"```\n// 获取 some.json 资源\nfetch('some.json')\n  .then(function(response) {\n    return response.json();\n  })\n  .then(function(data) {\n    console.log('data', data);\n  })\n  .catch(function(error) {\n    console.log('Fetch Error: ', error);\n  });\n```","url":"","summary":"","reference":"参考资料|https://aotu.io/notes/2017/04/10/fetch-API/index.html\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch","dot":""},{"prefix":"","tag":"new AbortController()","suffix":"","desc":"```\nvar controller = new AbortController();\nvar signal = controller.signal;\nabortBtn.addEventListener('click', function() {\n  controller.abort();\n  console.log('Download aborted');\n});\n```","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal","dot":""}]},{"title":"Headers","fold":false,"list":[{"prefix":"","tag":"new Headers","suffix":"(obj)","desc":"创建一个新的Headers对象.","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".get","suffix":"(name)","desc":"获取指定key的值\n```\nmyHeaders.append('Accept-Encoding', 'deflate');\nmyHeaders.append('Accept-Encoding', 'gzip');\nmyHeaders.get('Accept-Encoding'); // Returns \"deflate,gzip\"\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".entries|keys|values()","suffix":"","desc":"以 迭代器 的形式返回Headers对象中所有的键值对","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".set","suffix":"(name,val)","desc":"替换现有的header的值, 或者添加一个未存在的header并赋值.","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".append","suffix":"(name,val)","desc":"给现有的header添加一个值, 或者添加一个未存在的header并赋值.","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".delete","suffix":"(name)","desc":"从Headers对象中删除指定header.","url":"","summary":"","reference":"","dot":""},{"prefix":"headers","tag":".has","suffix":"(name)","desc":"以布尔值的形式从Headers对象中返回是否存在指定的header.","url":"","summary":"","reference":"","dot":""}]},{"title":"BODY","fold":false,"list":[{"prefix":"response|request","tag":".body","suffix":"","desc":"一个简单的getter用于暴露一个ReadableStream类型的主体内容。","url":"","summary":"Body被Request 和Response实现，并为这些对象提供了一个相关联的主体（字节流），一个已使用的标志（最初未设置）和一个MIME类型（最初为空字节序列）。","reference":"","dot":""},{"prefix":"body","tag":".bodyUsed ","suffix":"","desc":"一个Boolean 值指示是否body已经被标记读取。","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".arrayBuffer()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是ArrayBuffer。此操作会将bodyUsed状态改为已使用（true）","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".blob()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是Blob。此操作会将bodyUsed状态改为已使用（true）。","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".formData()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是FormData表单。此操作会将bodyUsed状态改为已使用（true）。","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".json()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是使用JSON解析body文本的结果。此操作会将bodyUsed状态改为已使用（true）。","url":"","summary":"","reference":"","dot":""},{"prefix":"body","tag":".text()","suffix":"","desc":"使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是USVString（文本）。此操作会将bodyUsed状态改为已使用（true）。","url":"","summary":"","reference":"","dot":""}]},{"title":"Request","fold":false,"list":[{"prefix":"","tag":"new Request","suffix":"(input,opt)","desc":"+ method: 请求的方法，例如：GET, POST。\n+ headers: 任何你想加到请求中的头，其被放在Headers对象或内部值为ByteString 的对象字面量中。\n+ body: 任何你想加到请求中的body，可以是Blob, BufferSource, FormData, URLSearchParams, 或 USVString对象。注意GET 和 HEAD请求没有body。\n+ mode: 请求的模式, 比如 cors, no-cors, same-origin, 或 navigate。默认值应该为 cors。但在Chrome中，Chrome 47 之前的版本默认值为 no-cors ，自Chrome 47起，默认值为same-origin。\n+ credentials: 想要在请求中使用的credentials：: omit, same-origin, 或 include。默认值应该为omit。但在Chrome中，Chrome 47 之前的版本默认值为 same-origin ，自Chrome 47起，默认值为include。\n+ cache: 请求中想要使用的cache mode \n+ redirect: 对重定向处理的模式： follow, error, or manual。在Chrome中，Chrome 47 之前的版本默认值为 manual ，自Chrome 47起，默认值为follow。\n+ referrer: 一个指定了no-referrer, client, 或一个 URL的 USVString 。默认值是client.\n+ integrity: 包括请求的 subresource integrity 值 (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".method","suffix":"","desc":"包含请求的方法 (GET, POST, 等.)","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".url","suffix":"","desc":"包含这个请求的URL","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".headers ","suffix":"","desc":"包含请求相关的Headers对象","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".mode","suffix":"","desc":"包含请求的模式 (例如： cors, no-cors, same-origin, navigate).","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".credentials ","suffix":"","desc":"包含请求的证书(例如： omit, same-origin).","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".cache","suffix":"","desc":"包含请求的缓存模式 (例如： default, reload, no-cache).","url":"","summary":"","reference":"","dot":""},{"prefix":"request","tag":".clone()","suffix":"","desc":"创建一个当前Request 对象的副本","url":"","summary":"","reference":"","dot":""}]},{"title":"Response","fold":false,"list":[{"prefix":"","tag":"new Response","suffix":"(body,opt)","desc":"创建一个 Response 对象","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".headers","suffix":"","desc":"包含此 Response 所关联的 Headers 对象","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".ok","suffix":"","desc":"包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".redirected ","suffix":"","desc":"表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".status","suffix":"","desc":"包含 Response 的状态码 （例如 200 表示成功）","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".statusText","suffix":"","desc":"包含了与该 Response 状态码一致的状态信息（例如，OK对应 200）","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".type ","suffix":"","desc":"包含 Response 的类型（例如，basic、cors）。","url":"","summary":"","reference":"","dot":""},{"prefix":"response","tag":".url ","suffix":"","desc":"包含 Response 的URL。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Web Worker","barcolor":"","fold":false,"box":[{"title":"主线程","fold":false,"list":[{"prefix":"","tag":"new Worker","suffix":"(path.js,[opt])","desc":"新建一个 Worker 线程,必须同源\n也可以是一个blob url","url":"","summary":"通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。\n```\n<script id=\"worker\" type=\"app/worker\">\n  addEventListener('message', function () {\n    postMessage('some message');\n  }, false);\n</script>\n```\n上面是一段嵌入网页的脚本，注意必须指定<script>标签的type属性是一个浏览器不认识的值，上例是app/worker。\n然后，读取这一段嵌入页面的脚本，用 Worker 来处理。\n```\nvar blob = new Blob([document.querySelector('#worker').textContent]);\nvar url = window.URL.createObjectURL(blob);\nvar worker = new Worker(url);\n\nworker.onmessage = function (e) {\n  // e.data === 'some message'\n};\n```","reference":"","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(data)","desc":"参数可以是各种数据类型，包括二进制数据。\n这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(buf,[buf])","desc":"快速转移arrayBuffer数据，主线程将失去控制权，非拷贝方式。\n```\nvar a = new ArrayBuffer(1);\nworker.postMessage(a, [a]);\nvar b = new Uint8Array(1);\nworker.postMessage({x:y,b:b.buffer}, [b.buffer])\n```","url":"","summary":"拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。","reference":"","dot":""},{"prefix":"worker","tag":".onmessage","suffix":"","desc":"主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息\ne.data 获取数据","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".terminate()","suffix":"","desc":"关闭worker线程","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".onerror","suffix":"","desc":"线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件\nWorker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"Worker线程","fold":false,"list":[{"prefix":"","tag":"self","suffix":"","desc":"代表子线程自身，即子线程的全局对象\n无法使用document、window、parent这些对象,但是，Worker 线程可以使用navigator对象和location对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".postMessage","suffix":"(data)","desc":"向产生这个 Worker 线程发送消息","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".onmessage","suffix":"","desc":"根据主线程发来的数据，Worker 线程可以调用不同的方法","url":"","summary":"```\nself.addEventListener('message', function (e) {\n  var data = e.data;\n  switch (data.cmd) {\n    case 'start':\n      self.postMessage('WORKER STARTED: ' + data.msg);\n      break;\n    case 'stop':\n      self.postMessage('WORKER STOPPED: ' + data.msg);\n      self.close(); // Terminates the worker.\n      break;\n    default:\n      self.postMessage('Unknown command: ' + data.msg);\n  };\n}, false);\n```","reference":"","dot":""},{"prefix":"","tag":"importScripts","suffix":"(mod.js,..)","desc":"加载其他脚本","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".close()","suffix":"","desc":"在 Worker 内部关闭自身","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Perfomance","barcolor":"","fold":false,"box":[{"title":"重排回调","fold":false,"list":[{"prefix":"window","tag":".requestAnimationFrame","suffix":"(fn)","desc":"在下次重绘之前调用指定的回调函数更新动画。\n该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n返回一个ID","url":"","summary":"window.requestAnimationFrame()方法跟setTimeout类似，都是推迟某个函数的执行。不同之处在于，setTimeout必须指定推迟的时间，window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，requestAnimationFrame()会暂停执行。","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame","dot":""},{"prefix":"window","tag":".cancelAnimationFrame","suffix":"(id)","desc":"取消回调函数的执行","url":"","summary":"","reference":"MDN参考|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame","dot":""}]},{"title":"空闲回调","fold":false,"list":[{"prefix":"window","tag":".requestIdleCallback","suffix":"(fn,deadline)","desc":"将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行\n`requestIdleCallback(callback, { timeout: 2000 });` 设定最大死线","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".cancelIdleCallback","suffix":"(id)","desc":"取消回调函数","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"IntersectionObserver","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"Touch","barcolor":"","fold":false,"box":[]}]}]}