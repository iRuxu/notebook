{"version":1584764487902,"name":"git","data":[{"column":[{"title":"Nodejs","barcolor":"","fold":false,"box":[{"title":"nvm","fold":false,"list":[{"prefix":"nvm ","tag":"install","suffix":"","desc":"安装 `nvm install <node_version>`\n`nvm uninstall <version>`: 卸载指定版本的 Node.js。","url":"","summary":"","reference":"","dot":""},{"prefix":"nvm ","tag":"list","suffix":"","desc":"所有安装的版本","url":"","summary":"","reference":"","dot":""},{"prefix":"nvm ","tag":"alias default ","suffix":"<version>","desc":"`nvm alias default <version>`将某个版本设置为默认版本\n`nvm use <node_version>` 在当前终端会话中切换到指定版本的Node.js\n`nvm alias <name> <version>`: 为特定版本创建别名。","url":"","summary":"","reference":"","dot":""},{"prefix":"nvm ","tag":"which","suffix":"","desc":"nvm which 12.18.3\n输出各自Node版本的完整路径","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"nvm","suffix":"","desc":"# Ubuntu\n+ 运行权限 `chmod +x install_nvm.sh`  \n+ 执行脚本 `./install_nvm.sh`\n+ 激活\n```\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"\n[ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\"\n```","url":"","summary":"# Mac\n下载 `curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash`\n激活 `source ~/.bashrc` 和 `source ~/.zshrc`\n","reference":"","dot":""},{"prefix":"","tag":"ubuntu","suffix":"","desc":"sudo apt update\nsudo apt remove nodejs npm\nsudo apt remove libnode72  //冲突\n\ncurl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\nsudo apt install nodejs\n","url":"","summary":"","reference":"","dot":""}]},{"title":"pm2","fold":false,"list":[{"prefix":"pm2 ","tag":"start","suffix":"","desc":"+ pm2 start <cmd|executable_file> 启动命令或可执行文件\n```\npm2 start --name \"test\" npm -- run ssr\npm2 start --name \"test\" ./my_script.sh\n```\n\n+ pm2 start <interpreter> <your_script_file> 使用指定解析器解析文件进行启动\n```\n# 指定node版本启动\npm2 start --name=node12 --interpreter=\"/home/user/.nvm/versions/node/v12.18.3/bin/node app.js \n# 启动python项目\npm2 start --name=pyservice  --interpreter python main.py\n```\n","url":"","summary":"`pm2 start [options] <app_name|script> [-- <args>]`\n\n# 名称\n--name: 为启动的进程指定一个名称。\npm2 start --name \"test\" npm -- run ssr\npm2 start --name=test npm -- run ssr\n如果值中不包含空格或特殊字符，两种方式都可以使用，且不强制要求引号。\n如果值中包含空格或特殊字符，推荐使用引号将值括起来，无论是使用空格还是等号连接参数和值。\n\n# 解析器\n--interpreter: 指定解释器来解释你的脚本，比如 Node.js、Python 等。\n`--interpreter=路径`或`--interpreter $cmd`\n\n# 环境\n--env: 参数用于设置环境变量，可以为正在启动的进程指定特定的环境变量。环境变量是在应用程序运行时可用的键值对，通常用于配置应用程序的行为。你可以根据需要设置多个环境变量，以空格分隔。\n```\npm2 start your_script.js --env NODE_ENV=production PORT=3000\n```\n-- arg1 arg2 arg3 传递参数给脚本或命令\n\n# 负载\n启动 PM2 的集群模式可以使用 -i 或 --instances 参数来指定要启动的进程实例数量\n```\npm2 start your_script.js -i 4\npm2 start your_script.js --instances 4\n```\n--max-memory-restart: 指定进程的最大内存使用量，当内存使用超过该阈值时，进程将被重启。\n\n# 日志\n--log <log_path> 指定日志路径\n--time 日志打印时间\n`pm2 start your_script.js --name \"myApp\" --log /path/to/myapp.log --time`","reference":"官方文档|https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/","dot":""},{"prefix":"pm2 ","tag":"dev","suffix":"","desc":"```pm2 start your_script.js --watch```\n--watch: 监视文件的变化，并在文件发生变化时自动重启进程。\n```pm2 dev your_script.js```\n用于开发环境的快捷方式\n\n指定忽略的文件\n```pm2 dev --ignore node_modules,logs,your_other_dir your_script.js```\n","url":"","summary":"","reference":"","dot":""},{"prefix":"pm2 ","tag":"list","suffix":"","desc":"`pm2 list`: 列出所有由PM2管理的应用。\n`pm2 stop <app_name>/<id>/all`: 停止应用。\n`pm2 delete <app_name>/<id>/all`: 删除应用。","url":"","summary":"","reference":"","dot":""},{"prefix":"pm2 ","tag":"reload","suffix":"","desc":"pm2 reload 无宕机重启（zero-downtime restarts）\npm2 restart 重启服务","url":"","summary":"","reference":"","dot":""},{"prefix":"pm2 ","tag":"startup","suffix":"","desc":"`pm2 save` 保存应用列表\n`pm2 startup` 开启启动\n`pm2 resurrect` 重新加载保存的应用列表和配置。","url":"","summary":"","reference":"","dot":""},{"prefix":"pm2 ","tag":"logs","suffix":"","desc":"`pm2 logs <app_name>/<id>`: 查看应用日志。\n`pm2 flush`：清空所有日志","url":"","summary":"","reference":"","dot":""},{"prefix":"pm2 ","tag":"monit","suffix":"","desc":"`pm2 monit`：监控每个节点的CPU和内存使用情况\n`pm2 dashboard`：一个终端仪表盘，显示关键的实时指标。","url":"","summary":"","reference":"","dot":""},{"prefix":"pm2 ","tag":"report","suffix":"","desc":"ping: 检查PM2 daemon是否运行。\nkill: 停止所有PM2进程。\nreport: 生成PM2状态报告，用于故障排查。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"windows","suffix":"","desc":"1.下载 https://github.com/jessety/pm2-installer\n2.配置（终端以管理员运行，更新版本则全部需要重新跑一次）\n```\nnpm run configure\nnpm run configure-policy\nnpm run setup\n```\n3.服务-PM2-属性-登录选项设为本地系统账号","url":"","summary":"","reference":"参考资料|https://blog.cloudboost.io/nodejs-pm2-startup-on-windows-db0906328d75\n权限问题|https://github.com/jessety/pm2-installer/issues/69","dot":""}]}]}]},{"column":[{"title":"Buffer","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"Buffer","tag":".from","suffix":"(str,encoding)","desc":"Buffer 实例也是 Uint8Array 实例，长度1为1个字节（8位）\n它可以接受多种不同类型的输入作为参数，包括字符串、数组、Buffer对象等\n","url":"","summary":"+ Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）\n+ Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n+ Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例\n+ Buffer.from(object[, offsetOrEncoding[, length]]) 对于对象的valueOf()返回值\n+ Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例\n+ Buffer.from(path)：从文件内容返回","reference":"","dot":""},{"prefix":"Buffer","tag":".alloc","suffix":"(size,[fill])","desc":"`Buffer.alloc(size[, fill[, encoding]])`： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0\n`Buffer.allocUnsafe(size)`： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据","url":"","summary":"```\nconst buf = Buffer.alloc(5);\n//<Buffer 00 00 00 00 00>\n\nconst buf = Buffer.alloc(5, 'a');\n//<Buffer 61 61 61 61 61>\n```","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"buf","tag":"[i]","suffix":"","desc":"获取或设置指定索引位置的字节，用于按索引访问和修改数据。\n返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".length","suffix":"","desc":"返回 Buffer 对象所占据的内存长度。(字节数）\n`Buffer.byteLength(buf)`","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".toString","suffix":"([encoding])","desc":"解码缓冲区数据并使用指定的编码返回字符串。\n`buf.toString([encoding[, start[, end]]])`\nencoding - 使用的编码。默认为 'utf8' 。\nstart - 指定开始读取的索引位置，默认为 0。\nend - 结束位置，默认为缓冲区的末尾。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"buf.indexOf","suffix":"(val)","desc":"在 Buffer 中查找值（字符串、Buffer、或数字）的位置。用于搜索数据。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"<encoding>","suffix":"","desc":"# nodejs默认内置字符编码\n+ ascii \n仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n+ utf-8\n多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n+ hex \n将每个字节编码为两个十六进制字符（1字节=8位=2个4位,2^4=16）\n+ base64\nMIME编码的一种\n+ latin1/binary \n一种把 Buffer 编码成一字节编码的字符串的方式,ISO-8859-1的别名\n+ utf16le/ucs2 \n2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。","url":"","summary":"# ascii\n作用：表语英语及西欧语言。\n位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。\n范围：ASCII从00到7F，扩展从00到FF\n# iso8859-1\n作用：扩展ASCII，表示西欧、希腊语等。\n位数：8位\n范围：从00到FF，兼容ASCII字符集\n# GB2312字符集\n作用：国家简体中文字符集，兼容ASCII。\n位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。\n范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码。\n# GBK字符集\n作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。\n位数：使用2个字节表示，可表示21886个字符。\n范围：高字节从81到FE，低字节从40到FE。\n# BIG5字符集\n作用：它解决了中文、日文、朝鲜语等的编码，兼容GBK。\n位数：它采用变字节表示(1 ASCII，2，4字节)。可表示27484个文字。\n范围：1字节从00到7F; 2字节高字节从81到FE，低字节从40到7E和80到FE；4字节第一三字节从81到FE，第二四字节从30到39。\n# UTF-8/UTF-32/UTF-16/UTF-7\n作用：为世界650种语言进行统一编码，兼容ISO-8859-1。\n位数：UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16和UTF-32。","reference":"参考资料1|https://www.cnblogs.com/happyday56/p/4135845.html\n参考资料2|https://dailc.github.io/2017/06/03/utf8ToUtf16ToGbk.html","dot":""},{"prefix":"","tag":"iconv-lite","suffix":"","desc":"包括gbk在内的更多编码支持\n```javascript\nvar iconv = require('iconv-lite');\n \n// Convert from an encoded buffer to js string.\nstr = iconv.decode(Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]), 'win1251');\n \n// Convert from js string to an encoded buffer.\nbuf = iconv.encode(\"Sample input string\", 'win1251');\n \n// Check if encoding is supported\niconv.encodingExists(\"us-ascii\")\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/iconv-lite","dot":""}]},{"title":"操作","fold":false,"list":[{"prefix":"buf","tag":".fill","suffix":"(val)","desc":"`buf.fill(value[, offset[, end]][, encoding])`\n使用指定的值填充 Buffer。用于初始化或重置 Buffer 数据。\n如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".write","suffix":"(str)","desc":"`buf.write(string[, offset[, length]][, encoding])`\n向 Buffer 写入字符串。用于将字符串数据编码存储到 Buffer。\n返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\nstring - 写入缓冲区的字符串。\noffset - 缓冲区开始写入的索引值，默认为 0 。\nlength - 写入的字节数，默认为 buffer.length\nencoding - 使用的编码。默认为 'utf8' 。","url":"","summary":"buf.writeBigInt64BE(value[, offset])\nbuf.writeBigInt64LE(value[, offset])\nbuf.writeBigUInt64BE(value[, offset])\nbuf.writeBigUInt64LE(value[, offset])\nbuf.writeDoubleBE(value[, offset])\nbuf.writeDoubleLE(value[, offset])\nbuf.writeFloatBE(value[, offset])\nbuf.writeFloatLE(value[, offset])\nbuf.writeInt8(value[, offset])\nbuf.writeInt16BE(value[, offset])\nbuf.writeInt16LE(value[, offset])\nbuf.writeInt32BE(value[, offset])\nbuf.writeInt32LE(value[, offset])\nbuf.writeIntBE(value, offset, byteLength)\nbuf.writeIntLE(value, offset, byteLength)\nbuf.writeUInt8(value[, offset])\nbuf.writeUInt16BE(value[, offset])\nbuf.writeUInt16LE(value[, offset])\nbuf.writeUInt32BE(value[, offset])\nbuf.writeUInt32LE(value[, offset])\nbuf.writeUIntBE(value, offset, byteLength)\nbuf.writeUIntLE(value, offset, byteLength)","reference":"","dot":""},{"prefix":"buf1","tag":".copy","suffix":"(buf2)","desc":"`buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])`\n缓冲区拷贝,没有返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".compare","suffix":"(buf2)","desc":"比较两个buffer，返回一个数字，表示 buf 在 otherBuffer 之前(<0)，之后或相同\n`buf.equals(otherBuffer)` 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".slice","suffix":"(start,[end])","desc":"`buf.slice([start[, end]])`\n返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。","url":"","summary":"","reference":"","dot":""},{"prefix":"Buffer","tag":".concat","suffix":"([buf1,buf2,..])","desc":"缓冲区合并,返回一个多个成员合并的新 Buffer 对象。\n`Buffer.concat(list[, totalLength])`\nlist - 用于合并的 Buffer 对象数组列表。\ntotalLength - 指定合并后Buffer对象的总长度。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":false,"list":[{"prefix":"Buffer","tag":".isEncoding","suffix":"(encoding)","desc":"检查指定的字符串编码是否受支持或有效","url":"","summary":"","reference":"","dot":""},{"prefix":"Buffer","tag":".isBuffer","suffix":"(obj)","desc":"判断对象是否是 Buffer。用于类型检查。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"events","barcolor":"","fold":false,"box":[{"title":"创建实例","fold":false,"list":[{"prefix":"","tag":"new events.EventEmitter()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"添加监听","fold":false,"list":[{"prefix":"emitter","tag":".addListener","suffix":"(evt,fn)","desc":"为指定事件添加一个监听器到监听器数组的尾部。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".on","suffix":"(evt,fn)","desc":"为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数\n不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 与 listener 会导致 listener 会被添加多次。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependListener","suffix":"(evt,fn)","desc":"添加 listener 函数到名为 eventName 的事件的监听器数组的开头。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".once","suffix":"(evt,fn)","desc":"为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependOnceListener","suffix":"(evt,fn)","desc":"添加单次监听器 listener 到名为 eventName 的事件的监听器数组的开头。 \n当 eventName 事件下次触发时，监听器会先被移除，然后再调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"newListener","suffix":",fn)","desc":"实例在新的监听器被添加到其内部监听器数组之前，会触发自身的 'newListener' 事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"移除监听","fold":false,"list":[{"prefix":"emitter","tag":".removeListener","suffix":"(evt,fn)","desc":"移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。\n最多只会从监听器数组中移除一个监听器。 如果监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener() 才能移除所有实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".off","suffix":"(evt,fn)","desc":"emitter.removeListener() 的别名。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".removeAllListeners","suffix":"([evt])","desc":"移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"removeListener","suffix":",fn)","desc":"'removeListener' 事件在 listener 被移除后触发。","url":"","summary":"","reference":"","dot":""}]},{"title":"触发事件","fold":false,"list":[{"prefix":"emitter","tag":".emit","suffix":"(evt,args..)","desc":"按监听器的顺序执行执行每个监听器\n如果事件有注册监听返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"error","suffix":",fn)","desc":"我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"emitter","tag":".eventNames()","suffix":"","desc":"返回已注册监听器的事件名数组。 数组中的值为字符串或 Symbol。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listeners","suffix":"(evt)","desc":"返回指定事件的监听器数组。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listenerCount","suffix":"(evt)","desc":"返回正在监听的名为 eventName 的事件的监听器的数量。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".setMaxListeners","suffix":"(n)","desc":"默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 \nsetMaxListeners 函数用于提高监听器的默认限制的数量。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Stream","barcolor":"","fold":false,"box":[{"title":"Readable","fold":false,"list":[{"prefix":"new ","tag":"Readable","suffix":"([options])","desc":"```js\nconst { Readable } = require('stream');\nconst data = ['apple', 'banana', 'cherry'];\n\nconst customReadableStream = new Readable({\n  highWaterMark: 1024,   // 设置缓冲区大小为1KB\n  encoding: 'utf8',      // 读取字符串数据\n  objectMode: false,     // 不启用对象模式\n  read(size) {\n    // 从数据源中读取数据并推送到流中\n    const nextItem = data.shift();\n    if (nextItem) {\n      this.push(nextItem);\n    } else {\n      this.push(null); // 没有更多数据，结束流\n    }\n  }\n});\n```","url":"","summary":"highWaterMark（可选）：这是一个用于配置内部缓冲区的选项，指定可读流的缓冲区大小（以字节为单位）。当可读流的缓冲区中的数据超过这个大小时，就会暂停从数据源读取数据。默认值取决于系统的内存限制。\n\nencoding（可选）：如果你希望从可读流中读取字符串而不是原始缓冲区数据，则可以设置此选项以指定字符编码，例如'utf8'。如果省略此选项，则会以原始缓冲区的形式读取数据。\n\nobjectMode（可选）：如果你希望从可读流中读取对象而不是字节流数据，则可以将此选项设置为true。这在某些情况下很有用，例如处理JSON数据流。\n\nread（可选）：一个可选的回调函数，用于自定义数据的读取逻辑。该回调会在可读流需要更多数据时被调用，可以在其中手动推送数据到流中。","reference":"官方文档|https://nodejs.org/docs/latest/api/stream.html#new-streamreadableoptions","dot":""},{"prefix":"rs","tag":".push","suffix":"(chunk)","desc":"+ chunk <缓冲区> | <Uint8Array> | <字符串> | <空> | <any>要推入读取队列的数据块。对于不以对象模式运行的流，chunk必须是字符串Buffer或Uint8Array.对于对象模式流，chunk可以是任何 JavaScript 值。\n+ encoding <string>字符串块的编码。必须是有效的 Buffer编码，例如'utf8'或'ascii'。\n+ 返回：<boolean> true是否可以继续推送额外的数据块；false否则。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".on('data',","suffix":"fn(chunk))","desc":"表示流有新的数据块可供读取","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".on('end')","suffix":"","desc":"表示流已经结束，没有更多数据可供读取。\n\n+ 'close' 事件表示流的底层资源已经被关闭，不再可用，与底层资源的生命周期相关。\n+ 'end' 事件表示流的数据已经正常结束，但流仍然可用，可以继续操作，与数据的读取或写入结束相关。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".on('error',","suffix":"fn(err))","desc":"'error' 事件会在可读流或可写流发生错误时触发。出现 'error' 事件不会自动中断流的读取或写入，但通常你应该在 'error' 事件的处理程序中采取适当的措施来处理错误情况。\n\n```js\nreadableStream.on('error', (error) => {\n  console.error('An error occurred:', error.message);\n  // 中断流的读取\n  readableStream.destroy();\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".pause()","suffix":"","desc":"暂停流的数据流动。\n会触发pause事件","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".resume()","suffix":"","desc":"恢复流的数据流动。\n会触发'resume'事件","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Readable.from","suffix":"(iterable[, options])","desc":"用于从可迭代对象生成可读流，通常用于将数组、生成器等转换为可读流。","url":"","summary":"","reference":"","dot":""}]},{"title":"Writable","fold":false,"list":[{"prefix":"new ","tag":"Writable","suffix":"([options])","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".write","suffix":"(chunk)","desc":"写入数据到可写流。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".cork/uncork","suffix":"()","desc":"缓冲/取消缓冲写入操作","url":"","summary":"writable.cork() 和 writable.uncork() 是用于控制写入操作的缓冲的方法，通常在写入大量数据时，以提高性能和效率。\n\nwritable.cork(): 当你调用 writable.cork() 时，它会告诉可写流将所有的写入操作缓冲起来，而不立即执行它们。这意味着写入的数据将被积累在内部缓冲区中，不会立即写入底层资源（例如文件或网络连接）。\n\nwritable.uncork(): 当你调用 writable.uncork() 时，它会告诉可写流可以开始执行之前缓冲的写入操作。这样可以一次性地将多个写入操作刷新到底层资源，减少了频繁的系统调用，提高了性能。\n\n这对于在写入大量数据时降低资源消耗和提高效率非常有用，因为可以减少系统调用的次数。一旦你调用了 writable.cork()，你可以在需要时多次调用 write() 方法，数据会被缓冲，然后再调用 writable.uncork() 以刷新数据到底层资源。\n\n```\nconst fs = require('fs');\n\nconst writableStream = fs.createWriteStream('output.txt');\n\nwritableStream.cork(); // 开始缓冲写入操作\n\nwritableStream.write('Data 1');\nwritableStream.write('Data 2');\nwritableStream.write('Data 3');\n\nwritableStream.uncork(); // 刷新缓冲的写入操作\n\n```","reference":"","dot":""},{"prefix":"ws","tag":".end()","suffix":"","desc":"writable.end([chunk[, encoding]][, callback])：结束可写流，可选地写入最后一个数据块。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".on('drain')","suffix":"","desc":"表示可写流已经排空，可以继续写入数据。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".on('finish')","suffix":"","desc":"finish 表示可写流已经完成所有写入操作。\nclose 表示可写流已经关闭。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".on('error'","suffix":",fn(err))","desc":"表示可写流发生错误。","url":"","summary":"","reference":"","dot":""}]},{"title":"Duplex","fold":false,"list":[{"prefix":"new ","tag":"Duplex","suffix":"(options)","desc":"双工流（Duplex Stream）可以使用所有可读流（Readable Stream）和可写流（Writable Stream）的方法，因为双工流是双向的，同时具备可读性和可写性。这意味着你可以像操作可读流或可写流一样操作双工流，包括读取数据、写入数据、暂停和恢复流动等。","url":"","summary":"```\nclass MyDuplexStream extends Duplex {\n  constructor() {\n    super();\n  }\n\n  _read(size) {\n    // 读取逻辑\n    const data = ... // 从某处获取数据\n    this.push(data);\n  }\n\n  _write(chunk, encoding, callback) {\n    // 写入逻辑\n    // 处理 chunk 数据\n    callback();\n  }\n}\n```\n\n先写后读\n```\nconst { Duplex } = require('stream');\n\nclass MyDuplexStream extends Duplex {\n  constructor() {\n    super();\n    this.dataQueue = []; // 存储数据的队列\n  }\n\n  // 实现读取数据的逻辑\n  _read(size) {\n    if (this.dataQueue.length > 0) {\n      const data = this.dataQueue.shift(); // 从队列中取出数据\n      this.push(data); // 推送数据给消费者\n    } else {\n      this.push(null); // 没有更多数据时，推送 null 表示结束\n    }\n  }\n\n  // 实现写入数据的逻辑\n  _write(chunk, encoding, callback) {\n    const data = chunk.toString();\n    this.dataQueue.push(data); // 将数据加入队列\n    callback(); // 调用 callback 表示写入完成\n  }\n}\n\n// 创建自定义双工流实例\nconst duplexStream = new MyDuplexStream();\n\n// 将数据写入双工流\nduplexStream.write('Data 1');\nduplexStream.write('Data 2');\nduplexStream.end();\n\n// 从双工流读取数据\nduplexStream.on('data', (chunk) => {\n  console.log('Received data:', chunk.toString());\n});\n\n// 在 'end' 事件中处理流的结束\nduplexStream.on('end', () => {\n  console.log('End of data.');\n});\n```","reference":"","dot":""},{"prefix":"ds","tag":"._read","suffix":"(size)","desc":"一个整数，表示要读取的字节数的建议值。这个参数通常用于优化数据的读取操作，你可以根据需要使用它。","url":"","summary":"```\n  _read(size) {\n    // 读取逻辑\n    const data = ... // 从某处获取数据\n    this.push(data);\n  }\n```","reference":"","dot":""},{"prefix":"ds","tag":"._write","suffix":"(chunk,ec,fn)","desc":"chunk：表示要写入的数据块。这通常是一个缓冲区（Buffer）或字符串。\nencoding：表示数据块的编码方式，通常是字符串。这是一个可选参数。\ncallback：一个回调函数，当写入操作完成时，你需要调用这个回调函数来通知可写流。通常，你在 _write 方法中执行写入操作后，调用 callback 来表示写入完成。","url":"","summary":"","reference":"","dot":""},{"prefix":"s","tag":".destroy","suffix":"([error])","desc":"销毁可写流，结束流的生命周期。","url":"","summary":"","reference":"","dot":""}]},{"title":"Transform","fold":false,"list":[{"prefix":"new ","tag":"Transform","suffix":"([options])","desc":"转换流（Transform Stream）是 Node.js 中的一种流类型，它是双工流（Duplex Stream）的一种特例，主要用于对数据进行转换、处理或过滤。转换流可以同时充当可读流和可写流，它接受数据，进行某种转换，然后将转换后的数据输出。","url":"","summary":"```\nconst { Transform } = require('stream');\n\nclass MyTransformStream extends Transform {\n  constructor() {\n    super();\n  }\n\n  _transform(chunk, encoding, callback) {\n    // 实现数据的转换逻辑\n    const transformedData = chunk.toString().toUpperCase();\n    this.push(transformedData);\n    callback();\n  }\n}\n\n// 使用转换流\nconst transformStream = new MyTransformStream();\n\n// 将数据传入转换流\ntransformStream.write('Hello, ');\ntransformStream.write('World');\ntransformStream.end();\n\n// 从转换流读取转换后的数据\ntransformStream.on('data', (chunk) => {\n  console.log(chunk.toString()); // 输出：HELLO, WORLD\n});\n\n```","reference":"","dot":""},{"prefix":"ts","tag":"._flush","suffix":"(fn) / end","desc":"并触发end事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ts","tag":"._transform","suffix":"(chunk,ec,fn) / finish","desc":"并触发finish事件","url":"","summary":"","reference":"","dot":""},{"prefix":"new ","tag":"PassThrough()","suffix":"","desc":"不做任何数据转换或处理，只是将从其可读端读取的数据原样传递到其可写端。换句话说，它将数据从一个流传递到另一个流，而不做任何修改。","url":"","summary":"```\nconst { PassThrough } = require('stream');\n\n// 创建一个 PassThrough 流\nconst passthroughStream = new PassThrough();\n\n// 创建一个可读流\nconst readableStream = createReadableStreamSomehow();\n\n// 创建一个可写流\nconst writableStream = createWritableStreamSomehow();\n\n// 将 PassThrough 流插入数据流管道\nreadableStream.pipe(passthroughStream).pipe(writableStream);\n\n// 监听数据事件\npassthroughStream.on('data', (chunk) => {\n  console.log('Received data:', chunk.toString());\n});\n\n```","reference":"","dot":""}]},{"title":"pipe","fold":false,"list":[{"prefix":"rs","tag":".pipe","suffix":"(ws,[{end:false}])","desc":"将一个可读流的数据传递到一个可写流的方法。它用于建立数据传输管道，将源流的数据流向目标流，通常用于简单的数据传递操作。\n\n绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。 数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。\n**返回:目标流的引用**\n默认情况下，当来源可读流触发 'end' 事件时，目标可写流也会调用 stream.end() 结束写入。 若要禁用这种默认行为， end 选项应设为 false，这样目标流就会保持打开\n```\nreader.pipe(writer, { end: false });\nreader.on('end', () => {\n  writer.end('结束');\n});\n```\n如果可读流在处理期间发送错误，则可写流目标不会自动关闭。 如果发生错误，则需要手动关闭每个流以防止内存泄漏。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".on('pipe',","suffix":"fn(src))","desc":"'pipe'：表示可读流通过 pipe() 方法将数据写入该可写流。\n'unpipe'：表示可读流通过 unpipe() 方法停止将数据写入该可写流。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".unpipe","suffix":"([ws])","desc":"解绑之前使用 stream.pipe() 方法绑定的可写流\n如果没有指定 destination, 则解绑所有管道\n如果指定了 destination, 但它没有建立管道，则不起作用","url":"","summary":"```\nconst { createReadStream, createWriteStream } = require('fs');\n\nconst readableStream = createReadStream('input.txt');\nconst writableStream = createWriteStream('output.txt');\n\n// 将可读流连接到可写流\nreadableStream.pipe(writableStream);\n\n// 在某个条件下取消管道连接\nif (condition) {\n  readableStream.unpipe(writableStream);\n  console.log('Pipeline canceled.');\n}\n\n```","reference":"","dot":""},{"prefix":"ws","tag":".on('unpipe'","suffix":",fn)","desc":"在可读流上调用 stream.unpipe() 方法时会发出 'unpipe'事件，从其目标集中移除此可写流。\n当可读流通过管道流向可写流发生错误时，也会触发此事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"pipeline","fold":false,"list":[{"prefix":"","tag":"pipeline","suffix":"(source, ...transforms, destination, callback)","desc":"`stream.pipeline(source[, ...transforms], destination, callback)`连接单个源流、转换流和目标流。\n这种用法适用于构建包含源流、中间转换流和目标流的数据处理管道。每个参数的作用如下：\n\n+ source：源流，通常是一个可读流。\n+ transforms：一个或多个中间转换流，用于数据处理和转换。\n+ destination：目标流，通常是一个可写流。\n+ callback：在数据处理完成或出现错误时执行的回调函数。\n使用此方法，stream.pipeline 会自动连接这些流，确保数据从源流经过中间流最终流向目标流，并在完成时调用回调函数。这种方式适用于构建复杂的数据处理管道。","url":"","summary":"```js\nconst { pipeline } = require('node:stream');\nconst fs = require('node:fs');\nconst zlib = require('node:zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n); \n```","reference":"","dot":""},{"prefix":"","tag":"pipeline","suffix":"([arr_streams],fn(err))","desc":"pipeline 方法在连接多个流并传递数据时不会触发 pipe 事件","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"path","barcolor":"","fold":false,"box":[{"title":"全局变量","fold":false,"list":[{"prefix":"","tag":"__filename","suffix":"","desc":"指向当前运行的脚本文件名","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__dirname","suffix":"","desc":"指向当前运行的脚本所在的目录","url":"","summary":"","reference":"","dot":""}]},{"title":"生成","fold":false,"list":[{"prefix":"path","tag":".resolve","suffix":"([...paths])","desc":"将路径或路径片段的序列解析为绝对路径","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".join","suffix":"([...paths])","desc":"使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。","url":"","summary":"零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 '.'，表示当前工作目录","reference":"","dot":""},{"prefix":"path","tag":".normalize","suffix":"(path)","desc":"规范化给定的 path","url":"","summary":"","reference":"","dot":""}]},{"title":"分析","fold":false,"list":[{"prefix":"path","tag":".parse","suffix":"(path)","desc":"返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略，\n```\npath.parse('/home/user/dir/file.txt');\n// 返回:\n// { root: '/',\n//   dir: '/home/user/dir',\n//   base: 'file.txt',\n//   ext: '.txt',\n//   name: 'file' \n```","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".format","suffix":"(obj)","desc":"从对象返回路径字符串,path逆方法\ndir和root只需一个\nbase和name+ext只需一个","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/path.html#path_path_format_pathobject","dot":""},{"prefix":"path","tag":".isAbsolute","suffix":"(path)","desc":"检测 path 是否为绝对路径。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".relative","suffix":"(from, to)","desc":"根据当前工作目录返回 from 到 to 的相对路径。 ","url":"","summary":"","reference":"","dot":""}]},{"title":"信息","fold":false,"list":[{"prefix":"path","tag":".dirname","suffix":"(path)","desc":"返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略\n```\npath.dirname('/foo/bar/baz/asdf/quux');\n// 返回: '/foo/bar/baz/asdf'\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".basename","suffix":"(path,[ext])","desc":"返回 path 的最后一部分，类似于 Unix 的 basename 命令。\n尾部的目录分隔符将被忽略\n```javascript\npath.basename('/foo/bar/baz/asdf/quux.html');\n// 返回: 'quux.html'\npath.basename('/foo/bar/baz/asdf/quux.html', '.html');\n// 返回: 'quux'\n```","url":"","summary":"","reference":"","dot":"","title":"其它"},{"prefix":"path","tag":".extname","suffix":"(path)","desc":"返回 path 的扩展名\n从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 path.basename()）除了第一个字符以外没有 .，则返回空字符串。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"path","tag":".delimiter","suffix":"","desc":"提供平台特定的路径定界符：\n; 用于 Windows\n: 用于 POSIX","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".sep","suffix":"","desc":"提供平台特定的路径片段分隔符：\nWindows 上是 \\。\nPOSIX 上是 /。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".win32","suffix":"","desc":"提供对特定于 Windows 的 path 方法的实现的访问。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".posix","suffix":"","desc":"提供对 path 方法的 POSIX 特定实现的访问","url":"","summary":"","reference":"","dot":""}]}]},{"title":"目录","barcolor":"","fold":false,"box":[{"title":"检查","fold":false,"list":[{"prefix":"fs","tag":".existsSync","suffix":"(path)","desc":"如果路径存在，则返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""}]},{"title":"移动","fold":false,"list":[{"prefix":"fse","tag":".move","suffix":"(src,dest,fn)","desc":"移动内容，默认不覆盖\n```\nfs.move(srcpath, dstpath)\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/move.md","summary":"","reference":"","dot":""}]},{"title":"创建","fold":false,"list":[{"prefix":"fs","tag":".mkdir","suffix":"(path,fn)","desc":"创建目录,如已存在会失败\n同步方法：`fs.mkdirSync(path[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_mkdir_path_options_callback","dot":""},{"prefix":"fs","tag":".mkdtemp","suffix":"(prefix,fn)","desc":"创建一个唯一的临时目录。\n同步方法：`fs.mkdtempSync(prefix[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_mkdtemp_prefix_options_callback","dot":""}]},{"title":"删除","fold":false,"list":[{"prefix":"fs","tag":".rmdir","suffix":"(path,[opt],fn)","desc":"删除目录\n同步方法：`fs.rmdirSync(path[, options])`\nopt.recursive 如果为 true，则执行递归的目录删除。在递归模式中，如果 path 不存在则不报告错误，并且在失败时重试操作。默认值: false。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_rmdir_path_options_callback","dot":""},{"prefix":"fse","tag":".remove","suffix":"(path)","desc":"递归删除文件和目录\n```\nfs.remove('/tmp/myfile')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/remove.md","summary":"","reference":"","dot":""},{"prefix":"fse","tag":".emptyDir","suffix":"(dir)","desc":"递归清空目录\n```\nfs.emptyDir('/tmp/some/dir')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"fs","tag":".readdir","suffix":"(path,fn)","desc":"读取目录的内容\n同步方法：`fs.readdirSync(path[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_readdir_path_options_callback","dot":""},{"prefix":"fs","tag":".opendir","suffix":"(path,fn)","desc":"打开目录\n同步方法：`fs.opendirSync(path[, options])`","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_opendir_path_options_callback","dot":""},{"prefix":"","tag":"glob","suffix":"(**/*.js,fn(err,files))","desc":"选择glob规则指定文件\n```\nvar glob = require(\"glob\")\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n})\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/glob","dot":""}]}]},{"title":"zlib","barcolor":"","fold":false,"box":[{"title":"zlib","fold":false,"list":[{"prefix":"","tag":"compressing","suffix":"","desc":"","url":"https://github.com/node-modules/compressing","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"fs","barcolor":"","fold":false,"box":[{"title":"读取","fold":false,"list":[{"prefix":"fs","tag":".createReadStream","suffix":"(path,opt)","desc":"按流读取，highWaterMark为64KB。","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_createreadstream_path_options","dot":""},{"prefix":"fs","tag":".readFile","suffix":"(path,encoding,fn)","desc":"异步地读取文件的全部内容。（会缓冲整个文件）\n同步方法： `fs.readFileSync(path,opt);`\n","url":"","summary":"+ path：可以为文件名或文件描述符\n+ encoding：如果没有指定 encoding，则返回原始的 buffer。\n```\nfs.readFile('/etc/passwd', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n```","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback","dot":""},{"prefix":"fs","tag":".copyFile","suffix":"(src,dest,fn)","desc":"复制文件。如果已存在，则覆盖它。\n同步方法：`fs.copyFileSync(src, dest[, flags])`","url":"","summary":"","reference":"","dot":""},{"prefix":"fse","tag":".copy","suffix":"(src,dest)","desc":"递归拷贝\n```\nconst fs = require('fs-extra')\nfs.copy('/tmp/myfile', '/tmp/mynewfile')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/copy.md","summary":"","reference":"","dot":""}]},{"title":"写入","fold":false,"list":[{"prefix":"fs","tag":".createWriteStream","suffix":"(path,opt)","desc":"创建可写流","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options","dot":""},{"prefix":"fs","tag":".writeFile","suffix":"(file,data,fn)","desc":"异步地将数据写入到一个文件，如果文件已存在则覆盖该文件。\n同步方法：`fs.writeFileSync(file, data[, options])`","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback","dot":""},{"prefix":"fs","tag":".appendFile","suffix":"(path,data,fn)","desc":"异步地将数据追加到文件，如果文件尚不存在则创建该文件。data 可以是字符串或 Buffer。\n同步方法：`fs.appendFileSync(path, data[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_appendfile_path_data_options_callback","dot":""},{"prefix":"fse","tag":".outputFile","suffix":"(file,data)","desc":"写入文件，如果不存在，自动创建\n导出json，`fs.outputJson(file, object[, options][, callback])` \n```\nfs.outputFile(file, 'hello!')\n.then(() => fs.readFile(file, 'utf8'))\n.then(data => {\n  console.log(data) // => hello!\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/outputFile.md","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".truncate","suffix":"(path,len,fn)","desc":"截断文件内容,len指定保留的长度（字节数）\n同步方法：`fs.truncateSync(path[, len])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_truncate_path_len_callback","dot":""}]},{"title":"开关","fold":false,"list":[{"prefix":"fd","tag":" ","suffix":"","desc":"在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。 每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。 在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。 Windows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。 为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。\n大多数操作系统限制在任何给定时间内可能打开的文件描述符的数量，因此当操作完成时关闭描述符至关重要。 如果不这样做将导致内存泄漏，最终导致应用程序崩溃。","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".open","suffix":"(path,fn(err,fd))","desc":"打开文件\n同步方法：`fs.openSync(path[, flags, mode])`","url":"","summary":"<table class=\"reference\">\n<tbody><tr><th>Flag</th><th>描述</th></tr>\n<tr><td>r</td><td>以读取模式打开文件。如果文件不存在抛出异常。</td></tr>\n<tr><td>r+</td><td> 以读写模式打开文件。如果文件不存在抛出异常。</td></tr>\n<tr><td>rs</td><td>以同步的方式读取文件。</td></tr>\n<tr><td>rs+</td><td>以同步的方式读取和写入文件。</td></tr>\n<tr><td>w</td><td>以写入模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>wx</td><td>类似 'w'，但是如果文件路径存在，则文件写入失败。</td></tr>\n<tr><td>w+</td><td>以读写模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>wx+</td><td>类似 'w+'， 但是如果文件路径存在，则文件读写失败。</td></tr>\n<tr><td>a</td><td>以追加模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>ax</td><td>类似 'a'， 但是如果文件路径存在，则文件追加失败。</td></tr>\n<tr><td>a+</td><td>以读取追加模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>ax+</td><td>类似 'a+'， 但是如果文件路径存在，则文件读取追加失败。</td></tr>\n</tbody></table>","reference":"","dot":""},{"prefix":"fs","tag":".read","suffix":"(fd,buffer,offset,length,position)","desc":"从 fd 指定的文件中读取数据\n同步方法：`fs.readSync(fd, buffer, offset, length, position)`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback","dot":""},{"prefix":"fs","tag":".write","suffix":"(fd,data,fn)","desc":"将 buffer 写入到 fd 指定的文件。\n`fs.write(fd, buffer[, offset[, length[, position]]], callback)`\n`fs.write(fd, string[, position[, encoding]], callback)`\n同步方法：\n`fs.writeSync(fd, buffer[, offset[, length[, position]]])`\n`fs.writeSync(fd, string[, position[, encoding]])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback","dot":""},{"prefix":"fs","tag":".writev","suffix":"(fd,buffers,fn)","desc":"使用 writev() 将一个 ArrayBufferView 数组写入 fd 指定的文件。\n同步方法：`fs.writevSync(fd, buffers[, position])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_writev_fd_buffers_position_callback","dot":""},{"prefix":"fs","tag":".close","suffix":"(fd,fn)","desc":"关闭文件\n同步方法：`fs.closeSync(fd)`","url":"","summary":"","reference":"","dot":""}]},{"title":"监听","fold":false,"list":[{"prefix":"fs","tag":".watch","suffix":"(path,fn)","desc":"监视 filename 的更改，其中 filename 是文件或目录","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_watch_filename_options_listener","dot":""},{"prefix":"fs","tag":".watchFile","suffix":"(file,fn)","desc":"监视 filename 的更改。","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_watchfile_filename_options_listener","dot":""},{"prefix":"fs","tag":".unwatchFile","suffix":"(file,fn)","desc":"停止监视 filename 的变化","url":"","summary":"","reference":"","dot":""},{"prefix":"watcher.on(","tag":"change","suffix":",fn)","desc":"+ change 当监视的目录或文件中发生更改时触发\n+ error 当监视文件时发生错误时触发\n+ close 当监视器停止监视更改时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"watcher","tag":".close()","suffix":"","desc":"给定的 fs.FSWatcher 停止监视更改。 一旦停止，则 fs.FSWatcher 对象将不再可用。","url":"","summary":"","reference":"","dot":""}]},{"title":"链接","fold":false,"list":[{"prefix":"link","tag":" ","suffix":"","desc":"# inode\n我们首先来看看 linux 系统里面的一个重要概念：inode。\n\n我们知道，文件存储在硬盘上，硬盘存储的最小单位是扇区（sector，每个扇区 512 B）。而操作系统读取文件时，按块读取（连续的多个扇区），也就是说文件存取的最小单位是块（block，块通常是 4 KB）。\n\n除了文件数据，我们还必须存储文件的元信息（如：文件大小、文件创建者、文件数据的块位置、文件读/写/执行权限、文件时间戳等等），这种存储文件元信息的结构就称为 inode。\n\n每个 inode 都有一个唯一的号码标志，linux 系统内部使用 inode 的号码来识别文件，并不使用文件名。我们打开一个文件时，系统首先找到文件名对应的 inode 号码，然后通过 inode 号码获取 inode 信息，最后根据 inode 信息中的文件数据所在的 block 读出数据。\n\n实际上，在 linux 系统中，目录也是一种文件。目录文件包含一系列目录项，每个目录项由两部分组成：所包含文件的文件名，以及该文件名对应的 inode 号码。我们可以使用 ls -i 来列出目录中的文件以及它们的 inode 号码。这其实也解释了仅更改目录的读权限，并不能实现读取目录下所有文件内容的原因，通常需要 chmod -R 来进行递归更改。\n\n总结下：\n\n硬盘存取的最小单位是扇区，文件存取的最小单位是块（连续的扇区）\n存储文件元信息（文件大小、创建者、块位置、时间戳、权限等非数据信息）的结构称为 inode\n每个 inode 拥有一个唯一号码，系统内部通过它来识别文件\n目录也是一种文件，其内容包含一系列目录项（每个目录项由文件的文件名和文件对应的 inode 号码组成）","url":"","summary":"# 硬链接\n一般情况，一个文件名“唯一”对应一个 inode。但是，linux 允许多个文件名都指向同一个 inode。这表示我们可以使用不同的文件名访问同样的内容；对文件内容进行修改将“反映”到所有文件；删除一个文件不影响另一个文件的访问 。这种机制就被称为“硬链接”。\n\n# 软链接\n软链接\n软链接类似于 windows 中的”快捷方式“。两个文件虽然 inode 号码不一样，但是文件 A 内部会指向文件 B 的 inode。当我们读取文件 A 时，系统就自动导向文件 B，文件 A 就是文件 B 的软链接（或者叫符号链接）。这表示我们同样可以使用不同的文件名访问同样的内容；对文件内容修改将”反映“到所有文件。但是当我们删除掉源文件 B 时，再访问文件 A 时会报错 “No such file or directory”。","reference":"参考资料|https://kohpoll.github.io/blog/2016/05/30/hardlink-symlink-require-in-nodejs/","dot":""},{"prefix":"fs","tag":".link","suffix":"(old,new,fn)","desc":"创建硬链接\n同步方法：`fs.linkSync(existingPath, newPath)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".unlink","suffix":"(path,fn)","desc":"异步地删除文件或符号链接。\n同步方法：`fs.unlinkSync(path)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".readlink","suffix":"(path,encoding,fn)","desc":"异步读取链接\n同步方法：`fs.readlinkSync(path[, options])` ","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_readlink_path_options_callback","dot":""},{"prefix":"fs","tag":".symlink","suffix":"(target,path,fn)","desc":"软链接。创建名为 path 的链接，该链接指向 target。\n同步方法：`fs.symlinkSync(target, path[, type])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_symlink_target_path_type_callback","dot":""}]},{"title":"权限","fold":false,"list":[{"prefix":"fs","tag":".chmod","suffix":"(path,mode,fn)","desc":"异步地更改文件的权限，0o<所有者7><群组6><其他人5>\n同步方法：`fs.chmodSync(path, mode)`\n强制执行：`fs.fchmod(fd, mode, callback)`\nMacOS：`fs.lchmod(path, mode, callback)`","url":"","summary":"权限数字\n<table><thead><tr><th>数字</th><th>说明</th></tr></thead><tbody><tr><td><code>7</code></td><td>可读、可写、可执行</td></tr><tr><td><code>6</code></td><td>可读、可写</td></tr><tr><td><code>5</code></td><td>可读、可执行</td></tr><tr><td><code>4</code></td><td>只读</td></tr><tr><td><code>3</code></td><td>可写、可执行</td></tr><tr><td><code>2</code></td><td>只写</td></tr><tr><td><code>1</code></td><td>只可执行</td></tr><tr><td><code>0</code></td><td>没有权限</td></tr></tbody></table>\n构造 mode 更简单的方法是使用三个八进制数字的序列（ 例如 765）。 最左边的数字（示例中的 7）指定文件所有者的权限。 中间的数字（示例中的 6）指定群组的权限。 最右边的数字（示例中的 5）指定其他人的权限。\n例如，八进制值 0o765 表示：\n所有者可以读取、写入和执行该文件。\n群组可以读和写入该文件。\n其他人可以读取和执行该文件。\n注意事项：在 Windows 上，只能更改写入权限，并且不会实现群组、所有者或其他人的权限之间的区别。","reference":"","dot":""},{"prefix":"fs","tag":".chown","suffix":"(path,uid,gid,fn)","desc":"异步地更改文件的所有者和群组\n同步方法：`fs.chownSync(path, uid, gid)`\n强制执行：`fs.fchown(fd, uid, gid, callback)`\nMacOS：`fs.lchown(path, uid, gid, callback)`","url":"","summary":"","reference":"","dot":""}]},{"title":"杂项","fold":false,"list":[{"prefix":"fs","tag":".stat","suffix":"(path,fn(err,stats))","desc":"同步方法：`fs.statSync(path[, options])`\nstats.isDirectory() 是否为目录\nstats.isFile() 是否为常规文件\nstats.isSocket() 是否为套接字\nstats.isSymbolicLink() 是否为软链接","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_class_fs_stats","dot":""},{"prefix":"fs","tag":".rename","suffix":"(old,new,fn)","desc":"文件重命名。如果 newPath 已存在，则覆盖它。\n同步方法：`fs.renameSync(oldPath, newPath)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".utimes","suffix":"(path,atime,mtime,fn)","desc":"更改 path 指向的对象的文件系统时间戳。\n同步方法：`fs.utimesSync(path, atime, mtime)`","url":"","summary":"atime 和 mtime 参数遵循以下规则：\n值可以是表示 Unix 纪元时间的数字、 Date 对象、或类似 '123456789.0' 的数值字符串。\n如果该值无法转换为数值、或值为 NaN、 Infinity 或 -Infinity，则抛出错误。","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"python","fold":false,"list":[{"prefix":"","tag":"open","suffix":"(file,flag)","desc":"`f = open('/Users/michael/test.txt', 'w')`","url":"https://www.runoob.com/python3/python3-file-methods.html","summary":"","reference":"","dot":""},{"prefix":"f","tag":".write","suffix":"(data)","desc":"`f.write('Hello, world!')`","url":"","summary":"","reference":"","dot":""},{"prefix":"f","tag":".close()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"crypto","barcolor":"","fold":false,"box":[{"title":"hash","fold":false,"list":[{"prefix":"crypto","tag":".createHash","suffix":"('md5',[opt])","desc":"创建并返回一个 Hash 对象，该对象可用于生成哈希摘要\n常用md5,sha1,sha256,sha512 \n\n**注意**：Hash实例不能复用，hash实例调用digest之后不能再调用update\n","url":"","summary":"可选的 options 参数控制流的行为。 对于 XOF 哈希函数（例如 'shake256'）， outputLength 选项可用于指定所需的输出长度（以字节为单位）。","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_crypto_createhash_algorithm_options\n其他|https://blog.csdn.net/qq_34838046/article/details/109460977","dot":""},{"prefix":"hash","tag":".update","suffix":"(data)","desc":"默认字符串编码为UTF-8，也可以传入Buffer","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_hash_update_data_inputencoding","dot":""},{"prefix":"hash","tag":".digest","suffix":"('hex')","desc":"如果提供了 encoding，则返回字符串，否则返回 Buffer","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_hash_digest_encoding","dot":""},{"prefix":"crypto","tag":".getHashes()","suffix":"","desc":"支持的hash算法列表","url":"","summary":"algorithm 取决于平台上的 OpenSSL 的版本所支持的可用算法。\n新 `openssl list -digest-algorithms`\n旧 `openssl list-message-digest-algorithms`","reference":"","dot":""}]},{"title":"hmac","fold":false,"list":[{"prefix":"crypto","tag":".createHmac","suffix":"(alg,key)","desc":"加盐摘要\n```\nconst crypto = require('crypto');\nconst hmac = crypto.createHmac('sha256', '密钥');\nhmac.update('要创建哈希的数据');\nhmac.digest('hex')\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"hmac","tag":".update","suffix":"(data)","desc":"可通过多次调用或输入流","url":"","summary":"```\nconst input = fs.createReadStream(filename);\ninput.on('readable', () => {\n  // 哈希流只会生成一个元素。\n  const data = input.read();\n  if (data)\n    hmac.update(data);\n  else {\n    console.log(`${hmac.digest('hex')} ${filename}`);\n  }\n});\n```","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_class_hmac","dot":""},{"prefix":"hmac","tag":".digest","suffix":"([encoding])","desc":"计算使用 hmac.update() 传入的所有数据的 HMAC 摘要。 如果提供了 encoding，则返回字符串，否则返回 Buffer。\n调用 hmac.digest() 方法之后， Hmac 对象不能被再次使用。 多次调用 hmac.digest() 将会导致抛出错误。","url":"","summary":"","reference":"","dot":""}]},{"title":"Diffie-Hellman","fold":false,"list":[{"prefix":"crypto","tag":".createDiffieHellman","suffix":"(len)","desc":"密钥交换协议\n```\nconst crypto = require('crypto');\nconst assert = require('assert');\n\n// 生成 Alice 的密钥。\nconst alice = crypto.createDiffieHellman(2048);\nconst aliceKey = alice.generateKeys();\n\n// 生成 Bob 的密钥。\nconst bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());\nconst bobKey = bob.generateKeys();\n\n// 交换并生成密钥。\nconst aliceSecret = alice.computeSecret(bobKey);\nconst bobSecret = bob.computeSecret(aliceKey);\n\nassert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n```","url":"","summary":"","reference":"参考资料|https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640\n官方文档|http://nodejs.cn/api/crypto.html#crypto_class_diffiehellman","dot":""},{"prefix":"crypto","tag":".createECDH() ","suffix":"","desc":"椭圆曲线 Elliptic Curve Diffie-Hellman（ECDH）\n```\nconst crypto = require('crypto');\nconst assert = require('assert');\n\n// 生成 Alice 的密钥。\nconst alice = crypto.createECDH('secp521r1');\nconst aliceKey = alice.generateKeys();\n\n// 生成 Bob 的密钥。\nconst bob = crypto.createECDH('secp521r1');\nconst bobKey = bob.generateKeys();\n\n// 交换并生成密钥。\nconst aliceSecret = alice.computeSecret(bobKey);\nconst bobSecret = bob.computeSecret(aliceKey);\n\nassert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n```","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_class_ecdh","dot":""},{"prefix":"crypto","tag":".getCurves()","suffix":"","desc":"查看全部椭圆曲线算法","url":"","summary":"","reference":"","dot":""}]},{"title":"AES","fold":false,"list":[{"prefix":"crypto","tag":".createCipher","suffix":"('aes192',key)","desc":"对称加密算法,常用如aes192，aes-128-ecb，aes-256-cbc等\n```\nfunction aesEncrypt(data, key) {\n    const cipher = crypto.createCipher('aes192', key);\n    var crypted = cipher.update(data, 'utf8', 'hex');\n    crypted += cipher.final('hex');\n    return crypted;\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"crypto","tag":".createDecipher","suffix":"('aes192',key)","desc":"```\nfunction aesDecrypt(encrypted, key) {\n    const decipher = crypto.createDecipher('aes192', key);\n    var decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"crypto","tag":".getCiphers()","suffix":"","desc":"支持的对称加密算法列表","url":"","summary":"","reference":"","dot":""}]},{"title":"RSA","fold":false,"list":[{"prefix":"crypto","tag":".privateEncrypt","suffix":"(prvKey,data)","desc":"非对称加密算法\n私钥加密 `let enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, 'utf8'));`\n公钥解密 `let dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv)`\n","url":"","summary":"","reference":"RSA算法原理（一）|http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\nRSA算法原理（二）|http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html","dot":""},{"prefix":"crypto","tag":".publicEncrypt","suffix":"(pubKey,data)","desc":"RSA加密的原始信息必须小于Key的长度\n公钥加密 `let enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, 'utf8'))`\n私钥解密 `let dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub)`","url":"","summary":"","reference":"","dot":""}]},{"title":"Misc","fold":false,"list":[{"prefix":"crypto","tag":".randomBytes","suffix":"(len).toString('hex')","desc":"生成随机字符\n```\nconst buf = crypto.randomBytes(256);\nconsole.log(\n  `${buf.length} 位的随机数据: ${buf.toString('hex')}`);\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"uuid","suffix":"","desc":"# Random UUIDs\n```\nimport { v4 as uuidv4 } from 'uuid';\nuuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'\n```\n# Timestamp UUIDs\n```\nimport { v1 as uuidv1 } from 'uuid';\nuuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8b2d-1b9d6bcdbbfd'\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/uuid","dot":""}]},{"title":"web crypto api","fold":false,"list":[{"prefix":"window","tag":".crypto","suffix":".subtle","desc":"","url":"","summary":"","reference":"参考资料|https://cloud.tencent.com/developer/article/1171800\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/SubtleCrypto","dot":""},{"prefix":"crypto.subtle","tag":".digest","suffix":"(alg,data)","desc":"摘要算法\n```\ncrypto.subtle.digest('SHA-256', new Uint8Array([1,2,3,4]))\n.then((hash)=>{\n    let arr = new Uint8Array(hash)\n    let str = ''\n    for(bit of arr){\n        str += bit.toString(16)\n    }\n})\n```","url":"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest","summary":"","reference":"MDN|https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"hash","fold":false,"list":[{"prefix":"md5|sha1","tag":".update","suffix":"(val)","desc":"```\nimport hashlib\nhashlib.md5()\n```","url":"","summary":"MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。","reference":"","dot":""},{"prefix":"md5|sha1","tag":".hexdigest()","suffix":"","desc":"MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。\nSHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示","url":"","summary":"","reference":"","dot":""}]},{"title":"hmac","fold":false,"list":[{"prefix":"hmac","tag":".new","suffix":"(key,data,digestmod='MD5')","desc":"```\nimport hmac\nmessage = b'Hello, world!'\nkey = b'secret'\nh = hmac.new(key, message, digestmod='MD5')\n```\n如果消息很长，可以多次调用h.update(msg)","url":"","summary":"","reference":"","dot":""},{"prefix":"h","tag":".hexdigest()","suffix":"","desc":"使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"process","barcolor":"","fold":false,"box":[{"title":"属性","fold":false,"list":[{"prefix":"process","tag":".argv","suffix":"","desc":"返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数\n+ `process.argv0` 当 Node.js 启动时传入的 argv[0] 的原始值的只读副本\n+ `process.execPath` 返回启动 Node.js 进程的可执行文件的绝对路径名\n+ `process.execArgv` 返回当 Node.js 进程被启动时，Node.js 特定的命令行选项,这些选项在 process.argv 属性返回的数组中不会出现","url":"","summary":"\n","reference":"","dot":""},{"prefix":"process","tag":".env","suffix":"","desc":"返回包含用户环境的对象\n可以修改此对象，但这些修改不会反映到 Node.js 进程之外，或者（除非明确请求）反映到其他 Worker 线程。","url":"","summary":"通常的做法是，新建一个环境变量NODE_ENV，用它确定当前所处的开发阶段，生产阶段设为production，开发阶段设为develop或staging，然后在脚本中读取process.env.NODE_ENV即可。\n`export NODE_ENV=production && node app.js`","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_env","dot":""},{"prefix":"process","tag":".cwd()","suffix":"","desc":"返回 Node.js 进程的当前工作目录\n`process.chdir(dir)`  变更 Node.js 进程的当前工作目录，如果变更目录失败会抛出异常","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".pid","suffix":"","desc":"`process.pid` 返回进程的 PID\n`process.ppid` 返回当前父进程的 PID\n`process.title` 返回当前进程标题,可以自定义该值","url":"","summary":"","reference":"","dot":""}]},{"title":"IPC","fold":false,"list":[{"prefix":"process","tag":".channel","suffix":"","desc":"如果 Node.js 进程是由 IPC 通道（参阅子进程文档）方式创建的， process.channel 属性保存 IPC 通道的引用。 如果 IPC 通道不存在，则此属性值为 undefined。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".send","suffix":"(msg,handle,fn)","desc":"进程间发送消息\n消息会进行序列化和解析","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"message","suffix":",fn)","desc":"收到消息时","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".disconnect()","suffix":"","desc":"关闭到父|子进程的 IPC 通道","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"disconnect","suffix":",fn)","desc":"IPC 通道关闭时将触发 'disconnect' 事件","url":"","summary":"调用父进程中的 subprocess.disconnect() 或子进程中的 process.disconnect() 后会触发 'disconnect' 事件。 断开连接后就不能再发送或接收信息，且 subprocess.connected 属性为 false。","reference":"","dot":""}]},{"title":"退出","fold":false,"list":[{"prefix":"process","tag":".exit","suffix":"(0)","desc":"以退出状态 code 指示 Node.js 同步地终止进程。\n0成功 1失败","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/process.html#process_process_exit_code","dot":""},{"prefix":"process","tag":".exitCode","suffix":"","desc":"指定错误码，抛出异常退出\n```\nprocess.exitCode = 1;\nthrow new Error(\"xx condition failed\");\n```","url":"","summary":"`process.exit()` 手动退出当前进程\n+ 如果参数大于0表示执行失败\n+ 如果等于0表示执行成功\n注意，process.exit()很多时候是不需要的。因为如果没有错误，一旦事件循环之中没有待完成的任务，Node 本来就会退出进程，不需要调用process.exit(0)。这时如果调用了，进程会立刻退出，不管有没有异步任务还在执行，所以不如等 Node 自然退出。另一方面，如果发生错误，Node 往往也会退出进程，也不一定要调用process.exit(1)。","reference":"","dot":""},{"prefix":"process.on(","tag":"exit","suffix":",fn(code))","desc":"当 Node.js 进程因以下原因之一即将退出时，则会触发 'exit' 事件：\n+ 显式调用 `process.exit()` 方法；\n+ Node.js 事件循环不再需要执行任何其他工作。\n此时无法阻止退出事件循环，并且一旦所有 'exit' 事件的监听器都已完成运行时，Node.js 进程将终止。\n\n注意，此时回调函数只能执行*同步*操作，不能包含异步操作，因为执行完回调函数，进程就会退出，无法监听到回调函数的操作结果。","url":"","summary":"# 退出码\n正常情况下，如果没有异步操作正在等待，那么 Node.js 会以状态码 0 退出，其他情况下，会用如下的状态码:\n1 未捕获异常 - 有一个未被捕获的异常, 并且没被 domain 或 'uncaughtException' 事件处理器处理。\n2 - 未被使用 (Bash 为防内部滥用而保留)\n3 内部的 JavaScript 解析错误 - Node.js 内部的 JavaScript 源代码在引导进程中导致了一个语法解析错误。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n4 内部的 JavaScript 执行失败 - 引导进程执行 Node.js 内部的 JavaScript 源代码时，返回函数值失败。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n5 致命错误 - 在 V8 中有一个致命的错误。 比较典型的是以 FATALERROR 为前缀从 stderr 打印出来的消息。\n6 非函数的内部异常处理 - 发生了一个内部异常，但是内部异常处理函数被设置成了一个非函数，或者不能被调用。\n7 内部异常处理运行时失败 - 有一个不能被捕获的异常，在试图处理这个异常时，处理函数本身抛出了一个错误。 这是可能发生的, 比如, 如果一个 'uncaughtException' 或者 domain.on('error') 处理函数抛出了一个错误。\n8 - 未被使用，在之前版本的 Node.js, 退出码 8 有时候表示一个未被捕获的异常。\n9 - 不可用参数 - 也许是某个未知选项没有确定，或者没给必需要的选项填值。\n10 内部的 JavaScript 运行时失败 - 调用引导函数时，引导进程执行 Node.js 内部的 JavaScript 源代码抛出错误。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n12 不可用的调试参数 - --inspect 和/或 --inspect-brk 选项已设置，但选择的端口号无效或不可用。\n>128 退出信号 - 如果 Node.js 接收到致命信号, 诸如 SIGKILL 或 SIGHUP，那么它的退出代码将是 128 加上信号的码值。 这是 POSIX 的标准做法，因为退出码被定义为 7 位整数，并且信号退出设置高位，然后包含信号码值。 例如，信号 SIGABRT 的值为 6，因此预期的退出代码将为 128 + 6 或 134。","reference":"","dot":""},{"prefix":"process.on(","tag":"beforeExit","suffix":",fn)","desc":"对于导致显式终止的条件，不会触发 'beforeExit' 事件，例如调用 process.exit() 或未捕获的异常。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".abort()","suffix":"","desc":"使 Node.js 进程立即结束，并生成一个核心文件","url":"","summary":"Worker 线程中没有此特性。","reference":"","dot":""}]},{"title":"信号","fold":false,"list":[{"prefix":"process","tag":".kill","suffix":"(pid,[signal])","desc":"对指定ID的线程发送信号，默认为SIGTERM信号","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_kill_pid_signal","dot":""},{"prefix":"process","tag":".kill","suffix":"([signal])","desc":"子进程或cluster worker自杀\n默认信号SIGTERM。如果成功，则此函数返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"<sign>","suffix":",fn)","desc":"当 Node.js 进程接收到一个信号时，会触发信号事件。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_signal_events","dot":""}]},{"title":"异常","fold":false,"list":[{"prefix":"process.on(","tag":"error","suffix":",fn)","desc":"每当出现以下情况时触发 'error' 事件：\n无法衍生进程；\n无法杀死进程；\n向子进程发送消息失败。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"uncaughtException","suffix":",fn(err,origin))","desc":"只要有错误没有捕获，就会触发这个事件。\n正确使用 'uncaughtException' 事件的方式，是用它在进程结束前执行一些已分配资源（比如文件描述符，句柄等等）的同步清理操作","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_event_uncaughtexception","dot":""},{"prefix":"process.on(","tag":"rejectionHandled","suffix":")","desc":"每当 Promise 被拒绝并且错误处理函数附加到它（例如，使用 promise.catch()）晚于一个 Node.js 事件循环时，就会触发 'rejectionHandled' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"unhandledRejection","suffix":")","desc":"如果在事件循环的一次轮询中，一个 Promise 被拒绝，并且此 Promise 没有绑定错误处理器， 'unhandledRejection 事件会被触发。 ","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"warning","suffix":",fn)","desc":"任何时候 Node.js 触发进程告警，都会触发 'warning' 事件。\n告警不是 Node.js 和 Javascript 错误处理流程的正式组成部分。 一旦探测到可能导致应用性能问题，缺陷或安全隐患相关的代码实践，Node.js 就可发出告警。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".emitWarning","suffix":"(msg,opt)","desc":"触发自定义或应用特定的进程警告\n","url":"","summary":"```\nprocess.emitWarning('出错啦', {\n  code: 'MY_WARNING',\n  detail: '一些额外的信息'\n});\n```","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_emitwarning_warning_options","dot":""}]},{"title":"优先级","fold":false,"list":[{"prefix":"process","tag":".nextTick","suffix":"(fn)","desc":"放到当前一轮事件循环（Event Loop）的尾部\nsetTimeout(f,0)是将任务放到下一轮事件循环的头部，因此nextTick会比它先执行。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".setPriority","suffix":"([pid],priority)","desc":"尝试为 pid 指定的进程设置调度优先级。 \n如果未提供 pid 或者为 0，则使用当前进程的进程 ID。\npriority 输入必须是 -20（高优先级）到 19（低优先级）之间的整数。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".getPriority","suffix":"([pid])","desc":"返回由 pid 指定的进程的调度优先级。\n如果未提供 pid 或者为 0，则返回当前进程的优先级。","url":"","summary":"","reference":"","dot":""}]},{"title":"信息","fold":false,"list":[{"prefix":"process","tag":".uptime()","suffix":"","desc":"返回当前 Node.js 进程运行时间秒长","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".memoryUsage()","suffix":"","desc":"返回 Node.js 进程的内存使用情况的对象，该对象每个属性值的单位为字节。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".resourceUsage()","suffix":"","desc":"资源使用","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".config","suffix":"","desc":"返回一个 Object，其中包含用于编译当前 Node.js 可执行文件的配置选项的 JavaScript 表示形式。 这与运行 ./configure 脚本时生成的 config.gypi 文件相同。","url":"","summary":"","reference":"","dot":""}]},{"title":"环境","fold":false,"list":[{"prefix":"process","tag":".platform","suffix":"","desc":"返回字符串，标识 Node.js 进程运行其上的操作系统平台。\n当前可能的值有：\n'aix'\n'darwin'\n'freebsd'\n'linux'\n'openbsd'\n'sunos'\n'win32'","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".arch","suffix":"","desc":"为其编译 Node.js 二进制文件的操作系统的 CPU 架构。 \n可能的值有：'arm'、 'arm64'、 'ia32'、 'mips'、 'mipsel'、 'ppc'、 'ppc64'、 's390'、 's390x'、 'x32' 和 'x64'。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".version","suffix":"","desc":"返回 Node.js 的版本信息","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"child_process","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"child_process.","tag":"exec","suffix":"(cmd,fn)","desc":"新建一个子进程，然后缓存它的运行结果，运行结束后调用回调函数，返回childprocess实例。\n同步方法：`child_process.execSync(command[, options])`\n适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。","url":"","summary":"回调函数参数：error, stdout, stderr\nexec方法会直接调用bash（/bin/sh程序）来解释命令","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback","dot":""},{"prefix":"child_process","tag":".spawn","suffix":"(cmd,[argarr])","desc":"与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。\n同步方法：`child_process.spawnSync(command[, args][, options])`\n适用于返回大量数据，例如图像处理，二进制数据处理","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options","dot":""},{"prefix":"child_process","tag":".execFile","suffix":"(file,[argarr],fn)","desc":"直接执行特定的程序，参数作为数组传入，不会被bash解释\n同步方法：`child_process.execFileSync(file[, args][, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback","dot":""},{"prefix":"child_process","tag":".fork","suffix":"(file)","desc":"fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。","url":"","summary":"衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。","reference":"参考资料|https://juejin.im/post/5d06d6ddf265da1b9570562a","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"child.on(","tag":"close","suffix":",fn)","desc":"当子进程的 stdio 流已被关闭时会触发 'close' 事件。 这与 'exit' 事件不同，因为多个进程可能共享相同的 stdio 流。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"cluster","barcolor":"","fold":false,"box":[{"title":"主进程","fold":false,"list":[{"prefix":"pm2 start app.js","tag":" -i 4","suffix":"","desc":"集群，-i 参数用来告诉PM2以cluster\\_mode的形式运行你的app（对应的叫fork_mode），后面的数字表示要启动的工作线程的数量。如果给定的数字为0，PM2则会根据你CPU核心的数量来生成对应的工作线程。注意一般在生产环境使用cluster\\_mode模式，测试或者本地环境一般使用fork模式，方便测试到错误。","url":"","summary":"","reference":"官方文档|https://pm2.keymetrics.io/docs/usage/quick-start/","dot":""},{"prefix":"cluster","tag":".isMaster","suffix":"","desc":"`cluster.isMaster` 如果该进程是主进程，则为 true。\n`cluster.isWorker` 如果该进程不是主进程，则为 true","url":"","summary":"","reference":"参考资料|https://juejin.im/post/5d43017be51d4561f40adcf9#heading-17","dot":""},{"prefix":"cluster","tag":".fork()","suffix":"","desc":"衍生出一个新的工作进程。","url":"","summary":"```\nvar cluster = require('cluster');\n\nif(cluster.isMaster) {\n  var numWorkers = require('os').cpus().length;\n  console.log('Master cluster setting up ' + numWorkers + ' workers...');\n\n  for(var i = 0; i < numWorkers; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('online', function(worker) {\n    console.log('Worker ' + worker.process.pid + ' is online');\n  });\n\n  cluster.on('exit', function(worker, code, signal) {\n    console.log('Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal);\n    console.log('Starting a new worker');\n    cluster.fork();\n  });\n}\n```","reference":"参考资料|https://zhuanlan.zhihu.com/p/74879045","dot":""},{"prefix":"cluster.on(","tag":"<event>","suffix":",fn)","desc":"+ fork 当主进程衍生工作进程时触发\n+ online 当工作进程运行时触发\n+ listening 任意worker触发时触发\n+ message 从任意工作进程收到消息时\n+ disconnect 任意worker工作进程的 IPC 管道被断开后触发。 可能导致事件触发的原因包括：工作进程优雅地退出、被杀死、或手动断开连接\n+ exit 任意worker退出时","url":"","summary":"","reference":"","dot":""},{"prefix":"cluster.","tag":"disconnect","suffix":"(fn)","desc":"在 cluster.workers 的每个工作进程中调用 .disconnect()","url":"","summary":"","reference":"","dot":""}]},{"title":"子进程","fold":false,"list":[{"prefix":"worker.on(","tag":"<event>","suffix":",fn)","desc":"'message' 事件\n+ online 就绪时\n+ listening 当调用 listen() 时触发\n+ disconnect 断开连接时\n+ message 收到消息时\n+ exit 退出时","url":"","summary":"","reference":"参考资料|https://zhuanlan.zhihu.com/p/74879045","dot":""},{"prefix":"worker","tag":".id","suffix":"","desc":"每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在 id 里面。\n当工作进程还存活时，这个编号可以作为在 cluster.workers 中的索引。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"worker_threads","barcolor":"","fold":false,"box":[{"title":"主线程","fold":false,"list":[{"prefix":"","tag":"isMainThread","suffix":"","desc":"当前线程为主线程时返回true","url":"","summary":"```\nconst {\n    Worker,\n    isMainThread,\n    threadId,\n    workerData,\n    SHARE_ENV\n} = require(\"worker_threads\");\n\n//主线程\nif (isMainThread) {\n    console.log(threadId);  //主线程ID\n    var worker = new Worker(__filename, {\n        workerData: \"Hello, world!\",    //传递数据\n        env: SHARE_ENV  //共享环境变量\n    });\n\n    worker.on(\"exit\", () => {\n        console.log(process.env.SET_IN_WORKER);\n    });\n\n//工作线程\n} else {\n    console.log(threadId);  //子线程ID\n    // console.log(workerData);    //被传递数据\n    process.env.SET_IN_WORKER = \"foo\";  //设置共享环境变量\n}\n```","reference":"参考资料|https://juejin.im/post/5d736a675188254faf71521a","dot":""},{"prefix":"","tag":"new Worker","suffix":"(path,opt)","desc":"# opt\nenv ：SHARE_ENV //主线程与子线程可共享环境变量读写\nworkerData : 传递数据 \nresourceLimits ： 资源限制","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/worker_threads.html#worker_threads_new_worker_filename_options","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(data,[transferList])","desc":"向工作线程发送数据","url":"","summary":"","reference":"","dot":""},{"prefix":"worker.on(","tag":"message","suffix":",fn)","desc":"收到工作线程消息时","url":"","summary":"","reference":"","dot":""},{"prefix":"worker.on(","tag":"<event>","suffix":",fn)","desc":"工作线程的其他事件\n+ online 工作线程就绪\n+ error 错误事件\n+ exit 退出事件\n ","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".terminate()","suffix":"","desc":"关闭线程","url":"","summary":"","reference":"","dot":""}]},{"title":"工作线程","fold":false,"list":[{"prefix":"parentPort.on(","tag":"message","suffix":",fn)","desc":"接收主线程消息","url":"","summary":"","reference":"","dot":""},{"prefix":"parentPort","tag":".postMessage","suffix":"(data)","desc":"向主主线程发送消息","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"workerData","suffix":"","desc":"初始化时由主线程拷贝传递的数据","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"threadId","suffix":"","desc":"线程唯一ID","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"io","barcolor":"","fold":false,"box":[{"title":"process","fold":false,"list":[{"prefix":"ps","tag":".stdin","suffix":".on(data,fn(data))","desc":"返回连接到 stdin (fd 0) 的流。 它是一个 net.Socket 流（也就是双工流）\n由于stdin和stdout都部署了stream接口，所以可以使用stream接口的方法\n`process.stdin` 当前进程\n`child.stdin` 创建的子进程实例，可绑定data事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ps","tag":".stdout","suffix":".on(data,fn(data))","desc":"返回连接到 stdout (fd 1) 的流。它是一个 net.Socket 流（也就是双工流），","url":"","summary":"","reference":"","dot":""},{"prefix":"ps","tag":".stderr","suffix":".on(data,fn(data))","desc":"返回连接到 stderr (fd 2) 的流。 它是一个 net.Socket 流（也就是双工流）","url":"","summary":"","reference":"","dot":""}]},{"title":"lib","fold":false,"list":[{"prefix":"","tag":"commander","suffix":"","desc":"","url":"https://www.npmjs.com/package/commander","summary":"","reference":"","dot":""},{"prefix":"","tag":"chalk","suffix":"","desc":"","url":"https://www.npmjs.com/package/chalk","summary":"","reference":"","dot":""}]}]},{"title":"os","barcolor":"","fold":false,"box":[{"title":"信息","fold":false,"list":[{"prefix":"os","tag":".freemem()","suffix":"","desc":"以整数的形式返回空闲的系统内存量（以字节为单位）\n`os.totalmem()` 以整数的形式返回系统的内存总量（以字节为单位）。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".loadavg()","suffix":"","desc":"返回一个数组，包含 1、5 和 15 分钟的平均负载。\n平均负载是系统活动性的测量，由操作系统计算得出，并表现为一个分数。\n平均负载是 UNIX 特定的概念。 在 Windows 上，其返回值始终为 [0, 0, 0]。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".uptime()","suffix":"","desc":"返回系统的正常运行时间（以秒为单位）。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".networkInterfaces()","suffix":"","desc":"返回一个对象，该对象包含已分配了网络地址的网络接口。\n返回的对象上的每个键都标识了一个网络接口。 关联的值是一个对象数组，每个对象描述了一个分配的网络地址。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/os.html#os_os_networkinterfaces","dot":""},{"prefix":"os","tag":".hostname()","suffix":"","desc":"以字符串的形式返回操作系统的主机名。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".homedir()","suffix":"","desc":"返回当前用户的主目录的字符串路径。\n在 POSIX 上，使用 $HOME 环境变量（如果有定义）。 否则，使用有效的 UID 来查找用户的主目录。\n在 Windows 上，使用 USERPROFILE 环境变量（如果有定义）。 否则，使用当前用户的配置文件目录的路径。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".tmpdir()","suffix":"","desc":"以字符串的形式返回操作系统的默认临时文件目录。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".userInfo()","suffix":"","desc":"返回关于当前有效用户的信息。\n在 POSIX 平台上，这通常是密码文件的子集。 返回的对象包含 username、 uid、 gid、 shell 和 homedir。 \n在 Windows 上，则 uid 和 gid 字段为 -1，且 shell 为 null。","url":"","summary":"","reference":"","dot":""}]},{"title":"环境","fold":false,"list":[{"prefix":"os","tag":".constants","suffix":"","desc":"包含错误码、进程信号等常用的操作系统特定的常量。 定义的特定常量在 OS 常量中描述。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".cpus()","suffix":"","desc":"返回一个对象数组，其中包含有关每个逻辑 CPU 内核的信息。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/os.html#os_os_cpus","dot":""},{"prefix":"os.","tag":"EOL","suffix":"","desc":"操作系统特定的行末标志。\n在 POSIX 上是 \\n。\n在 Windows 上是 \\r\\n。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".endianness()","suffix":"","desc":"返回一个字符串，该字符串标识为其编译 Node.js 二进制文件的 CPU 的字节序。\n可能的值有， 'BE' 用于大端字节序， 'LE' 用于小端字节序。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".platform()","suffix":"","desc":"返回标识操作系统平台的字符串。 该值在编译时设置。\n可能的值有 'aix'、 'darwin'、 'freebsd'、 'linux'、 'openbsd'、 'sunos' 和 'win32'。\n`os.type()` 返回操作系统名字。 例如，在 Linux 上返回 'Linux'，在 macOS 上返回 'Darwin'，在 Windows 上返回 'Windows_NT'。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".arch()","suffix":"","desc":"返回为其编译 Node.js 二进制文件的操作系统的 CPU 架构。 \n可能的值有：'arm'、 'arm64'、 'ia32'、 'mips'、 'mipsel'、 'ppc'、 'ppc64'、 's390'、 's390x'、 'x32' 和 'x64'","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".release()","suffix":"","desc":"以字符串的形式返回操作系统。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"io","fold":false,"list":[{"prefix":"","tag":"input","suffix":"(msg)","desc":"等待用户输入","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"print","suffix":"(val,..)","desc":"print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"WebSocket","barcolor":"","fold":false,"box":[{"title":"客户端","fold":false,"list":[{"prefix":"","tag":"new WebSocket","suffix":"(ws://url)","desc":"新建WebSocket实例","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"readyState","suffix":"","desc":"readyState属性返回实例对象的当前状态，共有四种。\nCONNECTING：值为0，表示正在连接。\nOPEN：值为1，表示连接成功，可以通信了。\nCLOSING：值为2，表示连接正在关闭。\nCLOSED：值为3，表示连接已经关闭，或者打开连接失败。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"binaryType","suffix":"","desc":"指定收到的二进制数据类型","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"bufferedAmount","suffix":"","desc":"表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。","url":"","summary":"```\nvar data = new ArrayBuffer(10000000);\nsocket.send(data);\n\nif (socket.bufferedAmount === 0) {\n  // 发送完毕\n} else {\n  // 发送还没结束\n}\n```","reference":"","dot":""},{"prefix":"ws.addEventListener(","tag":"<event>","suffix":",fn)","desc":"+ open 连接成功\n+ close 连接关闭\n+ message 收到服务器数据 \n+ error 发生错误","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".send","suffix":"(data)","desc":"发送数据","url":"","summary":"发送 Blob 对象\n```\nvar file = document\n  .querySelector('input[type=\"file\"]')\n  .files[0];\nws.send(file);\n```\n发送 ArrayBuffer 对象\n```\n// Sending canvas ImageData as ArrayBuffer\nvar img = canvas_context.getImageData(0, 0, 400, 320);\nvar binary = new Uint8Array(img.data.length);\nfor (var i = 0; i < img.data.length; i++) {\n  binary[i] = img.data[i];\n}\nws.send(binary.buffer);\n```","reference":"","dot":""},{"prefix":"ws","tag":".close","suffix":"([code,data])","desc":"code 默认1005。\nreason 关闭原因","url":"","summary":"","reference":"","dot":""}]},{"title":"服务端","fold":false,"list":[{"prefix":"请求头与响应头","tag":" ","suffix":"","desc":"# 请求头\n```\nGET / HTTP/1.1\nConnection: Upgrade\nUpgrade: websocket\nHost: example.com\nOrigin: null\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\nSec-WebSocket-Version: 13\n```\n\n# 响应头\n```\nHTTP/1.1 101 Switching Protocols\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\nSec-WebSocket-Origin: null\nSec-WebSocket-Location: ws://example.com/\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"实现原理","tag":" ","suffix":"","desc":"服务端实现:\n1.根据请求头判断是否为WebSocket请求\n2.校验Sec-WebSocket-Key\n```\nconst GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\nconst key = headers['sec-websocket-key']\nconst hash = crypto.createHash('sha1') // 创建一个签名算法为sha1的哈希对象\nhash.update(`${key}${GUID}`)  // 将key和GUID连接后，更新到hash\nconst result = hash.digest('base64') // 生成base64字符串\n```","url":"","summary":"","reference":"","dot":"","title":"node server"},{"prefix":"","tag":"ws","suffix":"","desc":"","url":"https://github.com/websockets/ws","summary":"","reference":"参考资料1|https://blog.csdn.net/chencl1986/article/details/88411056\n参考资料2|https://juejin.im/post/5e01e10ce51d4557f17fc14a","dot":""},{"prefix":"","tag":"socket.io","suffix":"","desc":"","url":"https://www.w3cschool.cn/socket/socket-1olq2egc.html","summary":"","reference":"Github|https://github.com/socketio/socket.io","dot":""}]}]},{"title":"HTTP","barcolor":"","fold":false,"box":[{"title":"node server","fold":true,"list":[{"prefix":"","tag":"http.STATUS_CODES","suffix":"","desc":"所有标准 HTTP 响应状态码的集合，以及每个状态码的简短描述。\n例如， `http.STATUS_CODES[404] === 'Not Found'`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"http.createServer","suffix":"(fn(req,res))","desc":"创建HTTP服务器\nrequestListener 是一个自动添加到 'request' 事件的函数","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".on","suffix":"(event,fn)","desc":"+ checkContinue 每次收到 HTTP Expect: 100-continue 的请求时都会触发\n+ checkExpectation 每次收到带有 HTTP Expect 请求头的请求时触发，其中值不是 100-continue。 \n+ clientError 如果客户端连接触发 'error' 事件，则会在此处转发。 此事件的监听器负责关闭或销毁底层套接字。\n+ close 当服务器关闭时触发。\n+ connect 每次客户端请求 HTTP CONNECT 方法时触发。 如果未监听此事件，则请求 CONNECT 方法的客户端将关闭其连接。\n+ connection 建立新的 TCP 流时会触发此事件。\n+ request 每次有请求时都会触发。\n+ upgrade 每次客户端请求 HTTP 升级时发出。 ","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".listen","suffix":"(port)","desc":"启动 HTTP 服务器监听连接。","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".close","suffix":"(fn)","desc":"停止服务器接受新连接","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".setTimeout","suffix":"(ms,fn)","desc":"设置套接字的超时值，并在服务器对象上触发 'timeout' 事件，如果发生超时，则将套接字作为参数传入。\n默认情况下，服务器的超时值为 2 分钟，如果超时，套接字会自动销毁。","url":"","summary":"","reference":"","dot":""}]},{"title":"node IncomingMessage","fold":true,"list":[{"prefix":"msg","tag":".on","suffix":"('data',fn)","desc":"IncomingMessage 对象由 http.Server 或 http.ClientRequest 创建，并分别作为第一个参数传给 'request' 和 'response' 事件。 它可用于访问响应状态、消息头、以及数据。继承自: stream.Readable","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".method","suffix":"","desc":"请求方法为字符串。 只读。 示例：'GET'、 'DELETE'。","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".url","suffix":"","desc":"请求的 URL 字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".headers","suffix":"","desc":"消息头的名称和值的键值对。 消息头的名称都是小写的。","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".statusCode","suffix":"","desc":"3 位 HTTP 响应状态码。 例如 404。","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".statusMessage","suffix":"","desc":"HTTP 响应状态消息（原因短语）","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".complete","suffix":"","desc":"如果已收到并成功解析完整的 HTTP 消息，则 message.complete 属性将为 true。","url":"","summary":"","reference":"","dot":""}]},{"title":"node ServerResponse","fold":true,"list":[{"prefix":"res","tag":".on","suffix":"(event,fn)","desc":"+ close 表明底层的连接已被终止。\n+ finish 响应发送后触发","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".writeHead","suffix":"(code,headers)","desc":"向请求发送响应头。\n```\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain'\n  })\n  .end(body);\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".setHeader","suffix":"(key,val)","desc":"为隐式响应头设置单个响应头的值。\n`response.flushHeaders()` 刷新响应头\n`response.getHeader(name)` 读出已排队但未发送到客户端的响应头。\n`response.getHeaderNames()` 返回一个数组，其中包含当前传出的响应头的唯一名称。 所有响应头名称都是小写的。\n`response.getHeaders()` 返回当前传出的响应头的浅拷贝。\n`response.hasHeader(name)` 如果当前在传出的响应头中设置了由 name 标识的响应头，则返回 true。 响应头名称匹配不区分大小写。\n`response.removeHeader(name)` 移除排队等待中的隐式发送的响应头。","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".statusCode","suffix":"","desc":"响应头发送到客户端后，此属性表示已发送的状态码。","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".statusMessage","suffix":"","desc":"响应头发送到客户端后，此属性表示已发送的状态消息。","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".write","suffix":"(chunk,fn)","desc":"这会发送一块响应主体。 可以多次调用该方法以提供连续的响应主体片段。","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".end","suffix":"([data],fn)","desc":"此方法向服务器发出信号，表明已发送所有响应头和主体，该服务器应该视为此消息已完成。 必须在每个响应上调用此 response.end() 方法。","url":"","summary":"","reference":"","dot":""}]},{"title":"node client","fold":true,"list":[{"prefix":"","tag":"http.get","suffix":"(url,fn(res))","desc":"用于发出get请求,自动调用end方法\n返回http.ClientRequest实例","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"http.request","suffix":"(opt,fn(res))","desc":"可设定具体选项,需要手动end\n返回http.ClientRequest实例","url":"","summary":"```\nconst postData = querystring.stringify({\n  'msg': '你好世界'\n});\n\nconst options = {\n  hostname: 'nodejs.cn',\n  port: 80,\n  path: '/upload',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData)\n  }\n};\n\nconst req = http.request(options, (res) => {\n  console.log(`状态码: ${res.statusCode}`);\n  console.log(`响应头: ${JSON.stringify(res.headers)}`);\n  res.setEncoding('utf8');\n  res.on('data', (chunk) => {\n    console.log(`响应主体: ${chunk}`);\n  });\n  res.on('end', () => {\n    console.log('响应中已无数据');\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`请求遇到问题: ${e.message}`);\n});\n\n// 将数据写入请求主体。\nreq.write(postData);\nreq.end();\n```","reference":"参考资料|http://nodejs.cn/api/http.html#http_http_request_url_options_callback","dot":""}]},{"title":"node ClientRequest","fold":true,"list":[{"prefix":"req","tag":".on","suffix":"(event,fn)","desc":"+ abort 当请求被客户端中止时触发。 此事件仅在第一次调用 abort() 时触发。\n+ connect 每次服务器使用 CONNECT 方法响应请求时都会触发\n+ continue 当服务器发送 100 Continue HTTP 响应时触发\n+ information 服务器发送 1xx 中间响应（不包括 101 Upgrade）时触发\n+ response 当收到此请求的响应时触发。 此事件仅触发一次\n+ socket 此事件保证传入 <net.Socket> 类（<stream.Duplex> 的子类）的实例\n+ timeout 当底层套接字因不活动而超时时触发。 这只会通知套接字已空闲。 必须手动中止请求。\n+ upgrade 每次服务器响应升级请求时发出。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".setHeader","suffix":"(key,val)","desc":"为请求头对象设置单个请求头的值。\n`req.getHeader(key)`读取请求中的一个请求头。 该名称不区分大小写。\n`req.removeHeader(key)`移除已定义到请求头对象中的请求头。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".write","suffix":"(chunk,fn)","desc":"发送一个请求主体的数据块。 通过多次调用此方法，可以将请求主体发送到服务器，在这种情况下，建议在创建请求时使用 ['Transfer-Encoding', 'chunked'] 请求头行。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".end","suffix":"([data],fn)","desc":"完成发送请求。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".abort()","suffix":"","desc":"将请求标记为中止。 调用此方法将导致响应中剩余的数据被丢弃并且套接字被销毁。\nrequest.aborted 如果请求已中止，则 request.aborted 属性将会为 true。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".<prop>","suffix":"","desc":"request.path 请求的路径","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".<fn>","suffix":"","desc":"`request.setTimeout(timeout[, callback])`\n`request.setNoDelay([noDelay])`\n`request.setSocketKeepAlive([enable][, initialDelay])` ","url":"","summary":"","reference":"","dot":""}]},{"title":"python","fold":true,"list":[{"prefix":"","tag":"requests","suffix":"","desc":"","url":"","summary":"","reference":"urllib|https://www.liaoxuefeng.com/wiki/1016959663602400/1019223241745024\nrequests|https://www.liaoxuefeng.com/wiki/1016959663602400/1183249464292448","dot":""},{"prefix":"","tag":"make_server","suffix":"","desc":"","url":"https://www.liaoxuefeng.com/wiki/1016959663602400/1017805733037760","summary":"","reference":"","dot":""}]},{"title":"framework","fold":false,"list":[{"prefix":"","tag":"koa","suffix":"","desc":"+ ctx.request  请求对象\n+ ctx.response 响应对象\n+ ctx.cookies.get|set(name,[val]) cookie","url":"","summary":"+ ctx.req Node 的 request 对象.\n+ ctx.res Node 的 response 对象.\n+ ctx.params => router :arg\n+ ctx.query => ?get查询参数数据 (axios通过params发送)\n+ ctx.request.body => post提交数据 （axios通过data发送）\n","reference":"参考资料|https://koa.bootcss.com","dot":""},{"prefix":"","tag":"flask","suffix":"","desc":"","url":"https://dormousehole.readthedocs.io/en/latest/quickstart.html#quickstart","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"TCP","barcolor":"","fold":false,"box":[{"title":"node server","fold":false,"list":[{"prefix":"","tag":"net.createServer","suffix":"(fn(socket))","desc":"创建一个 TCP 服务器\n参数 connectionListener 自动给 'connection' 事件创建监听器。\n`const server = new net.Server([options][, connectionListener])`","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".listen","suffix":"(port)","desc":"启动一个服务器来监听连接","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/net.html#net_server_listen","dot":""},{"prefix":"server","tag":".on","suffix":"(event,fn)","desc":"+ connection (socket) : 当一个新的连接建立的时候触发,socket 是一个 net.Socket 实例.\n+ listening  : 当调用 server.listen() 绑定服务器之后触发。\n+ close :当 server 关闭的时候触发。 如果有连接存在，直到所有的连接结束才会触发这个事件。\n+ error (err) : 当错误出现的时候触发.'close' 事件不会在这个事件触发后继续触发，除非 server.close() 是手动调用.","url":"","summary":"","reference":"","dot":""}]},{"title":"node client","fold":false,"list":[{"prefix":"","tag":"net.connect","suffix":"(port,host,fn)","desc":"返回一个新的 'net.Socket'，并连接到指定的地址和端口。\n当 socket 建立的时候，将会触发 'connect' 事件。\n`const client = net.createConnection(options[, connectListener])` 的别名。","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/net.html#net_net_connect","dot":""}]},{"title":"net.Socket","fold":false,"list":[{"prefix":"","tag":"new net.Socket","suffix":"(opt)","desc":"`socket.connect(port[, host][, connectListener])`\n指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。\n\n`socket.connect(path[, connectListener])`\n打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".on","suffix":"(event,fn)","desc":"+ lookup 在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。\n+ connect 成功建立 socket 连接时触发。\n+ ready 套接字准备好使用时触发,'connect' 后立即触发。\n+ **data** 当接收到数据时触发。\n+ end 当 socket 另一端发送 FIN 包时，触发该事件。\n+ timeout 当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。\n+ drain 当写缓存为空得时候触发。可用来控制上传。\n+ error 错误发生时触发。\n+ close 当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".write","suffix":"(data,fn)","desc":"在 socket 上发送数据\n第二个参数指定了字符串的编码，默认是 UTF8 编码。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket.","tag":"<prop>","suffix":"","desc":"+ socket.bufferSize\n该属性显示了要写入缓冲区的字节数。\n\n+ socket.remoteAddress \n远程的 IP 地址字符串，例如：'74.125.127.100' or '2001:4860:a005::68'。\n+ socket.remoteFamily\n远程IP协议族字符串，比如 'IPv4' or 'IPv6'。\n+ socket.remotePort\n远程端口，数字表示，例如：80 or 21。\n\n+ socket.localAddress\n网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听'0.0.0.0'而客户端连接在'192.168.1.1'，这个值就会是 '192.168.1.1'。\n+ socket.localPort\n本地端口地址，数字表示。例如：80 or 21。\n\n+ socket.bytesRead\n接收到得字节数。\n+ socket.bytesWritten\n发送的字节数。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".<fn>","suffix":"","desc":"+ socket.setEncoding([encoding])\n设置编码\n+ socket.write(data[, encoding][, callback])\n在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。\n+ socket.end([data][, encoding])\n半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。\n+ socket.destroy()\n确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。\n+ socket.pause()\n暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。\n+ socket.resume()\n调用 pause() 后想恢复读取数据。\n+ socket.setTimeout(timeout[, callback])\nsocket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。\n+ socket.setNoDelay([noDelay])\n禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。\n+ socket.setKeepAlive([enable][, initialDelay])\n禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.\n+ socket.address()\n操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: 'IPv4', address: '127.0.0.1' }。\n+ socket.unref()\n如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。\n+ socket.ref()\n与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。","url":"","summary":"","reference":"","dot":""}]},{"title":"python socket","fold":false,"list":[{"prefix":"","tag":"socket.socket","suffix":"(socket.AF_INET, socket.SOCK_STREAM)","desc":"导入socket库:\n`import socket`\n创建一个socket:\n`s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`\n\n\n创建Socket时，AF\\_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6","url":"","summary":"","reference":"参考资料|https://www.runoob.com/python3/python3-socket.html","dot":""},{"prefix":"s","tag":".connect","suffix":"((host,port))","desc":"建立连接:\n`s.connect(('www.abc.com', 80))`\n注意参数是一个tuple，包含地址和端口号。","url":"","summary":"","reference":"","dot":""},{"prefix":"s","tag":".send","suffix":"(data)","desc":"发送数据","url":"","summary":"","reference":"","dot":""},{"prefix":"s","tag":".recv","suffix":"(max)","desc":"接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。\n```\n# 接收数据:\nbuffer = []\nwhile True:\n    # 每次最多接收1k字节:\n    d = s.recv(1024)\n    if d:\n        buffer.append(d)\n    else:\n        break\ndata = b''.join(buffer)\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"s.","tag":"close()","suffix":"","desc":"关闭连接","url":"","summary":"","reference":"","dot":""}]},{"title":"python server","fold":false,"list":[{"prefix":"s","tag":".bind","suffix":"((host,port))","desc":"监听端口`s.bind(('127.0.0.1', 9999))`","url":"","summary":"","reference":"","dot":""},{"prefix":"s","tag":".listen","suffix":"(max)","desc":"调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量\n```\ns.listen(5)\nprint('Waiting for connection...')\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"s.","tag":"accept()","suffix":"","desc":"服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:\n```\nwhile True:\n    # 接受一个新连接:\n    sock, addr = s.accept()\n    # 创建新线程来处理TCP连接:\n    t = threading.Thread(target=tcplink, args=(sock, addr))\n    t.start()\n```","url":"","summary":"每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：\n```\ndef tcplink(sock, addr):\n    print('Accept new connection from %s:%s...' % addr)\n    sock.send(b'Welcome!')\n    while True:\n        data = sock.recv(1024)\n        time.sleep(1)\n        if not data or data.decode('utf-8') == 'exit':\n            break\n        sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8'))\n    sock.close()\n    print('Connection from %s:%s closed.' % addr)\n```","reference":"","dot":""}]}]},{"title":"MQ","barcolor":"","fold":false,"box":[{"title":"RabbitMQ","fold":false,"list":[{"prefix":"","tag":"install","suffix":"","desc":"```\ndocker run -d --name rabbitmq \\\n  -p 5672:5672 \\\n  -p 15672:15672 \\\n  -e RABBITMQ_DEFAULT_USER=username \\\n  -e RABBITMQ_DEFAULT_PASS=password \\\n  -v /var/log/rabbitmq:/var/log/rabbitmq \\\n  -e RABBITMQ_LOGS=/var/log/rabbitmq/rabbitmq.log \\\n  -e RABBITMQ_LOGS_ROTATE_INTERVAL=86400 \\\n  -e RABBITMQ_LOGS_ROTATE_COUNT=7 \\\n  rabbitmq:latest\n\n```","url":"","summary":"mac日志地址配置/Users/iruxu/logs/rabbitmq","reference":"","dot":""},{"prefix":"","tag":"conf","suffix":"","desc":"/etc/rabbitmq/rabbitmq.conf","url":"","summary":"log.rotate_on_size = 100000000\nlog.file.count = 5\n# log.file.path = /var/log/my-rabbitmq/rabbitmq.log","reference":"","dot":""},{"prefix":"","tag":"init","suffix":"","desc":"```\nsudo rabbitmqctl add_user myuser mypassword\nsudo rabbitmqctl set_permissions -p / myuser \"myqueue\" \".*\" \".*\"\n```","url":"","summary":"rabbitmqctl set_user_tags myuser administrator","reference":"","dot":""}]}]}]},{"column":[{"title":"UDP","barcolor":"","fold":false,"box":[{"title":"node dgram","fold":false,"list":[{"prefix":"","tag":"dgram.createSocket","suffix":"('udp4|6')","desc":"创建一个 dgram.Socket 对象\ncallback <Function> 为 'message' 事件绑定一个监听器。","url":"","summary":"# server\n```\n// 例子：UDP服务端\nvar PORT = 33333;\nvar HOST = '127.0.0.1';\n\nvar dgram = require('dgram');\nvar server = dgram.createSocket('udp4');\n\nserver.on('listening', function () {\n    var address = server.address();\n    console.log('UDP Server listening on ' + address.address + \":\" + address.port);\n});\n\nserver.on('message', function (message, remote) {\n    console.log(remote.address + ':' + remote.port +' - ' + message);\n});\n\nserver.bind(PORT, HOST);\n```\n# 客户端\n```\n// 例子：UDP客户端\nvar PORT = 33333;\nvar HOST = '127.0.0.1';\n\nvar dgram = require('dgram');\nvar message = Buffer.from('My KungFu is Good!');\n\nvar client = dgram.createSocket('udp4');\n\nclient.send(message, PORT, HOST, function(err, bytes) {\n    if (err) throw err;\n    console.log('UDP message sent to ' + HOST +':'+ PORT);\n    client.close();\n});\n```","reference":"","dot":""},{"prefix":"socket","tag":".bind","suffix":"(port)","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".on","suffix":"(event,fn)","desc":"+ listening\n当一个 socket 开始监听数据包信息时， 'listening' 事件将被触发。 该事件会在创建 UDP socket 之后被立即触发。\n+ **message**\n当有新的数据包被 socket 接收时， 'message' 事件会被触发。msg 和 rinfo 会作为参数传递到该事件的处理函数中。\n+ connect\n因 connect() 调用成功而使 socket 与远程地址关联之后，则会触发 'connect' 事件。\n+ close \n'close' 事件将在使用 close() 关闭一个 socket 之后触发。 该事件一旦触发，则这个 socket 上将不会触发新的 'message' 事件。\n+ error\n当有任何错误发生时， 'error' 事件将被触发。 事件发生时，事件处理函数仅会接收到一个 Error 对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".send","suffix":"(msg,[port,host],fn)","desc":"在 socket 上广播一个数据包","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".setBroadcast","suffix":"(flag)","desc":"设置或清除 SO_BROADCAST socket 选项。 当设置为 true, UDP 包可能会被发送到一个本地接口的广播地址。","url":"","summary":"```\nvar dgram = require('dgram');\nvar client = dgram.createSocket('udp4');\nvar msg = Buffer.from('hello world');\nvar port = 33333;\nvar host = '255.255.255.255';\n\nclient.bind(function(){\n    client.setBroadcast(true);\n    client.send(msg, port, host, function(err){\n        if(err) throw err;\n        console.log('msg has been sent');\n        client.close();\n    });\n});\n```","reference":"参考资料|https://segmentfault.com/a/1190000013092163","dot":""}]},{"title":"python dgram","fold":false,"list":[{"prefix":"","tag":"socket.socket","suffix":"(socket.AF_INET, socket.SOCK_DGRAM)","desc":"`s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)`\n不需要调用listen()方法，而是直接接收来自任何客户端的数据","url":"","summary":"","reference":"参考资料|https://www.liaoxuefeng.com/wiki/1016959663602400/1017790181885952","dot":""},{"prefix":"s","tag":".bind","suffix":"((host,port))","desc":"绑定端口","url":"","summary":"","reference":"","dot":""},{"prefix":"s.","tag":"sendto","suffix":"(data)","desc":"服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端\n客户端也不需要调用connect()，直接通过sendto()给服务器发数据","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"IP","barcolor":"","fold":false,"box":[{"title":"node","fold":false,"list":[{"prefix":"","tag":"net.isIP","suffix":"(val)","desc":"测试输入是否是 IP 地址。\n+ 无效的字符串则返回 0\n+ IPv4 地址则返回 4\n+ IPv6 的地址则返回 6","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"net.isIPv4","suffix":"(val)","desc":"如果输入是 IPv4 地址则返回 true，否则返回 false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"net.isIPv6","suffix":"(val)","desc":"如果输入是 IPv6 地址则返回 true，否则返回 false","url":"","summary":"","reference":"","dot":""}]}]},{"title":"URL","barcolor":"","fold":false,"box":[{"title":"url","fold":false,"list":[{"prefix":"","tag":"new URL","suffix":"(path,base)","desc":"生成URL\nurl.hash\nurl.host\nurl.hostname\nurl.href\nurl.origin\nurl.password\nurl.pathname\nurl.port\nurl.protocol\nurl.search\nurl.searchParams\nurl.username\nurl.toString()","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"new URLSearchParams","suffix":"(val)","desc":"生成字符串查询对象,只读\nurlSearchParams.append(name, value)\nurlSearchParams.delete(name)\nurlSearchParams.entries()\nurlSearchParams.forEach(fn[, thisArg])\nurlSearchParams.get(name)\nurlSearchParams.getAll(name)\nurlSearchParams.has(name)\nurlSearchParams.keys()\nurlSearchParams.set(name, value)\nurlSearchParams.sort()\nurlSearchParams.toString()\nurlSearchParams.values()\nurlSearchParams[Symbol.iterator]()","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"url.domainToASCII","suffix":"(domain)","desc":"域名编码 `url.domainToASCII(domain)`\n域名解码 `url.domainToUnicode(domain)`\n返回 Punycode ASCII 序列化的 domain。 如果 domain 是无效域名，则返回空字符串。\n```\nconsole.log(url.domainToASCII('中文.com'));\n// 打印 xn--fiq228c.com\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"url.pathToFileURL","suffix":"(path)","desc":"文件路径编码 `url.pathToFileURL(path)`\n文件路径解码 `url.fileURLToPath(url)`\n此方法保证百分号编码字符解码结果的正确性，同时也确保绝对路径字符串在不同平台下的有效性。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Spider","barcolor":"","fold":false,"box":[{"title":"python","fold":false,"list":[{"prefix":"","tag":"HTMLParser","suffix":"","desc":"https://www.liaoxuefeng.com/wiki/1016959663602400/1017784593019776","url":"","summary":"","reference":"","dot":""}]}]}]}]}