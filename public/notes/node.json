{"version":1584764487902,"name":"git","data":[{"column":[{"title":"Buffer","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"","tag":"Buffer.from","suffix":"(str,encoding)","desc":"Buffer 实例也是 Uint8Array 实例，长度1为1个字节（8位）\n+ Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）\n+ Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n+ Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例\n+ Buffer.from(object[, offsetOrEncoding[, length]]) 对于对象的valueOf()返回值\n+ Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例\n+ Buffer.from(path)：从文件内容返回","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Buffer.alloc","suffix":"(size)","desc":"+ Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0\n+ Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据\n+ Buffer.allocUnsafeSlow(size)","url":"","summary":"","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"buf","tag":"[i]","suffix":"","desc":"获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".length","suffix":"","desc":"返回 Buffer 对象所占据的内存长度。(字节数）\n`Buffer.byteLength(buf)`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"<encoding>","suffix":"","desc":"# nodejs默认内置字符编码\n+ ascii \n仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n+ utf-8\n多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n+ hex \n将每个字节编码为两个十六进制字符（1字节=8位=2个4位,2^4=16）\n+ base64\nMIME编码的一种\n+ latin1/binary \n一种把 Buffer 编码成一字节编码的字符串的方式,ISO-8859-1的别名\n+ utf16le/ucs2 \n2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。","url":"","summary":"# ascii\n作用：表语英语及西欧语言。\n位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。\n范围：ASCII从00到7F，扩展从00到FF\n# iso8859-1\n作用：扩展ASCII，表示西欧、希腊语等。\n位数：8位\n范围：从00到FF，兼容ASCII字符集\n# GB2312字符集\n作用：国家简体中文字符集，兼容ASCII。\n位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。\n范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码。\n# GBK字符集\n作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。\n位数：使用2个字节表示，可表示21886个字符。\n范围：高字节从81到FE，低字节从40到FE。\n# BIG5字符集\n作用：它解决了中文、日文、朝鲜语等的编码，兼容GBK。\n位数：它采用变字节表示(1 ASCII，2，4字节)。可表示27484个文字。\n范围：1字节从00到7F; 2字节高字节从81到FE，低字节从40到7E和80到FE；4字节第一三字节从81到FE，第二四字节从30到39。\n# UTF-8/UTF-32/UTF-16/UTF-7\n作用：为世界650种语言进行统一编码，兼容ISO-8859-1。\n位数：UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16和UTF-32。","reference":"参考资料1|https://www.cnblogs.com/happyday56/p/4135845.html\n参考资料2|https://dailc.github.io/2017/06/03/utf8ToUtf16ToGbk.html","dot":""},{"prefix":"buf","tag":".toString","suffix":"([encoding])","desc":"解码缓冲区数据并使用指定的编码返回字符串。\n`buf.toString([encoding[, start[, end]]])`\nencoding - 使用的编码。默认为 'utf8' 。\nstart - 指定开始读取的索引位置，默认为 0。\nend - 结束位置，默认为缓冲区的末尾。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"iconv-lite","suffix":"","desc":"包括gbk在内的更多编码支持\n```javascript\nvar iconv = require('iconv-lite');\n \n// Convert from an encoded buffer to js string.\nstr = iconv.decode(Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]), 'win1251');\n \n// Convert from js string to an encoded buffer.\nbuf = iconv.encode(\"Sample input string\", 'win1251');\n \n// Check if encoding is supported\niconv.encodingExists(\"us-ascii\")\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/iconv-lite","dot":""}]},{"title":"操作","fold":false,"list":[{"prefix":"buf","tag":".write","suffix":"(str)","desc":"返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n`buf.write(string[, offset[, length]][, encoding])`\nstring - 写入缓冲区的字符串。\noffset - 缓冲区开始写入的索引值，默认为 0 。\nlength - 写入的字节数，默认为 buffer.length\nencoding - 使用的编码。默认为 'utf8' 。","url":"","summary":"buf.writeBigInt64BE(value[, offset])\nbuf.writeBigInt64LE(value[, offset])\nbuf.writeBigUInt64BE(value[, offset])\nbuf.writeBigUInt64LE(value[, offset])\nbuf.writeDoubleBE(value[, offset])\nbuf.writeDoubleLE(value[, offset])\nbuf.writeFloatBE(value[, offset])\nbuf.writeFloatLE(value[, offset])\nbuf.writeInt8(value[, offset])\nbuf.writeInt16BE(value[, offset])\nbuf.writeInt16LE(value[, offset])\nbuf.writeInt32BE(value[, offset])\nbuf.writeInt32LE(value[, offset])\nbuf.writeIntBE(value, offset, byteLength)\nbuf.writeIntLE(value, offset, byteLength)\nbuf.writeUInt8(value[, offset])\nbuf.writeUInt16BE(value[, offset])\nbuf.writeUInt16LE(value[, offset])\nbuf.writeUInt32BE(value[, offset])\nbuf.writeUInt32LE(value[, offset])\nbuf.writeUIntBE(value, offset, byteLength)\nbuf.writeUIntLE(value, offset, byteLength)","reference":"","dot":""},{"prefix":"","tag":"Buffer.concat","suffix":"([buf1,buf2,..])","desc":"缓冲区合并,返回一个多个成员合并的新 Buffer 对象。\n`Buffer.concat(list[, totalLength])`\nlist - 用于合并的 Buffer 对象数组列表。\ntotalLength - 指定合并后Buffer对象的总长度。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".slice","suffix":"(start,[end])","desc":"`buf.slice([start[, end]])`\n返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".copy","suffix":"(buf2)","desc":"`buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])`\n缓冲区拷贝,没有返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".compare","suffix":"(buf2)","desc":"比较两个buffer，返回一个数字，表示 buf 在 otherBuffer 之前(<0)，之后或相同\n`buf.equals(otherBuffer)` 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".fill","suffix":"(val)","desc":"`buf.fill(value[, offset][, end])`\n使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"events","barcolor":"","fold":false,"box":[{"title":"创建实例","fold":false,"list":[{"prefix":"","tag":"new events.EventEmitter()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"添加监听","fold":false,"list":[{"prefix":"emitter","tag":".addListener","suffix":"(evt,fn)","desc":"为指定事件添加一个监听器到监听器数组的尾部。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".on","suffix":"(evt,fn)","desc":"为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数\n不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 与 listener 会导致 listener 会被添加多次。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependListener","suffix":"(evt,fn)","desc":"添加 listener 函数到名为 eventName 的事件的监听器数组的开头。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".once","suffix":"(evt,fn)","desc":"为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependOnceListener","suffix":"(evt,fn)","desc":"添加单次监听器 listener 到名为 eventName 的事件的监听器数组的开头。 \n当 eventName 事件下次触发时，监听器会先被移除，然后再调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"newListener","suffix":",fn)","desc":"实例在新的监听器被添加到其内部监听器数组之前，会触发自身的 'newListener' 事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"移除监听","fold":false,"list":[{"prefix":"emitter","tag":".removeListener","suffix":"(evt,fn)","desc":"移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。\n最多只会从监听器数组中移除一个监听器。 如果监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener() 才能移除所有实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".off","suffix":"(evt,fn)","desc":"emitter.removeListener() 的别名。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".removeAllListeners","suffix":"([evt])","desc":"移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"removeListener","suffix":",fn)","desc":"'removeListener' 事件在 listener 被移除后触发。","url":"","summary":"","reference":"","dot":""}]},{"title":"触发事件","fold":false,"list":[{"prefix":"emitter","tag":".emit","suffix":"(evt,args..)","desc":"按监听器的顺序执行执行每个监听器\n如果事件有注册监听返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"error","suffix":",fn)","desc":"我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"emitter","tag":".eventNames()","suffix":"","desc":"返回已注册监听器的事件名数组。 数组中的值为字符串或 Symbol。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listeners","suffix":"(evt)","desc":"返回指定事件的监听器数组。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listenerCount","suffix":"(evt)","desc":"返回正在监听的名为 eventName 的事件的监听器的数量。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".setMaxListeners","suffix":"(n)","desc":"默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 \nsetMaxListeners 函数用于提高监听器的默认限制的数量。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"struct","fold":false,"list":[{"prefix":"","tag":"struct.pack","suffix":"(flag,data)","desc":"把任意数据类型变成bytes","url":"","summary":"","reference":"参考资料|https://www.liaoxuefeng.com/wiki/1016959663602400/1017685387246080","dot":"","title":"python"},{"prefix":"","tag":"struct.unpack","suffix":"(flag,bytes)","desc":"把bytes变成相应的数据类型","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"stream","barcolor":"","fold":false,"box":[{"title":"管道全自动","fold":false,"list":[{"prefix":"rs","tag":".pipe","suffix":"(ws,[{end:false}])","desc":"绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。 数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。\n**返回:目标流的引用**\n默认情况下，当来源可读流触发 'end' 事件时，目标可写流也会调用 stream.end() 结束写入。 若要禁用这种默认行为， end 选项应设为 false，这样目标流就会保持打开\n```\nreader.pipe(writer, { end: false });\nreader.on('end', () => {\n  writer.end('结束');\n});\n```\n如果可读流在处理期间发送错误，则可写流目标不会自动关闭。 如果发生错误，则需要手动关闭每个流以防止内存泄漏。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"pipe","suffix":",fn(rs))","desc":"当在可读流上调用 stream.pipe() 方法时会发出 'pipe' 事件，并将此可写流添加到其目标集","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".unpipe","suffix":"([ws])","desc":"解绑之前使用 stream.pipe() 方法绑定的可写流\n如果没有指定 destination, 则解绑所有管道\n如果指定了 destination, 但它没有建立管道，则不起作用","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"unpipe","suffix":",fn)","desc":"在可读流上调用 stream.unpipe() 方法时会发出 'unpipe'事件，从其目标集中移除此可写流。\n当可读流通过管道流向可写流发生错误时，也会触发此事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"s","tag":".destroy","suffix":"([error])","desc":"销毁流","url":"","summary":"","reference":"","dot":""},{"prefix":"s.on(","tag":"close","suffix":",fn)","desc":"当流或其底层资源（比如文件描述符）被关闭时触发 'close' 事件。 \n该事件表明不会再触发其他事件，也不会再发生操作。","url":"","summary":"","reference":"","dot":""},{"prefix":"s.on(","tag":"error","suffix":",fn)","desc":"发生错误时","url":"","summary":"","reference":"","dot":""}]}]},{"title":"stream.Transform","barcolor":"","fold":false,"box":[{"title":"自定义","fold":false,"list":[{"prefix":"ts = ","tag":"new stream.Transform","suffix":"","desc":"转换流是一种双工流，它会对输入做些计算然后输出。\n```\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"ts","tag":"._transform","suffix":"(chunk,encoding,done)","desc":"将读入的chunk进行操作后，最后传递给push。`this.push(newChunk)`\n_transform的回调函数，第一参数可为err，第2个参数将传递给push。\n","url":"","summary":"该方法是用于接受输入并产生输出的一个中转站，该方法内部实现对写入的字节进行操作，然后计算出一个输出，最后将输出使用readable.push()方法传递给可读流。\ncallback函数必须在当前块完全消耗完毕之后调用，如果在处理输入的时候发生错误的时候回调的第一个参数必须是一个Error对象，否则是一个null。如果回调有第二个参数的话，它将会转发给readable.push()。\n```\nconst { Transform } = require(\"stream\");\nclass myTransform extends Transform {\n    constructor(options) {\n        super(options);\n    }\n    _transform(chunk, encoding, done) {\n        const upperChunk = chunk.toString().toUpperCase();\n        this.push(upperChunk);\n        done();\n    }\n    _flush(done) {\n        // this.push(\"end\\n\");\n        done();\n    }\n}\n```","reference":"参考资料|https://juejin.im/entry/59b5539af265da066c22e28a","dot":""},{"prefix":"ts","tag":"._flush","suffix":"(done)","desc":"收尾处理，在finish之前执行。\n_flush的回调函数，第一个参数可为null，第2个参数将传递给push。","url":"","summary":"\n","reference":"","dot":""}]}]},{"title":"stream.Readable","barcolor":"","fold":false,"box":[{"title":"stream.Readable","fold":false,"list":[{"prefix":"rs","tag":".readableFlowing","suffix":"","desc":"+ null 没有提供消费流数据的机制，所以流不会产生数据\n+ false 数据可能会堆积在流的内部缓冲中\n+ true ","url":"","summary":"# 两种模式\n可读流运作于两种模式之一：流动模式（flowing）或暂停模式（paused）。 这些模式与对象模式分开。 无论是否处于流动模式或暂停模式，可读流都可以处于对象模式。\n在流动模式中，数据自动从底层系统读取，并通过 EventEmitter 接口的事件尽可能快地被提供给应用程序。\n在暂停模式中，必须显式调用 stream.read() 读取数据块。\n# 模式切换\n所有可读流都开始于暂停模式\n*切换到流动模式*：\n+ 添加 'data' 事件句柄。\n+ 调用 stream.resume() 方法。\n+ 调用 stream.pipe() 方法将数据发送到可写流。\n\n*切换回暂停模式*：\n+ 如果没有管道目标，则调用 stream.pause()。\n+ 如果有管道目标，则移除所有管道目标。调用 stream.unpipe() 可以移除多个管道目标。\n# 补充说明\n只有提供了消费或忽略数据的机制后，可读流才会产生数据。 如果消费的机制被禁用或移除，则可读流会停止产生数据。\n\n为了向后兼容，移除 'data' 事件句柄不会自动地暂停流。 如果有管道目标，一旦目标变为 drain 状态并请求接收数据时，则调用 stream.pause() 也不能保证流会保持暂停模式。\n\n如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。 例如，当调用 readable.resume() 时，没有监听 'data' 事件或 'data' 事件句柄已移除。\n\n添加 'readable' 事件句柄会使流自动停止流动，并通过 readable.read() 消费数据。 如果 'readable' 事件句柄被移除，且存在 'data' 事件句柄，则流会再次开始流动。","reference":"","dot":""},{"prefix":"rs","tag":".setEncoding","suffix":"(encoding)","desc":"为从可读流读取的数据设置字符编码\n默认情况下没有设置字符编码，流数据返回的是 Buffer 对象。 如果设置了字符编码，则流数据返回指定编码的字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".readableHighWaterMark","suffix":"","desc":"默认16KB","url":"","summary":"","reference":"","dot":""}]},{"title":"纯手动","fold":false,"list":[{"prefix":"rs.on(","tag":"readable","suffix":",fn)","desc":"当有数据可从流中读取时，就会触发 'readable' 事件。 \n在某些情况下，为 'readable' 事件附加监听器将会导致将一些数据读入内部缓冲区\n```\nreadable.on('readable', function() {\n  // 有数据可读取。\n  let data;\n\n  while (data = this.read()) {\n    console.log(data);\n  }\n});\n```","url":"","summary":"当到达流数据的尽头时， 'readable' 事件也会触发，但是在 'end' 事件之前触发。\n'readable' 事件表明流有新的动态：要么有新的数据，要么到达流的尽头。 对于前者，stream.read() 会返回可用的数据。 对于后者，stream.read() 会返回 null。","reference":"","dot":""},{"prefix":"rs","tag":".read","suffix":"([size])","desc":"从内部缓冲拉取并返回数据。size指定要读取的数据的字节数。\n如果没有可读的数据，则返回 null。 \n默认情况下， readable.read() 返回的数据是 Buffer 对象，除非使用 readable.setEncoding() 指定字符编码或流处于对象模式。\n```\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(`接收到 ${chunk.length} 字节的数据`);\n  }\n});\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"可调节","fold":false,"list":[{"prefix":"rs.on(","tag":"data","suffix":",fn(chunk))","desc":"当流将数据块传送给消费者后触发\n将 'data' 事件监听器附加到尚未显式暂停的流将会使流切换为流动模式。 数据将会在可用时立即传递。\n```\nreadable.on('data', (chunk) => {\n  console.log(`接收到 ${chunk.length} 个字节的数据`);\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".pause()","suffix":"","desc":"使流动模式的流停止触发 'data' 事件，并切换出流动模式。\n任何可用的数据都会保留在内部缓存中。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs.on(","tag":"pause","suffix":",fn)","desc":"当调用 stream.pause() 并且 readsFlowing 不为 false 时，就会触发 'pause' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".resume()","suffix":"","desc":"将被暂停的可读流恢复触发 'data' 事件，并将流切换到流动模式。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs.on(","tag":"resume","suffix":",fn)","desc":"当调用 stream.resume() 并且 readsFlowing 不为 true 时，将会触发 'resume' 事件","url":"","summary":"","reference":"","dot":""}]},{"title":"读取完毕","fold":false,"list":[{"prefix":"rs.on(","tag":"end","suffix":",fn)","desc":"当流中没有数据可供消费时触发。\n'end' 事件只有在数据被完全消费掉后才会触发。 ","url":"","summary":"","reference":"","dot":""}]},{"title":"自定义","fold":false,"list":[{"prefix":"rs = ","tag":"new stream.Readable","suffix":"","desc":"创建一个readable流\n```\nconst { Readable } = require('stream');\n\nconst myReadable = new Readable({\n  read(size) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/stream.html#stream_new_stream_readable_options","dot":""},{"prefix":"rs","tag":"._read","suffix":"([size])","desc":"自定义按需读取","url":"","summary":"","reference":"参考资料|https://github.com/jabez128/stream-handbook","dot":""},{"prefix":"rs","tag":".push","suffix":"(chunk,[encoding])","desc":"当 chunk 是 Buffer、 Uint8Array 或 string 时， chunk 的数据会被添加到内部队列中供流消费。 \n在没有数据可写入后，给 chunk 传入 **null** 表示流的结束（EOF）。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"stream.Readable.from","suffix":"(ite)","desc":"一个从迭代器中创建可读流的实用方法","url":"","summary":"```\nconst { Readable } = require('stream');\n\nasync function * generate() {\n  yield 'hello';\n  yield 'streams';\n}\n\nconst readable = Readable.from(generate());\n\nreadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n```","reference":"","dot":""}]}]},{"title":"stream.Writable","barcolor":"","fold":false,"box":[{"title":"stream.Writable","fold":false,"list":[{"prefix":"ws","tag":".setDefaultEncoding","suffix":"(encoding)","desc":"为可写流设置默认的 encoding","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".writableHighWaterMark","suffix":"","desc":"默认16KB","url":"","summary":"","reference":"","dot":""}]},{"title":"写入中","fold":false,"list":[{"prefix":"ws","tag":".write","suffix":"(chunk,[encoding,callback])","desc":"`writable.write(chunk[, encoding][, callback])`\n写入数据到流，并在数据被完全处理之后调用 callback。 \n在接收了 chunk 后，如果内部的缓冲小于创建流时配置的 highWaterMark，则返回 true 。 如果返回 false ，则应该停止向流写入数据，直到 'drain' 事件被触发。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"drain","suffix":",fn)","desc":"writable.write(chunk)返回false以后，当缓存数据全部写入完成，可以继续写入时，会触发drain事件，表示缓存空了。","url":"","summary":"","reference":"","dot":""}]},{"title":"写入完","fold":false,"list":[{"prefix":"ws","tag":".end","suffix":"([chunk,encoding,callback])","desc":"`writable.end([chunk[, encoding]][, callback])`\n表明已没有数据要被写入可写流。 \n可选的 chunk 和 encoding 参数可以在关闭流之前再写入一块数据。 \n如果传入了 callback 函数，则会做为监听器添加到 'finish' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"finish","suffix":",fn)","desc":"缓冲数据都已传给底层系统之后触发","url":"","summary":"","reference":"","dot":""}]},{"title":"自定义","fold":false,"list":[{"prefix":"ws = ","tag":"new stream.Writable","suffix":"","desc":"创建一个可写流\n```\nconst { Writable } = require('stream');\n\nconst myWritable = new Writable({\n  write(chunk, encoding, callback) {\n    // ...\n  },\n  writev(chunks, callback) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/stream.html#stream_constructor_new_stream_writable_options","dot":""},{"prefix":"ws","tag":"._write","suffix":"(chunk,encoding,callback)","desc":"所有可写流的实现必须提供 writable.\\_write() 和/或 writable.\\_writev() 方法将数据发送到底层资源。\n`writable._writev(chunks, callback)` 一次处理多个数据块","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":"._final","suffix":"(callback)","desc":"当结束写入所有剩余数据时的回调函数\n该方法会在流关闭之前被调用，且在 callback 被调用后触发 'finish' 事件。 主要用于在流结束之前关闭资源或写入缓冲的数据。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"path","barcolor":"","fold":false,"box":[{"title":"全局变量","fold":false,"list":[{"prefix":"","tag":"__filename","suffix":"","desc":"指向当前运行的脚本文件名","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__dirname","suffix":"","desc":"指向当前运行的脚本所在的目录","url":"","summary":"","reference":"","dot":""}]},{"title":"生成","fold":false,"list":[{"prefix":"path","tag":".resolve","suffix":"([...paths])","desc":"将路径或路径片段的序列解析为绝对路径","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".join","suffix":"([...paths])","desc":"使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。","url":"","summary":"零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 '.'，表示当前工作目录","reference":"","dot":""},{"prefix":"path","tag":".normalize","suffix":"(path)","desc":"规范化给定的 path","url":"","summary":"","reference":"","dot":""}]},{"title":"分析","fold":false,"list":[{"prefix":"path","tag":".parse","suffix":"(path)","desc":"返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略，\n```\npath.parse('/home/user/dir/file.txt');\n// 返回:\n// { root: '/',\n//   dir: '/home/user/dir',\n//   base: 'file.txt',\n//   ext: '.txt',\n//   name: 'file' \n```","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".format","suffix":"(obj)","desc":"从对象返回路径字符串,path逆方法\ndir和root只需一个\nbase和name+ext只需一个","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/path.html#path_path_format_pathobject","dot":""},{"prefix":"path","tag":".isAbsolute","suffix":"(path)","desc":"检测 path 是否为绝对路径。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".relative","suffix":"(from, to)","desc":"根据当前工作目录返回 from 到 to 的相对路径。 ","url":"","summary":"","reference":"","dot":""}]},{"title":"信息","fold":false,"list":[{"prefix":"path","tag":".dirname","suffix":"(path)","desc":"返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略\n```\npath.dirname('/foo/bar/baz/asdf/quux');\n// 返回: '/foo/bar/baz/asdf'\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".basename","suffix":"(path,[ext])","desc":"返回 path 的最后一部分，类似于 Unix 的 basename 命令。\n尾部的目录分隔符将被忽略\n```javascript\npath.basename('/foo/bar/baz/asdf/quux.html');\n// 返回: 'quux.html'\npath.basename('/foo/bar/baz/asdf/quux.html', '.html');\n// 返回: 'quux'\n```","url":"","summary":"","reference":"","dot":"","title":"其它"},{"prefix":"path","tag":".extname","suffix":"(path)","desc":"返回 path 的扩展名\n从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 path.basename()）除了第一个字符以外没有 .，则返回空字符串。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"path","tag":".delimiter","suffix":"","desc":"提供平台特定的路径定界符：\n; 用于 Windows\n: 用于 POSIX","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".sep","suffix":"","desc":"提供平台特定的路径片段分隔符：\nWindows 上是 \\。\nPOSIX 上是 /。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".win32","suffix":"","desc":"提供对特定于 Windows 的 path 方法的实现的访问。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".posix","suffix":"","desc":"提供对 path 方法的 POSIX 特定实现的访问","url":"","summary":"","reference":"","dot":""}]}]},{"title":"目录","barcolor":"","fold":false,"box":[{"title":"检查","fold":false,"list":[{"prefix":"fs","tag":".existsSync","suffix":"(path)","desc":"如果路径存在，则返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""}]},{"title":"移动","fold":false,"list":[{"prefix":"fse","tag":".move","suffix":"(src,dest,fn)","desc":"移动内容，默认不覆盖\n```\nfs.move(srcpath, dstpath)\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/move.md","summary":"","reference":"","dot":""}]},{"title":"创建","fold":false,"list":[{"prefix":"fs","tag":".mkdir","suffix":"(path,fn)","desc":"创建目录,如已存在会失败\n同步方法：`fs.mkdirSync(path[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_mkdir_path_options_callback","dot":""},{"prefix":"fs","tag":".mkdtemp","suffix":"(prefix,fn)","desc":"创建一个唯一的临时目录。\n同步方法：`fs.mkdtempSync(prefix[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_mkdtemp_prefix_options_callback","dot":""}]},{"title":"删除","fold":false,"list":[{"prefix":"fs","tag":".rmdir","suffix":"(path,[opt],fn)","desc":"删除目录\n同步方法：`fs.rmdirSync(path[, options])`\nopt.recursive 如果为 true，则执行递归的目录删除。在递归模式中，如果 path 不存在则不报告错误，并且在失败时重试操作。默认值: false。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_rmdir_path_options_callback","dot":""},{"prefix":"fse","tag":".remove","suffix":"(path)","desc":"递归删除文件和目录\n```\nfs.remove('/tmp/myfile')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/remove.md","summary":"","reference":"","dot":""},{"prefix":"fse","tag":".emptyDir","suffix":"(dir)","desc":"递归清空目录\n```\nfs.emptyDir('/tmp/some/dir')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"fs","tag":".readdir","suffix":"(path,fn)","desc":"读取目录的内容\n同步方法：`fs.readdirSync(path[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_readdir_path_options_callback","dot":""},{"prefix":"fs","tag":".opendir","suffix":"(path,fn)","desc":"打开目录\n同步方法：`fs.opendirSync(path[, options])`","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_opendir_path_options_callback","dot":""},{"prefix":"","tag":"glob","suffix":"(**/*.js,fn(err,files))","desc":"选择glob规则指定文件\n```\nvar glob = require(\"glob\")\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n})\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/glob","dot":""}]}]},{"title":"zlib","barcolor":"","fold":false,"box":[{"title":"zlib","fold":false,"list":[{"prefix":"","tag":"compressing","suffix":"","desc":"","url":"https://github.com/node-modules/compressing","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"fs","barcolor":"","fold":false,"box":[{"title":"读取","fold":false,"list":[{"prefix":"fs","tag":".createReadStream","suffix":"(path,opt)","desc":"按流读取，highWaterMark为64KB。","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_createreadstream_path_options","dot":""},{"prefix":"fs","tag":".readFile","suffix":"(path,encoding,fn)","desc":"异步地读取文件的全部内容。（会缓冲整个文件）\n同步方法： `fs.readFileSync(path,opt);`\n","url":"","summary":"+ path：可以为文件名或文件描述符\n+ encoding：如果没有指定 encoding，则返回原始的 buffer。\n```\nfs.readFile('/etc/passwd', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n```","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback","dot":""},{"prefix":"fs","tag":".copyFile","suffix":"(src,dest,fn)","desc":"复制文件。如果已存在，则覆盖它。\n同步方法：`fs.copyFileSync(src, dest[, flags])`","url":"","summary":"","reference":"","dot":""},{"prefix":"fse","tag":".copy","suffix":"(src,dest)","desc":"递归拷贝\n```\nconst fs = require('fs-extra')\nfs.copy('/tmp/myfile', '/tmp/mynewfile')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/copy.md","summary":"","reference":"","dot":""}]},{"title":"写入","fold":false,"list":[{"prefix":"fs","tag":".createWriteStream","suffix":"(path,opt)","desc":"创建可写流","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options","dot":""},{"prefix":"fs","tag":".writeFile","suffix":"(file,data,fn)","desc":"异步地将数据写入到一个文件，如果文件已存在则覆盖该文件。\n同步方法：`fs.writeFileSync(file, data[, options])`","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback","dot":""},{"prefix":"fs","tag":".appendFile","suffix":"(path,data,fn)","desc":"异步地将数据追加到文件，如果文件尚不存在则创建该文件。data 可以是字符串或 Buffer。\n同步方法：`fs.appendFileSync(path, data[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_appendfile_path_data_options_callback","dot":""},{"prefix":"fse","tag":".outputFile","suffix":"(file,data)","desc":"写入文件，如果不存在，自动创建\n导出json，`fs.outputJson(file, object[, options][, callback])` \n```\nfs.outputFile(file, 'hello!')\n.then(() => fs.readFile(file, 'utf8'))\n.then(data => {\n  console.log(data) // => hello!\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/outputFile.md","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".truncate","suffix":"(path,len,fn)","desc":"截断文件内容,len指定保留的长度（字节数）\n同步方法：`fs.truncateSync(path[, len])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_truncate_path_len_callback","dot":""}]},{"title":"开关","fold":false,"list":[{"prefix":"fd","tag":" ","suffix":"","desc":"在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。 每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。 在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。 Windows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。 为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。\n大多数操作系统限制在任何给定时间内可能打开的文件描述符的数量，因此当操作完成时关闭描述符至关重要。 如果不这样做将导致内存泄漏，最终导致应用程序崩溃。","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".open","suffix":"(path,fn(err,fd))","desc":"打开文件\n同步方法：`fs.openSync(path[, flags, mode])`","url":"","summary":"<table class=\"reference\">\n<tbody><tr><th>Flag</th><th>描述</th></tr>\n<tr><td>r</td><td>以读取模式打开文件。如果文件不存在抛出异常。</td></tr>\n<tr><td>r+</td><td> 以读写模式打开文件。如果文件不存在抛出异常。</td></tr>\n<tr><td>rs</td><td>以同步的方式读取文件。</td></tr>\n<tr><td>rs+</td><td>以同步的方式读取和写入文件。</td></tr>\n<tr><td>w</td><td>以写入模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>wx</td><td>类似 'w'，但是如果文件路径存在，则文件写入失败。</td></tr>\n<tr><td>w+</td><td>以读写模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>wx+</td><td>类似 'w+'， 但是如果文件路径存在，则文件读写失败。</td></tr>\n<tr><td>a</td><td>以追加模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>ax</td><td>类似 'a'， 但是如果文件路径存在，则文件追加失败。</td></tr>\n<tr><td>a+</td><td>以读取追加模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>ax+</td><td>类似 'a+'， 但是如果文件路径存在，则文件读取追加失败。</td></tr>\n</tbody></table>","reference":"","dot":""},{"prefix":"fs","tag":".read","suffix":"(fd,buffer,offset,length,position)","desc":"从 fd 指定的文件中读取数据\n同步方法：`fs.readSync(fd, buffer, offset, length, position)`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback","dot":""},{"prefix":"fs","tag":".write","suffix":"(fd,data,fn)","desc":"将 buffer 写入到 fd 指定的文件。\n`fs.write(fd, buffer[, offset[, length[, position]]], callback)`\n`fs.write(fd, string[, position[, encoding]], callback)`\n同步方法：\n`fs.writeSync(fd, buffer[, offset[, length[, position]]])`\n`fs.writeSync(fd, string[, position[, encoding]])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback","dot":""},{"prefix":"fs","tag":".writev","suffix":"(fd,buffers,fn)","desc":"使用 writev() 将一个 ArrayBufferView 数组写入 fd 指定的文件。\n同步方法：`fs.writevSync(fd, buffers[, position])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_writev_fd_buffers_position_callback","dot":""},{"prefix":"fs","tag":".close","suffix":"(fd,fn)","desc":"关闭文件\n同步方法：`fs.closeSync(fd)`","url":"","summary":"","reference":"","dot":""}]},{"title":"监听","fold":false,"list":[{"prefix":"fs","tag":".watch","suffix":"(path,fn)","desc":"监视 filename 的更改，其中 filename 是文件或目录","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_watch_filename_options_listener","dot":""},{"prefix":"fs","tag":".watchFile","suffix":"(file,fn)","desc":"监视 filename 的更改。","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_watchfile_filename_options_listener","dot":""},{"prefix":"fs","tag":".unwatchFile","suffix":"(file,fn)","desc":"停止监视 filename 的变化","url":"","summary":"","reference":"","dot":""},{"prefix":"watcher.on(","tag":"change","suffix":",fn)","desc":"+ change 当监视的目录或文件中发生更改时触发\n+ error 当监视文件时发生错误时触发\n+ close 当监视器停止监视更改时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"watcher","tag":".close()","suffix":"","desc":"给定的 fs.FSWatcher 停止监视更改。 一旦停止，则 fs.FSWatcher 对象将不再可用。","url":"","summary":"","reference":"","dot":""}]},{"title":"链接","fold":false,"list":[{"prefix":"link","tag":" ","suffix":"","desc":"# inode\n我们首先来看看 linux 系统里面的一个重要概念：inode。\n\n我们知道，文件存储在硬盘上，硬盘存储的最小单位是扇区（sector，每个扇区 512 B）。而操作系统读取文件时，按块读取（连续的多个扇区），也就是说文件存取的最小单位是块（block，块通常是 4 KB）。\n\n除了文件数据，我们还必须存储文件的元信息（如：文件大小、文件创建者、文件数据的块位置、文件读/写/执行权限、文件时间戳等等），这种存储文件元信息的结构就称为 inode。\n\n每个 inode 都有一个唯一的号码标志，linux 系统内部使用 inode 的号码来识别文件，并不使用文件名。我们打开一个文件时，系统首先找到文件名对应的 inode 号码，然后通过 inode 号码获取 inode 信息，最后根据 inode 信息中的文件数据所在的 block 读出数据。\n\n实际上，在 linux 系统中，目录也是一种文件。目录文件包含一系列目录项，每个目录项由两部分组成：所包含文件的文件名，以及该文件名对应的 inode 号码。我们可以使用 ls -i 来列出目录中的文件以及它们的 inode 号码。这其实也解释了仅更改目录的读权限，并不能实现读取目录下所有文件内容的原因，通常需要 chmod -R 来进行递归更改。\n\n总结下：\n\n硬盘存取的最小单位是扇区，文件存取的最小单位是块（连续的扇区）\n存储文件元信息（文件大小、创建者、块位置、时间戳、权限等非数据信息）的结构称为 inode\n每个 inode 拥有一个唯一号码，系统内部通过它来识别文件\n目录也是一种文件，其内容包含一系列目录项（每个目录项由文件的文件名和文件对应的 inode 号码组成）","url":"","summary":"# 硬链接\n一般情况，一个文件名“唯一”对应一个 inode。但是，linux 允许多个文件名都指向同一个 inode。这表示我们可以使用不同的文件名访问同样的内容；对文件内容进行修改将“反映”到所有文件；删除一个文件不影响另一个文件的访问 。这种机制就被称为“硬链接”。\n\n# 软链接\n软链接\n软链接类似于 windows 中的”快捷方式“。两个文件虽然 inode 号码不一样，但是文件 A 内部会指向文件 B 的 inode。当我们读取文件 A 时，系统就自动导向文件 B，文件 A 就是文件 B 的软链接（或者叫符号链接）。这表示我们同样可以使用不同的文件名访问同样的内容；对文件内容修改将”反映“到所有文件。但是当我们删除掉源文件 B 时，再访问文件 A 时会报错 “No such file or directory”。","reference":"参考资料|https://kohpoll.github.io/blog/2016/05/30/hardlink-symlink-require-in-nodejs/","dot":""},{"prefix":"fs","tag":".link","suffix":"(old,new,fn)","desc":"创建硬链接\n同步方法：`fs.linkSync(existingPath, newPath)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".unlink","suffix":"(path,fn)","desc":"异步地删除文件或符号链接。\n同步方法：`fs.unlinkSync(path)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".readlink","suffix":"(path,encoding,fn)","desc":"异步读取链接\n同步方法：`fs.readlinkSync(path[, options])` ","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_readlink_path_options_callback","dot":""},{"prefix":"fs","tag":".symlink","suffix":"(target,path,fn)","desc":"软链接。创建名为 path 的链接，该链接指向 target。\n同步方法：`fs.symlinkSync(target, path[, type])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_symlink_target_path_type_callback","dot":""}]},{"title":"权限","fold":false,"list":[{"prefix":"fs","tag":".chmod","suffix":"(path,mode,fn)","desc":"异步地更改文件的权限，0o<所有者7><群组6><其他人5>\n同步方法：`fs.chmodSync(path, mode)`\n强制执行：`fs.fchmod(fd, mode, callback)`\nMacOS：`fs.lchmod(path, mode, callback)`","url":"","summary":"权限数字\n<table><thead><tr><th>数字</th><th>说明</th></tr></thead><tbody><tr><td><code>7</code></td><td>可读、可写、可执行</td></tr><tr><td><code>6</code></td><td>可读、可写</td></tr><tr><td><code>5</code></td><td>可读、可执行</td></tr><tr><td><code>4</code></td><td>只读</td></tr><tr><td><code>3</code></td><td>可写、可执行</td></tr><tr><td><code>2</code></td><td>只写</td></tr><tr><td><code>1</code></td><td>只可执行</td></tr><tr><td><code>0</code></td><td>没有权限</td></tr></tbody></table>\n构造 mode 更简单的方法是使用三个八进制数字的序列（ 例如 765）。 最左边的数字（示例中的 7）指定文件所有者的权限。 中间的数字（示例中的 6）指定群组的权限。 最右边的数字（示例中的 5）指定其他人的权限。\n例如，八进制值 0o765 表示：\n所有者可以读取、写入和执行该文件。\n群组可以读和写入该文件。\n其他人可以读取和执行该文件。\n注意事项：在 Windows 上，只能更改写入权限，并且不会实现群组、所有者或其他人的权限之间的区别。","reference":"","dot":""},{"prefix":"fs","tag":".chown","suffix":"(path,uid,gid,fn)","desc":"异步地更改文件的所有者和群组\n同步方法：`fs.chownSync(path, uid, gid)`\n强制执行：`fs.fchown(fd, uid, gid, callback)`\nMacOS：`fs.lchown(path, uid, gid, callback)`","url":"","summary":"","reference":"","dot":""}]},{"title":"杂项","fold":false,"list":[{"prefix":"fs","tag":".stat","suffix":"(path,fn(err,stats))","desc":"同步方法：`fs.statSync(path[, options])`\nstats.isDirectory() 是否为目录\nstats.isFile() 是否为常规文件\nstats.isSocket() 是否为套接字\nstats.isSymbolicLink() 是否为软链接","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_class_fs_stats","dot":""},{"prefix":"fs","tag":".rename","suffix":"(old,new,fn)","desc":"文件重命名。如果 newPath 已存在，则覆盖它。\n同步方法：`fs.renameSync(oldPath, newPath)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".utimes","suffix":"(path,atime,mtime,fn)","desc":"更改 path 指向的对象的文件系统时间戳。\n同步方法：`fs.utimesSync(path, atime, mtime)`","url":"","summary":"atime 和 mtime 参数遵循以下规则：\n值可以是表示 Unix 纪元时间的数字、 Date 对象、或类似 '123456789.0' 的数值字符串。\n如果该值无法转换为数值、或值为 NaN、 Infinity 或 -Infinity，则抛出错误。","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"python","fold":false,"list":[{"prefix":"","tag":"open","suffix":"(file,flag)","desc":"`f = open('/Users/michael/test.txt', 'w')`","url":"https://www.runoob.com/python3/python3-file-methods.html","summary":"","reference":"","dot":""},{"prefix":"f","tag":".write","suffix":"(data)","desc":"`f.write('Hello, world!')`","url":"","summary":"","reference":"","dot":""},{"prefix":"f","tag":".close()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"crypto","barcolor":"","fold":false,"box":[{"title":"hash","fold":false,"list":[{"prefix":"crypto","tag":".createHash","suffix":"('md5',[opt])","desc":"创建并返回一个 Hash 对象，该对象可用于生成哈希摘要\n常用md5,sha1,sha256,sha512 \n\n**注意**：Hash实例不能复用，hash实例调用digest之后不能再调用update\n","url":"","summary":"可选的 options 参数控制流的行为。 对于 XOF 哈希函数（例如 'shake256'）， outputLength 选项可用于指定所需的输出长度（以字节为单位）。","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_crypto_createhash_algorithm_options\n其他|https://blog.csdn.net/qq_34838046/article/details/109460977","dot":""},{"prefix":"hash","tag":".update","suffix":"(data)","desc":"默认字符串编码为UTF-8，也可以传入Buffer","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_hash_update_data_inputencoding","dot":""},{"prefix":"hash","tag":".digest","suffix":"('hex')","desc":"如果提供了 encoding，则返回字符串，否则返回 Buffer","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_hash_digest_encoding","dot":""},{"prefix":"crypto","tag":".getHashes()","suffix":"","desc":"支持的hash算法列表","url":"","summary":"algorithm 取决于平台上的 OpenSSL 的版本所支持的可用算法。\n新 `openssl list -digest-algorithms`\n旧 `openssl list-message-digest-algorithms`","reference":"","dot":""}]},{"title":"hmac","fold":false,"list":[{"prefix":"crypto","tag":".createHmac","suffix":"(alg,key)","desc":"加盐摘要\n```\nconst crypto = require('crypto');\nconst hmac = crypto.createHmac('sha256', '密钥');\nhmac.update('要创建哈希的数据');\nhmac.digest('hex')\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"hmac","tag":".update","suffix":"(data)","desc":"可通过多次调用或输入流","url":"","summary":"```\nconst input = fs.createReadStream(filename);\ninput.on('readable', () => {\n  // 哈希流只会生成一个元素。\n  const data = input.read();\n  if (data)\n    hmac.update(data);\n  else {\n    console.log(`${hmac.digest('hex')} ${filename}`);\n  }\n});\n```","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_class_hmac","dot":""},{"prefix":"hmac","tag":".digest","suffix":"([encoding])","desc":"计算使用 hmac.update() 传入的所有数据的 HMAC 摘要。 如果提供了 encoding，则返回字符串，否则返回 Buffer。\n调用 hmac.digest() 方法之后， Hmac 对象不能被再次使用。 多次调用 hmac.digest() 将会导致抛出错误。","url":"","summary":"","reference":"","dot":""}]},{"title":"Diffie-Hellman","fold":false,"list":[{"prefix":"crypto","tag":".createDiffieHellman","suffix":"(len)","desc":"密钥交换协议\n```\nconst crypto = require('crypto');\nconst assert = require('assert');\n\n// 生成 Alice 的密钥。\nconst alice = crypto.createDiffieHellman(2048);\nconst aliceKey = alice.generateKeys();\n\n// 生成 Bob 的密钥。\nconst bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());\nconst bobKey = bob.generateKeys();\n\n// 交换并生成密钥。\nconst aliceSecret = alice.computeSecret(bobKey);\nconst bobSecret = bob.computeSecret(aliceKey);\n\nassert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n```","url":"","summary":"","reference":"参考资料|https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640\n官方文档|http://nodejs.cn/api/crypto.html#crypto_class_diffiehellman","dot":""},{"prefix":"crypto","tag":".createECDH() ","suffix":"","desc":"椭圆曲线 Elliptic Curve Diffie-Hellman（ECDH）\n```\nconst crypto = require('crypto');\nconst assert = require('assert');\n\n// 生成 Alice 的密钥。\nconst alice = crypto.createECDH('secp521r1');\nconst aliceKey = alice.generateKeys();\n\n// 生成 Bob 的密钥。\nconst bob = crypto.createECDH('secp521r1');\nconst bobKey = bob.generateKeys();\n\n// 交换并生成密钥。\nconst aliceSecret = alice.computeSecret(bobKey);\nconst bobSecret = bob.computeSecret(aliceKey);\n\nassert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n```","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/crypto.html#crypto_class_ecdh","dot":""},{"prefix":"crypto","tag":".getCurves()","suffix":"","desc":"查看全部椭圆曲线算法","url":"","summary":"","reference":"","dot":""}]},{"title":"AES","fold":false,"list":[{"prefix":"crypto","tag":".createCipher","suffix":"('aes192',key)","desc":"对称加密算法,常用如aes192，aes-128-ecb，aes-256-cbc等\n```\nfunction aesEncrypt(data, key) {\n    const cipher = crypto.createCipher('aes192', key);\n    var crypted = cipher.update(data, 'utf8', 'hex');\n    crypted += cipher.final('hex');\n    return crypted;\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"crypto","tag":".createDecipher","suffix":"('aes192',key)","desc":"```\nfunction aesDecrypt(encrypted, key) {\n    const decipher = crypto.createDecipher('aes192', key);\n    var decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"crypto","tag":".getCiphers()","suffix":"","desc":"支持的对称加密算法列表","url":"","summary":"","reference":"","dot":""}]},{"title":"RSA","fold":false,"list":[{"prefix":"crypto","tag":".privateEncrypt","suffix":"(prvKey,data)","desc":"非对称加密算法\n私钥加密 `let enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, 'utf8'));`\n公钥解密 `let dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv)`\n","url":"","summary":"","reference":"RSA算法原理（一）|http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\nRSA算法原理（二）|http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html","dot":""},{"prefix":"crypto","tag":".publicEncrypt","suffix":"(pubKey,data)","desc":"RSA加密的原始信息必须小于Key的长度\n公钥加密 `let enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, 'utf8'))`\n私钥解密 `let dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub)`","url":"","summary":"","reference":"","dot":""}]},{"title":"Misc","fold":false,"list":[{"prefix":"crypto","tag":".randomBytes","suffix":"(len).toString('hex')","desc":"生成随机字符\n```\nconst buf = crypto.randomBytes(256);\nconsole.log(\n  `${buf.length} 位的随机数据: ${buf.toString('hex')}`);\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"uuid","suffix":"","desc":"# Random UUIDs\n```\nimport { v4 as uuidv4 } from 'uuid';\nuuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'\n```\n# Timestamp UUIDs\n```\nimport { v1 as uuidv1 } from 'uuid';\nuuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8b2d-1b9d6bcdbbfd'\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/uuid","dot":""}]},{"title":"web crypto api","fold":false,"list":[{"prefix":"window","tag":".crypto","suffix":".subtle","desc":"","url":"","summary":"","reference":"参考资料|https://cloud.tencent.com/developer/article/1171800\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/SubtleCrypto","dot":""},{"prefix":"crypto.subtle","tag":".digest","suffix":"(alg,data)","desc":"摘要算法\n```\ncrypto.subtle.digest('SHA-256', new Uint8Array([1,2,3,4]))\n.then((hash)=>{\n    let arr = new Uint8Array(hash)\n    let str = ''\n    for(bit of arr){\n        str += bit.toString(16)\n    }\n})\n```","url":"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest","summary":"","reference":"MDN|https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"hash","fold":false,"list":[{"prefix":"md5|sha1","tag":".update","suffix":"(val)","desc":"```\nimport hashlib\nhashlib.md5()\n```","url":"","summary":"MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。","reference":"","dot":""},{"prefix":"md5|sha1","tag":".hexdigest()","suffix":"","desc":"MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。\nSHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示","url":"","summary":"","reference":"","dot":""}]},{"title":"hmac","fold":false,"list":[{"prefix":"hmac","tag":".new","suffix":"(key,data,digestmod='MD5')","desc":"```\nimport hmac\nmessage = b'Hello, world!'\nkey = b'secret'\nh = hmac.new(key, message, digestmod='MD5')\n```\n如果消息很长，可以多次调用h.update(msg)","url":"","summary":"","reference":"","dot":""},{"prefix":"h","tag":".hexdigest()","suffix":"","desc":"使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"process","barcolor":"","fold":false,"box":[{"title":"属性","fold":false,"list":[{"prefix":"process","tag":".argv","suffix":"","desc":"返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数\n+ `process.argv0` 当 Node.js 启动时传入的 argv[0] 的原始值的只读副本\n+ `process.execPath` 返回启动 Node.js 进程的可执行文件的绝对路径名\n+ `process.execArgv` 返回当 Node.js 进程被启动时，Node.js 特定的命令行选项,这些选项在 process.argv 属性返回的数组中不会出现","url":"","summary":"\n","reference":"","dot":""},{"prefix":"process","tag":".env","suffix":"","desc":"返回包含用户环境的对象\n可以修改此对象，但这些修改不会反映到 Node.js 进程之外，或者（除非明确请求）反映到其他 Worker 线程。","url":"","summary":"通常的做法是，新建一个环境变量NODE_ENV，用它确定当前所处的开发阶段，生产阶段设为production，开发阶段设为develop或staging，然后在脚本中读取process.env.NODE_ENV即可。\n`export NODE_ENV=production && node app.js`","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_env","dot":""},{"prefix":"process","tag":".cwd()","suffix":"","desc":"返回 Node.js 进程的当前工作目录\n`process.chdir(dir)`  变更 Node.js 进程的当前工作目录，如果变更目录失败会抛出异常","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".pid","suffix":"","desc":"`process.pid` 返回进程的 PID\n`process.ppid` 返回当前父进程的 PID\n`process.title` 返回当前进程标题,可以自定义该值","url":"","summary":"","reference":"","dot":""}]},{"title":"IPC","fold":false,"list":[{"prefix":"process","tag":".channel","suffix":"","desc":"如果 Node.js 进程是由 IPC 通道（参阅子进程文档）方式创建的， process.channel 属性保存 IPC 通道的引用。 如果 IPC 通道不存在，则此属性值为 undefined。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".send","suffix":"(msg,handle,fn)","desc":"进程间发送消息\n消息会进行序列化和解析","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"message","suffix":",fn)","desc":"收到消息时","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".disconnect()","suffix":"","desc":"关闭到父|子进程的 IPC 通道","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"disconnect","suffix":",fn)","desc":"IPC 通道关闭时将触发 'disconnect' 事件","url":"","summary":"调用父进程中的 subprocess.disconnect() 或子进程中的 process.disconnect() 后会触发 'disconnect' 事件。 断开连接后就不能再发送或接收信息，且 subprocess.connected 属性为 false。","reference":"","dot":""}]},{"title":"退出","fold":false,"list":[{"prefix":"process","tag":".exit","suffix":"(0)","desc":"以退出状态 code 指示 Node.js 同步地终止进程。\n0成功 1失败","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/process.html#process_process_exit_code","dot":""},{"prefix":"process","tag":".exitCode","suffix":"","desc":"指定错误码，抛出异常退出\n```\nprocess.exitCode = 1;\nthrow new Error(\"xx condition failed\");\n```","url":"","summary":"`process.exit()` 手动退出当前进程\n+ 如果参数大于0表示执行失败\n+ 如果等于0表示执行成功\n注意，process.exit()很多时候是不需要的。因为如果没有错误，一旦事件循环之中没有待完成的任务，Node 本来就会退出进程，不需要调用process.exit(0)。这时如果调用了，进程会立刻退出，不管有没有异步任务还在执行，所以不如等 Node 自然退出。另一方面，如果发生错误，Node 往往也会退出进程，也不一定要调用process.exit(1)。","reference":"","dot":""},{"prefix":"process.on(","tag":"exit","suffix":",fn(code))","desc":"当 Node.js 进程因以下原因之一即将退出时，则会触发 'exit' 事件：\n+ 显式调用 `process.exit()` 方法；\n+ Node.js 事件循环不再需要执行任何其他工作。\n此时无法阻止退出事件循环，并且一旦所有 'exit' 事件的监听器都已完成运行时，Node.js 进程将终止。\n\n注意，此时回调函数只能执行*同步*操作，不能包含异步操作，因为执行完回调函数，进程就会退出，无法监听到回调函数的操作结果。","url":"","summary":"# 退出码\n正常情况下，如果没有异步操作正在等待，那么 Node.js 会以状态码 0 退出，其他情况下，会用如下的状态码:\n1 未捕获异常 - 有一个未被捕获的异常, 并且没被 domain 或 'uncaughtException' 事件处理器处理。\n2 - 未被使用 (Bash 为防内部滥用而保留)\n3 内部的 JavaScript 解析错误 - Node.js 内部的 JavaScript 源代码在引导进程中导致了一个语法解析错误。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n4 内部的 JavaScript 执行失败 - 引导进程执行 Node.js 内部的 JavaScript 源代码时，返回函数值失败。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n5 致命错误 - 在 V8 中有一个致命的错误。 比较典型的是以 FATALERROR 为前缀从 stderr 打印出来的消息。\n6 非函数的内部异常处理 - 发生了一个内部异常，但是内部异常处理函数被设置成了一个非函数，或者不能被调用。\n7 内部异常处理运行时失败 - 有一个不能被捕获的异常，在试图处理这个异常时，处理函数本身抛出了一个错误。 这是可能发生的, 比如, 如果一个 'uncaughtException' 或者 domain.on('error') 处理函数抛出了一个错误。\n8 - 未被使用，在之前版本的 Node.js, 退出码 8 有时候表示一个未被捕获的异常。\n9 - 不可用参数 - 也许是某个未知选项没有确定，或者没给必需要的选项填值。\n10 内部的 JavaScript 运行时失败 - 调用引导函数时，引导进程执行 Node.js 内部的 JavaScript 源代码抛出错误。 这是非常少见的, 一般只会在开发 Node.js 本身的时候出现。\n12 不可用的调试参数 - --inspect 和/或 --inspect-brk 选项已设置，但选择的端口号无效或不可用。\n>128 退出信号 - 如果 Node.js 接收到致命信号, 诸如 SIGKILL 或 SIGHUP，那么它的退出代码将是 128 加上信号的码值。 这是 POSIX 的标准做法，因为退出码被定义为 7 位整数，并且信号退出设置高位，然后包含信号码值。 例如，信号 SIGABRT 的值为 6，因此预期的退出代码将为 128 + 6 或 134。","reference":"","dot":""},{"prefix":"process.on(","tag":"beforeExit","suffix":",fn)","desc":"对于导致显式终止的条件，不会触发 'beforeExit' 事件，例如调用 process.exit() 或未捕获的异常。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".abort()","suffix":"","desc":"使 Node.js 进程立即结束，并生成一个核心文件","url":"","summary":"Worker 线程中没有此特性。","reference":"","dot":""}]},{"title":"信号","fold":false,"list":[{"prefix":"process","tag":".kill","suffix":"(pid,[signal])","desc":"对指定ID的线程发送信号，默认为SIGTERM信号","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_kill_pid_signal","dot":""},{"prefix":"process","tag":".kill","suffix":"([signal])","desc":"子进程或cluster worker自杀\n默认信号SIGTERM。如果成功，则此函数返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"<sign>","suffix":",fn)","desc":"当 Node.js 进程接收到一个信号时，会触发信号事件。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_signal_events","dot":""}]},{"title":"异常","fold":false,"list":[{"prefix":"process.on(","tag":"error","suffix":",fn)","desc":"每当出现以下情况时触发 'error' 事件：\n无法衍生进程；\n无法杀死进程；\n向子进程发送消息失败。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"uncaughtException","suffix":",fn(err,origin))","desc":"只要有错误没有捕获，就会触发这个事件。\n正确使用 'uncaughtException' 事件的方式，是用它在进程结束前执行一些已分配资源（比如文件描述符，句柄等等）的同步清理操作","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/process.html#process_event_uncaughtexception","dot":""},{"prefix":"process.on(","tag":"rejectionHandled","suffix":")","desc":"每当 Promise 被拒绝并且错误处理函数附加到它（例如，使用 promise.catch()）晚于一个 Node.js 事件循环时，就会触发 'rejectionHandled' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"unhandledRejection","suffix":")","desc":"如果在事件循环的一次轮询中，一个 Promise 被拒绝，并且此 Promise 没有绑定错误处理器， 'unhandledRejection 事件会被触发。 ","url":"","summary":"","reference":"","dot":""},{"prefix":"process.on(","tag":"warning","suffix":",fn)","desc":"任何时候 Node.js 触发进程告警，都会触发 'warning' 事件。\n告警不是 Node.js 和 Javascript 错误处理流程的正式组成部分。 一旦探测到可能导致应用性能问题，缺陷或安全隐患相关的代码实践，Node.js 就可发出告警。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".emitWarning","suffix":"(msg,opt)","desc":"触发自定义或应用特定的进程警告\n","url":"","summary":"```\nprocess.emitWarning('出错啦', {\n  code: 'MY_WARNING',\n  detail: '一些额外的信息'\n});\n```","reference":"官方手册|http://nodejs.cn/api/process.html#process_process_emitwarning_warning_options","dot":""}]},{"title":"优先级","fold":false,"list":[{"prefix":"process","tag":".nextTick","suffix":"(fn)","desc":"放到当前一轮事件循环（Event Loop）的尾部\nsetTimeout(f,0)是将任务放到下一轮事件循环的头部，因此nextTick会比它先执行。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".setPriority","suffix":"([pid],priority)","desc":"尝试为 pid 指定的进程设置调度优先级。 \n如果未提供 pid 或者为 0，则使用当前进程的进程 ID。\npriority 输入必须是 -20（高优先级）到 19（低优先级）之间的整数。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".getPriority","suffix":"([pid])","desc":"返回由 pid 指定的进程的调度优先级。\n如果未提供 pid 或者为 0，则返回当前进程的优先级。","url":"","summary":"","reference":"","dot":""}]},{"title":"信息","fold":false,"list":[{"prefix":"process","tag":".uptime()","suffix":"","desc":"返回当前 Node.js 进程运行时间秒长","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".memoryUsage()","suffix":"","desc":"返回 Node.js 进程的内存使用情况的对象，该对象每个属性值的单位为字节。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".resourceUsage()","suffix":"","desc":"资源使用","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".config","suffix":"","desc":"返回一个 Object，其中包含用于编译当前 Node.js 可执行文件的配置选项的 JavaScript 表示形式。 这与运行 ./configure 脚本时生成的 config.gypi 文件相同。","url":"","summary":"","reference":"","dot":""}]},{"title":"环境","fold":false,"list":[{"prefix":"process","tag":".platform","suffix":"","desc":"返回字符串，标识 Node.js 进程运行其上的操作系统平台。\n当前可能的值有：\n'aix'\n'darwin'\n'freebsd'\n'linux'\n'openbsd'\n'sunos'\n'win32'","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".arch","suffix":"","desc":"为其编译 Node.js 二进制文件的操作系统的 CPU 架构。 \n可能的值有：'arm'、 'arm64'、 'ia32'、 'mips'、 'mipsel'、 'ppc'、 'ppc64'、 's390'、 's390x'、 'x32' 和 'x64'。","url":"","summary":"","reference":"","dot":""},{"prefix":"process","tag":".version","suffix":"","desc":"返回 Node.js 的版本信息","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"child_process","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"child_process.","tag":"exec","suffix":"(cmd,fn)","desc":"新建一个子进程，然后缓存它的运行结果，运行结束后调用回调函数，返回childprocess实例。\n同步方法：`child_process.execSync(command[, options])`\n适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。","url":"","summary":"回调函数参数：error, stdout, stderr\nexec方法会直接调用bash（/bin/sh程序）来解释命令","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback","dot":""},{"prefix":"child_process","tag":".spawn","suffix":"(cmd,[argarr])","desc":"与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。\n同步方法：`child_process.spawnSync(command[, args][, options])`\n适用于返回大量数据，例如图像处理，二进制数据处理","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options","dot":""},{"prefix":"child_process","tag":".execFile","suffix":"(file,[argarr],fn)","desc":"直接执行特定的程序，参数作为数组传入，不会被bash解释\n同步方法：`child_process.execFileSync(file[, args][, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback","dot":""},{"prefix":"child_process","tag":".fork","suffix":"(file)","desc":"fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。","url":"","summary":"衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。","reference":"参考资料|https://juejin.im/post/5d06d6ddf265da1b9570562a","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"child.on(","tag":"close","suffix":",fn)","desc":"当子进程的 stdio 流已被关闭时会触发 'close' 事件。 这与 'exit' 事件不同，因为多个进程可能共享相同的 stdio 流。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"cluster","barcolor":"","fold":false,"box":[{"title":"主进程","fold":false,"list":[{"prefix":"pm2 start app.js","tag":" -i 4","suffix":"","desc":"集群，-i 参数用来告诉PM2以cluster\\_mode的形式运行你的app（对应的叫fork_mode），后面的数字表示要启动的工作线程的数量。如果给定的数字为0，PM2则会根据你CPU核心的数量来生成对应的工作线程。注意一般在生产环境使用cluster\\_mode模式，测试或者本地环境一般使用fork模式，方便测试到错误。","url":"","summary":"","reference":"官方文档|https://pm2.keymetrics.io/docs/usage/quick-start/","dot":""},{"prefix":"cluster","tag":".isMaster","suffix":"","desc":"`cluster.isMaster` 如果该进程是主进程，则为 true。\n`cluster.isWorker` 如果该进程不是主进程，则为 true","url":"","summary":"","reference":"参考资料|https://juejin.im/post/5d43017be51d4561f40adcf9#heading-17","dot":""},{"prefix":"cluster","tag":".fork()","suffix":"","desc":"衍生出一个新的工作进程。","url":"","summary":"```\nvar cluster = require('cluster');\n\nif(cluster.isMaster) {\n  var numWorkers = require('os').cpus().length;\n  console.log('Master cluster setting up ' + numWorkers + ' workers...');\n\n  for(var i = 0; i < numWorkers; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('online', function(worker) {\n    console.log('Worker ' + worker.process.pid + ' is online');\n  });\n\n  cluster.on('exit', function(worker, code, signal) {\n    console.log('Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal);\n    console.log('Starting a new worker');\n    cluster.fork();\n  });\n}\n```","reference":"参考资料|https://zhuanlan.zhihu.com/p/74879045","dot":""},{"prefix":"cluster.on(","tag":"<event>","suffix":",fn)","desc":"+ fork 当主进程衍生工作进程时触发\n+ online 当工作进程运行时触发\n+ listening 任意worker触发时触发\n+ message 从任意工作进程收到消息时\n+ disconnect 任意worker工作进程的 IPC 管道被断开后触发。 可能导致事件触发的原因包括：工作进程优雅地退出、被杀死、或手动断开连接\n+ exit 任意worker退出时","url":"","summary":"","reference":"","dot":""},{"prefix":"cluster.","tag":"disconnect","suffix":"(fn)","desc":"在 cluster.workers 的每个工作进程中调用 .disconnect()","url":"","summary":"","reference":"","dot":""}]},{"title":"子进程","fold":false,"list":[{"prefix":"worker.on(","tag":"<event>","suffix":",fn)","desc":"'message' 事件\n+ online 就绪时\n+ listening 当调用 listen() 时触发\n+ disconnect 断开连接时\n+ message 收到消息时\n+ exit 退出时","url":"","summary":"","reference":"参考资料|https://zhuanlan.zhihu.com/p/74879045","dot":""},{"prefix":"worker","tag":".id","suffix":"","desc":"每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在 id 里面。\n当工作进程还存活时，这个编号可以作为在 cluster.workers 中的索引。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"worker_threads","barcolor":"","fold":false,"box":[{"title":"主线程","fold":false,"list":[{"prefix":"","tag":"isMainThread","suffix":"","desc":"当前线程为主线程时返回true","url":"","summary":"```\nconst {\n    Worker,\n    isMainThread,\n    threadId,\n    workerData,\n    SHARE_ENV\n} = require(\"worker_threads\");\n\n//主线程\nif (isMainThread) {\n    console.log(threadId);  //主线程ID\n    var worker = new Worker(__filename, {\n        workerData: \"Hello, world!\",    //传递数据\n        env: SHARE_ENV  //共享环境变量\n    });\n\n    worker.on(\"exit\", () => {\n        console.log(process.env.SET_IN_WORKER);\n    });\n\n//工作线程\n} else {\n    console.log(threadId);  //子线程ID\n    // console.log(workerData);    //被传递数据\n    process.env.SET_IN_WORKER = \"foo\";  //设置共享环境变量\n}\n```","reference":"参考资料|https://juejin.im/post/5d736a675188254faf71521a","dot":""},{"prefix":"","tag":"new Worker","suffix":"(path,opt)","desc":"# opt\nenv ：SHARE_ENV //主线程与子线程可共享环境变量读写\nworkerData : 传递数据 \nresourceLimits ： 资源限制","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/worker_threads.html#worker_threads_new_worker_filename_options","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(data,[transferList])","desc":"向工作线程发送数据","url":"","summary":"","reference":"","dot":""},{"prefix":"worker.on(","tag":"message","suffix":",fn)","desc":"收到工作线程消息时","url":"","summary":"","reference":"","dot":""},{"prefix":"worker.on(","tag":"<event>","suffix":",fn)","desc":"工作线程的其他事件\n+ online 工作线程就绪\n+ error 错误事件\n+ exit 退出事件\n ","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".terminate()","suffix":"","desc":"关闭线程","url":"","summary":"","reference":"","dot":""}]},{"title":"工作线程","fold":false,"list":[{"prefix":"parentPort.on(","tag":"message","suffix":",fn)","desc":"接收主线程消息","url":"","summary":"","reference":"","dot":""},{"prefix":"parentPort","tag":".postMessage","suffix":"(data)","desc":"向主主线程发送消息","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"workerData","suffix":"","desc":"初始化时由主线程拷贝传递的数据","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"threadId","suffix":"","desc":"线程唯一ID","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"io","barcolor":"","fold":false,"box":[{"title":"process","fold":false,"list":[{"prefix":"ps","tag":".stdin","suffix":".on(data,fn(data))","desc":"返回连接到 stdin (fd 0) 的流。 它是一个 net.Socket 流（也就是双工流）\n由于stdin和stdout都部署了stream接口，所以可以使用stream接口的方法\n`process.stdin` 当前进程\n`child.stdin` 创建的子进程实例，可绑定data事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ps","tag":".stdout","suffix":".on(data,fn(data))","desc":"返回连接到 stdout (fd 1) 的流。它是一个 net.Socket 流（也就是双工流），","url":"","summary":"","reference":"","dot":""},{"prefix":"ps","tag":".stderr","suffix":".on(data,fn(data))","desc":"返回连接到 stderr (fd 2) 的流。 它是一个 net.Socket 流（也就是双工流）","url":"","summary":"","reference":"","dot":""}]},{"title":"lib","fold":false,"list":[{"prefix":"","tag":"commander","suffix":"","desc":"","url":"https://www.npmjs.com/package/commander","summary":"","reference":"","dot":""},{"prefix":"","tag":"chalk","suffix":"","desc":"","url":"https://www.npmjs.com/package/chalk","summary":"","reference":"","dot":""}]}]},{"title":"os","barcolor":"","fold":false,"box":[{"title":"信息","fold":false,"list":[{"prefix":"os","tag":".freemem()","suffix":"","desc":"以整数的形式返回空闲的系统内存量（以字节为单位）\n`os.totalmem()` 以整数的形式返回系统的内存总量（以字节为单位）。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".loadavg()","suffix":"","desc":"返回一个数组，包含 1、5 和 15 分钟的平均负载。\n平均负载是系统活动性的测量，由操作系统计算得出，并表现为一个分数。\n平均负载是 UNIX 特定的概念。 在 Windows 上，其返回值始终为 [0, 0, 0]。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".uptime()","suffix":"","desc":"返回系统的正常运行时间（以秒为单位）。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".networkInterfaces()","suffix":"","desc":"返回一个对象，该对象包含已分配了网络地址的网络接口。\n返回的对象上的每个键都标识了一个网络接口。 关联的值是一个对象数组，每个对象描述了一个分配的网络地址。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/os.html#os_os_networkinterfaces","dot":""},{"prefix":"os","tag":".hostname()","suffix":"","desc":"以字符串的形式返回操作系统的主机名。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".homedir()","suffix":"","desc":"返回当前用户的主目录的字符串路径。\n在 POSIX 上，使用 $HOME 环境变量（如果有定义）。 否则，使用有效的 UID 来查找用户的主目录。\n在 Windows 上，使用 USERPROFILE 环境变量（如果有定义）。 否则，使用当前用户的配置文件目录的路径。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".tmpdir()","suffix":"","desc":"以字符串的形式返回操作系统的默认临时文件目录。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".userInfo()","suffix":"","desc":"返回关于当前有效用户的信息。\n在 POSIX 平台上，这通常是密码文件的子集。 返回的对象包含 username、 uid、 gid、 shell 和 homedir。 \n在 Windows 上，则 uid 和 gid 字段为 -1，且 shell 为 null。","url":"","summary":"","reference":"","dot":""}]},{"title":"环境","fold":false,"list":[{"prefix":"os","tag":".constants","suffix":"","desc":"包含错误码、进程信号等常用的操作系统特定的常量。 定义的特定常量在 OS 常量中描述。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".cpus()","suffix":"","desc":"返回一个对象数组，其中包含有关每个逻辑 CPU 内核的信息。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/os.html#os_os_cpus","dot":""},{"prefix":"os.","tag":"EOL","suffix":"","desc":"操作系统特定的行末标志。\n在 POSIX 上是 \\n。\n在 Windows 上是 \\r\\n。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".endianness()","suffix":"","desc":"返回一个字符串，该字符串标识为其编译 Node.js 二进制文件的 CPU 的字节序。\n可能的值有， 'BE' 用于大端字节序， 'LE' 用于小端字节序。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".platform()","suffix":"","desc":"返回标识操作系统平台的字符串。 该值在编译时设置。\n可能的值有 'aix'、 'darwin'、 'freebsd'、 'linux'、 'openbsd'、 'sunos' 和 'win32'。\n`os.type()` 返回操作系统名字。 例如，在 Linux 上返回 'Linux'，在 macOS 上返回 'Darwin'，在 Windows 上返回 'Windows_NT'。","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".arch()","suffix":"","desc":"返回为其编译 Node.js 二进制文件的操作系统的 CPU 架构。 \n可能的值有：'arm'、 'arm64'、 'ia32'、 'mips'、 'mipsel'、 'ppc'、 'ppc64'、 's390'、 's390x'、 'x32' 和 'x64'","url":"","summary":"","reference":"","dot":""},{"prefix":"os","tag":".release()","suffix":"","desc":"以字符串的形式返回操作系统。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"io","fold":false,"list":[{"prefix":"","tag":"input","suffix":"(msg)","desc":"等待用户输入","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"print","suffix":"(val,..)","desc":"print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"HTTP Headers","barcolor":"","fold":false,"box":[{"title":"Overview","fold":true,"list":[{"prefix":"","tag":"MDN文档","suffix":"","desc":"","url":"https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers","summary":"","reference":"","dot":""},{"prefix":"","tag":"请求方法","suffix":"","desc":"<table class=\"reference\">\n   <tbody><tr><th width=\"5%\">序号</th><th width=\"10%\">方法</th><th>描述</th></tr>\n   <tr><td>1</td><td>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr>\n   <tr><td>2</td><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr>\n   <tr><td>3</td><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr>\n   <tr><td>4</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr>\n   <tr><td>5</td><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr>\n   <tr><td>6</td><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr>\n   <tr><td>7</td><td>OPTIONS </td><td>允许客户端查看服务器的性能。</td></tr>\n   <tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr>\n   <tr><td>9</td><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr>\n   </tbody></table>","url":"","summary":"","reference":"参考资料|https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods","dot":""},{"prefix":"","tag":" 状态返回码","suffix":"","desc":"<table class=\"reference\"><caption>HTTP状态码列表</caption>\n   <tbody>\n   <tr>\n   <th>状态码</th>\n   <th>状态码英文名称</th>\n   <th>中文描述</th>\n   </tr>\n   <tr>\n   <td>100</td>\n   <td>Continue</td>\n   <td>继续客户端应继续其请求</td>\n   </tr>\n   <tr>\n   <td>101</td>\n   <td>Switching Protocols</td>\n   <td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>\n   </tr>\n   <tr>\n   <td colspan=\"3\"></td>\n   </tr>\n   <tr>\n   <td>200</td>\n   <td>OK</td>\n   <td>请求成功。一般用于GET与POST请求</td>\n   </tr>\n   <tr>\n   <td>201</td>\n   <td>Created</td>\n   <td>已创建。成功请求并创建了新的资源</td>\n   </tr>\n   <tr>\n   <td>202</td>\n   <td>Accepted</td>\n   <td>已接受。已经接受请求，但未处理完成</td>\n   </tr>\n   <tr>\n   <td>203</td>\n   <td>Non-Authoritative Information</td>\n   <td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>\n   </tr>\n   <tr>\n   <td>204</td>\n   <td>No Content</td>\n   <td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>\n   </tr>\n   <tr>\n   <td>205</td>\n   <td>Reset Content</td>\n   <td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>\n   </tr>\n   <tr>\n   <td>206</td>\n   <td>Partial Content</td>\n   <td>部分内容。服务器成功处理了部分GET请求</td>\n   </tr>\n   <tr>\n   <td colspan=\"3\"></td>\n   </tr>\n   <tr>\n   <td>300</td>\n   <td>Multiple Choices</td>\n   <td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>\n   </tr>\n   <tr>\n   <td>301</td>\n   <td>Moved Permanently</td>\n   <td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>\n   </tr>\n   <tr>\n   <td>302</td>\n   <td>Found</td>\n   <td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>\n   </tr>\n   <tr>\n   <td>303</td>\n   <td>See Other</td>\n   <td>查看其它地址。与301类似。使用GET和POST请求查看</td>\n   </tr>\n   <tr>\n   <td>304</td>\n   <td>Not Modified</td>\n   <td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>\n   </tr>\n   <tr>\n   <td>305</td>\n   <td>Use Proxy</td>\n   <td>使用代理。所请求的资源必须通过代理访问</td>\n   </tr>\n   <tr>\n   <td>306</td>\n   <td>Unused</td>\n   <td>已经被废弃的HTTP状态码</td>\n   </tr>\n   <tr>\n   <td>307</td>\n   <td>Temporary Redirect</td>\n   <td>临时重定向。与302类似。使用GET请求重定向</td>\n   </tr>\n   <tr>\n   <td colspan=\"3\"></td>\n   </tr>\n   <tr>\n   <td>400</td>\n   <td>Bad Request</td>\n   <td>客户端请求的语法错误，服务器无法理解</td>\n   </tr>\n   <tr>\n   <td>401</td>\n   <td>Unauthorized</td>\n   <td>请求要求用户的身份认证</td>\n   </tr>\n   <tr>\n   <td>402</td>\n   <td>Payment Required</td>\n   <td>保留，将来使用</td>\n   </tr>\n   <tr>\n   <td>403</td>\n   <td>Forbidden</td>\n   <td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>\n   </tr>\n   <tr>\n   <td>404</td>\n   <td>Not Found</td>\n   <td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面</td>\n   </tr>\n   <tr>\n   <td>405</td>\n   <td>Method Not Allowed</td>\n   <td>客户端请求中的方法被禁止</td>\n   </tr>\n   <tr>\n   <td>406</td>\n   <td>Not Acceptable</td>\n   <td>服务器无法根据客户端请求的内容特性完成请求</td>\n   </tr>\n   <tr>\n   <td>407</td>\n   <td>Proxy Authentication Required</td>\n   <td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>\n   </tr>\n   <tr>\n   <td>408</td>\n   <td>Request Time-out</td>\n   <td>服务器等待客户端发送的请求时间过长，超时</td>\n   </tr>\n   <tr>\n   <td>409</td>\n   <td>Conflict</td>\n   <td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>\n   </tr>\n   <tr>\n   <td>410</td>\n   <td>Gone</td>\n   <td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>\n   </tr>\n   <tr>\n   <td>411</td>\n   <td>Length Required</td>\n   <td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>\n   </tr>\n   <tr>\n   <td>412</td>\n   <td>Precondition Failed</td>\n   <td>客户端请求信息的先决条件错误</td>\n   </tr>\n   <tr>\n   <td>413</td>\n   <td>Request Entity Too Large</td>\n   <td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>\n   </tr>\n   <tr>\n   <td>414</td>\n   <td>Request-URI Too Large</td>\n   <td>请求的URI过长（URI通常为网址），服务器无法处理</td>\n   </tr>\n   <tr>\n   <td>415</td>\n   <td>Unsupported Media Type</td>\n   <td>服务器无法处理请求附带的媒体格式</td>\n   </tr>\n   <tr>\n   <td>416</td>\n   <td>Requested range not satisfiable</td>\n   <td>客户端请求的范围无效</td>\n   </tr>\n   <tr>\n   <td>417</td>\n   <td>Expectation Failed</td>\n   <td>服务器无法满足Expect的请求头信息</td>\n   </tr>\n   <tr>\n   <td colspan=\"3\"></td>\n   </tr>\n   <tr>\n   <td>500</td>\n   <td>Internal Server Error</td>\n   <td>服务器内部错误，无法完成请求</td>\n   </tr>\n   <tr>\n   <td>501</td>\n   <td>Not Implemented</td>\n   <td>服务器不支持请求的功能，无法完成请求</td>\n   </tr>\n   <tr>\n   <td>502</td>\n   <td>Bad Gateway</td>\n   <td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>\n   </tr>\n   <tr>\n   <td>503</td>\n   <td>Service Unavailable</td>\n   <td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>\n   </tr>\n   <tr>\n   <td>504</td>\n   <td>Gateway Time-out</td>\n   <td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>\n   </tr>\n   <tr>\n   <td>505</td>\n   <td>HTTP Version not supported</td>\n   <td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>\n   </tr>\n   </tbody>\n   </table>","url":"","summary":"","reference":"参考资料|https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Status","dot":""},{"prefix":"","tag":"通用首部字段","suffix":"","desc":"# 通用首部字段\n<table data-evernote-id=\"409\" class=\"js-evernote-checked\">\n<thead>\n<tr>\n<th align=\"center\" data-evernote-id=\"504\" class=\"js-evernote-checked\">首部字段名</th>\n<th align=\"center\" data-evernote-id=\"505\" class=\"js-evernote-checked\">说明</th>\n</tr>\n</thead>\n<tbody><tr data-evernote-id=\"1025\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"506\" class=\"js-evernote-checked\">Cache-Control</td>\n<td align=\"center\" data-evernote-id=\"507\" class=\"js-evernote-checked\">控制缓存的行为</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"508\" class=\"js-evernote-checked\">Connection</td>\n<td align=\"center\" data-evernote-id=\"509\" class=\"js-evernote-checked\">逐挑首部、连接的管理</td>\n</tr>\n<tr data-evernote-id=\"1026\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"510\" class=\"js-evernote-checked\">Date</td>\n<td align=\"center\" data-evernote-id=\"511\" class=\"js-evernote-checked\">创建报文的日期时间</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"512\" class=\"js-evernote-checked\">Pragma</td>\n<td align=\"center\" data-evernote-id=\"513\" class=\"js-evernote-checked\">报文指令</td>\n</tr>\n<tr data-evernote-id=\"1027\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"514\" class=\"js-evernote-checked\">Trailer</td>\n<td align=\"center\" data-evernote-id=\"515\" class=\"js-evernote-checked\">报文末端的首部一览</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"516\" class=\"js-evernote-checked\">Transfer-Encoding</td>\n<td align=\"center\" data-evernote-id=\"517\" class=\"js-evernote-checked\">指定报文主体的传输编码方式</td>\n</tr>\n<tr data-evernote-id=\"1028\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"518\" class=\"js-evernote-checked\">Upgrade</td>\n<td align=\"center\" data-evernote-id=\"519\" class=\"js-evernote-checked\">升级为其他协议</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"520\" class=\"js-evernote-checked\">Via</td>\n<td align=\"center\" data-evernote-id=\"521\" class=\"js-evernote-checked\">代理服务器的相关信息</td>\n</tr>\n<tr data-evernote-id=\"1029\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"522\" class=\"js-evernote-checked\">Warning</td>\n<td align=\"center\" data-evernote-id=\"523\" class=\"js-evernote-checked\">错误通知</td>\n</tr>\n</tbody></table>","url":"","summary":"","reference":"MDN|https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\n常用字段|https://andrewpqc.github.io/2018/07/15/http2/","dot":""},{"prefix":"","tag":"请求首部字段","suffix":"","desc":"# 请求首部字段\n<table data-evernote-id=\"436\" class=\"js-evernote-checked\">\n<thead>\n<tr>\n<th align=\"center\" data-evernote-id=\"657\" class=\"js-evernote-checked\">首部字段名</th>\n<th align=\"center\" data-evernote-id=\"658\" class=\"js-evernote-checked\">说明</th>\n</tr>\n</thead>\n<tbody><tr data-evernote-id=\"1067\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"659\" class=\"js-evernote-checked\">Accept</td>\n<td align=\"center\" data-evernote-id=\"660\" class=\"js-evernote-checked\">用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"661\" class=\"js-evernote-checked\">Accept-Charset</td>\n<td align=\"center\" data-evernote-id=\"662\" class=\"js-evernote-checked\">优先的字符集</td>\n</tr>\n<tr data-evernote-id=\"1068\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"663\" class=\"js-evernote-checked\">Accept-Encoding</td>\n<td align=\"center\" data-evernote-id=\"664\" class=\"js-evernote-checked\">优先的内容编码</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"665\" class=\"js-evernote-checked\">Accept-Language</td>\n<td align=\"center\" data-evernote-id=\"666\" class=\"js-evernote-checked\">优先的语言（自然语言）</td>\n</tr>\n<tr data-evernote-id=\"1069\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"667\" class=\"js-evernote-checked\">Authorization</td>\n<td align=\"center\" data-evernote-id=\"668\" class=\"js-evernote-checked\">Web认证信息</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"669\" class=\"js-evernote-checked\">Expect</td>\n<td align=\"center\" data-evernote-id=\"670\" class=\"js-evernote-checked\">期待服务器的特定行为</td>\n</tr>\n<tr data-evernote-id=\"1070\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"671\" class=\"js-evernote-checked\">From</td>\n<td align=\"center\" data-evernote-id=\"672\" class=\"js-evernote-checked\">用户的电子邮箱地址</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"673\" class=\"js-evernote-checked\">Host</td>\n<td align=\"center\" data-evernote-id=\"674\" class=\"js-evernote-checked\">请求资源所在服务器</td>\n</tr>\n<tr data-evernote-id=\"1071\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"675\" class=\"js-evernote-checked\">If-Match</td>\n<td align=\"center\" data-evernote-id=\"676\" class=\"js-evernote-checked\">比较实体标记（ETag）</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"677\" class=\"js-evernote-checked\">If-Modified-Since</td>\n<td align=\"center\" data-evernote-id=\"678\" class=\"js-evernote-checked\">比较资源的更新时间</td>\n</tr>\n<tr data-evernote-id=\"1072\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"679\" class=\"js-evernote-checked\">If-None-Match</td>\n<td align=\"center\" data-evernote-id=\"680\" class=\"js-evernote-checked\">比较实体标记（与 If-Macth 相反）</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"681\" class=\"js-evernote-checked\">If-Range</td>\n<td align=\"center\" data-evernote-id=\"682\" class=\"js-evernote-checked\">资源未更新时发送实体 Byte 的范围请求</td>\n</tr>\n<tr data-evernote-id=\"1073\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"683\" class=\"js-evernote-checked\">If-Unmodified-Since</td>\n<td align=\"center\" data-evernote-id=\"684\" class=\"js-evernote-checked\">比较资源的更新时间(与 If-Modified-Since 相反)</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"685\" class=\"js-evernote-checked\">Max-Forwards</td>\n<td align=\"center\" data-evernote-id=\"686\" class=\"js-evernote-checked\">最大传输逐跳数</td>\n</tr>\n<tr data-evernote-id=\"1074\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"687\" class=\"js-evernote-checked\">Proxy-Authorization</td>\n<td align=\"center\" data-evernote-id=\"688\" class=\"js-evernote-checked\">代理服务器要求客户端的认证信息</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"689\" class=\"js-evernote-checked\">Range</td>\n<td align=\"center\" data-evernote-id=\"690\" class=\"js-evernote-checked\">实体的字节范围请求</td>\n</tr>\n<tr data-evernote-id=\"1075\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"691\" class=\"js-evernote-checked\">Referer</td>\n<td align=\"center\" data-evernote-id=\"692\" class=\"js-evernote-checked\">对请求中 URI 的原始获取方</td>\n</tr>\n<tr>\n<td align=\"center\" data-evernote-id=\"693\" class=\"js-evernote-checked\">TE</td>\n<td align=\"center\" data-evernote-id=\"694\" class=\"js-evernote-checked\">传输编码的优先级</td>\n</tr>\n<tr data-evernote-id=\"1076\" class=\"js-evernote-checked\">\n<td align=\"center\" data-evernote-id=\"695\" class=\"js-evernote-checked\">User-Agent</td>\n<td align=\"center\" data-evernote-id=\"696\" class=\"js-evernote-checked\">HTTP 客户端程序的信息</td>\n</tr>\n</tbody></table>","url":"","summary":"","reference":"","dot":"","title":"请求"},{"prefix":"","tag":"响应首部字段","suffix":"","desc":"# 响应首部字段\n<table data-evernote-id=\"456\" class=\"js-evernote-checked\">\n   <thead>\n   <tr>\n   <th align=\"center\" data-evernote-id=\"739\" class=\"js-evernote-checked\">首部字段名</th>\n   <th align=\"center\" data-evernote-id=\"740\" class=\"js-evernote-checked\">说明</th>\n   </tr>\n   </thead>\n   <tbody><tr data-evernote-id=\"1097\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"741\" class=\"js-evernote-checked\">Accept-Ranges</td>\n   <td align=\"center\" data-evernote-id=\"742\" class=\"js-evernote-checked\">是否接受字节范围请求</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"743\" class=\"js-evernote-checked\">Age</td>\n   <td align=\"center\" data-evernote-id=\"744\" class=\"js-evernote-checked\">推算资源创建经过时间</td>\n   </tr>\n   <tr data-evernote-id=\"1098\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"745\" class=\"js-evernote-checked\">ETag</td>\n   <td align=\"center\" data-evernote-id=\"746\" class=\"js-evernote-checked\">资源的匹配信息</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"747\" class=\"js-evernote-checked\">Location</td>\n   <td align=\"center\" data-evernote-id=\"748\" class=\"js-evernote-checked\">令客户端重定向至指定 URI</td>\n   </tr>\n   <tr data-evernote-id=\"1099\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"749\" class=\"js-evernote-checked\">Proxy-Authenticate</td>\n   <td align=\"center\" data-evernote-id=\"750\" class=\"js-evernote-checked\">代理服务器对客户端的认证信息</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"751\" class=\"js-evernote-checked\">Retry-After</td>\n   <td align=\"center\" data-evernote-id=\"752\" class=\"js-evernote-checked\">对再次发起请求的时机要求</td>\n   </tr>\n   <tr data-evernote-id=\"1100\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"753\" class=\"js-evernote-checked\">Server</td>\n   <td align=\"center\" data-evernote-id=\"754\" class=\"js-evernote-checked\">HTTP 服务器的安装信息</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"755\" class=\"js-evernote-checked\">Vary</td>\n   <td align=\"center\" data-evernote-id=\"756\" class=\"js-evernote-checked\">代理服务器缓存的管理信息</td>\n   </tr>\n   <tr data-evernote-id=\"1101\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"757\" class=\"js-evernote-checked\">WWW-Authenticate</td>\n   <td align=\"center\" data-evernote-id=\"758\" class=\"js-evernote-checked\">服务器对客户端的认证信息</td>\n   </tr>\n   </tbody></table>","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"实体首部字段","suffix":"","desc":"# 实体首部字段\n<table data-evernote-id=\"466\" class=\"js-evernote-checked\">\n   <thead>\n   <tr>\n   <th align=\"center\" data-evernote-id=\"781\" class=\"js-evernote-checked\">首部字段名</th>\n   <th align=\"center\" data-evernote-id=\"782\" class=\"js-evernote-checked\">说明</th>\n   </tr>\n   </thead>\n   <tbody><tr data-evernote-id=\"1112\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"783\" class=\"js-evernote-checked\">Allow</td>\n   <td align=\"center\" data-evernote-id=\"784\" class=\"js-evernote-checked\">资源可支持的 HTTP 方法</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"785\" class=\"js-evernote-checked\">Content-Encoding</td>\n   <td align=\"center\" data-evernote-id=\"786\" class=\"js-evernote-checked\">实体主体适用的编码方式</td>\n   </tr>\n   <tr data-evernote-id=\"1113\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"787\" class=\"js-evernote-checked\">Content-Language</td>\n   <td align=\"center\" data-evernote-id=\"788\" class=\"js-evernote-checked\">实体主体的自然语言</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"789\" class=\"js-evernote-checked\">Content-Length</td>\n   <td align=\"center\" data-evernote-id=\"790\" class=\"js-evernote-checked\">实体主体的大小（单位：字节）</td>\n   </tr>\n   <tr data-evernote-id=\"1114\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"791\" class=\"js-evernote-checked\">Content-Location</td>\n   <td align=\"center\" data-evernote-id=\"792\" class=\"js-evernote-checked\">替代对应资源的 URI</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"793\" class=\"js-evernote-checked\">Content-MD5</td>\n   <td align=\"center\" data-evernote-id=\"794\" class=\"js-evernote-checked\">实体主体的报文摘要</td>\n   </tr>\n   <tr data-evernote-id=\"1115\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"795\" class=\"js-evernote-checked\">Content-Range</td>\n   <td align=\"center\" data-evernote-id=\"796\" class=\"js-evernote-checked\">实体主体的位置范围</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"797\" class=\"js-evernote-checked\">Content-Type</td>\n   <td align=\"center\" data-evernote-id=\"798\" class=\"js-evernote-checked\">实体主体的媒体类型</td>\n   </tr>\n   <tr data-evernote-id=\"1116\" class=\"js-evernote-checked\">\n   <td align=\"center\" data-evernote-id=\"799\" class=\"js-evernote-checked\">Expires</td>\n   <td align=\"center\" data-evernote-id=\"800\" class=\"js-evernote-checked\">实体主体过期的日期时间</td>\n   </tr>\n   <tr>\n   <td align=\"center\" data-evernote-id=\"801\" class=\"js-evernote-checked\">Last-Modified</td>\n   <td align=\"center\" data-evernote-id=\"802\" class=\"js-evernote-checked\">资源的最后修改日期时间</td>\n   </tr>\n   </tbody></table>","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"其它首部字段","suffix":"","desc":"# 其他首部字段\n+ X-Frame-Options `X-Frame-Options: DENY`\n    + DENY：拒绝\n    + SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。\n\n首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。\n\n----\n+ X-XSS-Protection `X-XSS-Protection: 1`\n    + 0 ：将 XSS 过滤设置成无效状态\n    + 1 ：将 XSS 过滤设置成有效状态\n\n首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。\n\n----","url":"","summary":"","reference":"","dot":""}]},{"title":"Content-Type","fold":false,"list":[{"prefix":"","tag":"application/x-www-form-urlencoded","suffix":"","desc":"1. 浏览器的原生form 表单，如果不设置 enctype 属性，那么最终就会此方式提交数据\n2. 提交的数据按照 `key1=val1&key2=val2` 的方式进行编码，key和val都进行了 URL 转码\n3. `jQuery` 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。","url":"","summary":"```\nPOST http://www.example.com HTTP/1.1\nContent-Type: application/x-www-form-urlencoded;charset=utf-8\n\ntitle=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3\n```","reference":"","dot":""},{"prefix":"","tag":"multipart/form-data","suffix":"","desc":"我们使用表单上传文件时，必须让 form 表单的 enctype 等于 multipart/form-data\n现阶段标准中原生 form 表单也只支持这两种方式","url":"","summary":"```\nPOST http://www.example.com HTTP/1.1\nContent-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA\n\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=\"text\"\n\ntitle\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"\nContent-Type: image/png\n\nPNG ... content of chrome.png ...\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA--\n```\n\n1. 首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。\n2. 以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。关于 multipart/form-data 的详细定义，请前往 [rfc1867](https://www.ietf.org/rfc/rfc1867.txt) 查看。","reference":"","dot":""},{"prefix":"","tag":"application/json","suffix":"","desc":"rest主流\nphp 就无法通过 $_POST 对象从上面的请求中获得内容","url":"","summary":"```\nPOST http://www.example.com HTTP/1.1 \nContent-Type: application/json;charset=utf-8\n\n{\"title\":\"test\",\"sub\":[1,2,3]}\n```","reference":"参考资料|https://imququ.com/post/four-ways-to-post-data-in-http.html","dot":""},{"prefix":"","tag":"text/plain","suffix":"","desc":"纯文本\n表单请求增加Origin字段","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"MIME类型","suffix":"","desc":"<table class=\"reference\"> \n\t<tbody><tr>\n       <th>文件扩展名</th>\n       <th>Content-Type(Mime-Type)</th>\n       <th>文件扩展名</th>\n       <th>Content-Type(Mime-Type)</th>\n     </tr>\n     </tbody><tbody>\n\t\t<tr>\n    \t\t<td>.*（ 二进制流，不知道下载文件类型）</td>\n    \t\t<td>application/octet-stream</td>\n\t\t\t<td>.tif</td>\n\t\t\t<td>image/tiff</td> \n    \t</tr>\n      <tr>\n       <td>.001</td>\n       <td>application/x-001</td> \n       <td>.301</td>\n       <td>application/x-301</td>\n      </tr> \n      <tr>\n       <td>.323</td>\n       <td>text/h323</td> \n \n       <td>.906</td>\n       <td>application/x-906</td>\n      </tr> \n      <tr>\n       <td>.907</td>\n       <td>drawing/907</td> \n   \n       <td>.a11</td>\n       <td>application/x-a11</td>\n      </tr> \n      <tr>\n       <td>.acp</td>\n       <td>audio/x-mei-aac</td> \n     \n       <td>.ai</td>\n       <td>application/postscript</td>\n      </tr> \n      <tr>\n       <td>.aif</td>\n       <td>audio/aiff</td> \n      \n       <td>.aifc</td>\n       <td>audio/aiff</td>\n      </tr> \n      <tr>\n       <td>.aiff</td>\n       <td>audio/aiff</td> \n     \n       <td>.anv</td>\n       <td>application/x-anv</td>\n      </tr> \n      <tr>\n       <td>.asa</td>\n       <td>text/asa</td> \n    \n       <td>.asf</td>\n       <td>video/x-ms-asf</td>\n      </tr> \n      <tr>\n       <td>.asp</td>\n       <td>text/asp</td> \n    \n       <td>.asx</td>\n       <td>video/x-ms-asf</td>\n      </tr> \n      <tr>\n       <td>.au</td>\n       <td>audio/basic</td> \n     \n       <td>.avi</td>\n       <td>video/avi</td>\n      </tr> \n      <tr>\n       <td>.awf</td>\n       <td>application/vnd.adobe.workflow</td> \n   \n       <td>.biz</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.bmp</td>\n       <td>application/x-bmp</td> \n      \n       <td>.bot</td>\n       <td>application/x-bot</td>\n      </tr> \n      <tr>\n       <td>.c4t</td>\n       <td>application/x-c4t</td> \n      \n       <td>.c90</td>\n       <td>application/x-c90</td>\n      </tr> \n      <tr>\n       <td>.cal</td>\n       <td>application/x-cals</td> \n      \n       <td>.cat</td>\n       <td>application/vnd.ms-pki.seccat</td>\n      </tr> \n      <tr>\n       <td>.cdf</td>\n       <td>application/x-netcdf</td> \n     \n       <td>.cdr</td>\n       <td>application/x-cdr</td>\n      </tr> \n      <tr>\n       <td>.cel</td>\n       <td>application/x-cel</td> \n      \n       <td>.cer</td>\n       <td>application/x-x509-ca-cert</td>\n      </tr> \n      <tr>\n       <td>.cg4</td>\n       <td>application/x-g4</td> \n      \n       <td>.cgm</td>\n       <td>application/x-cgm</td>\n      </tr> \n      <tr>\n       <td>.cit</td>\n       <td>application/x-cit</td> \n     \n       <td>.class</td>\n       <td>java/*</td>\n      </tr> \n      <tr>\n       <td>.cml</td>\n       <td>text/xml</td> \n      \n       <td>.cmp</td>\n       <td>application/x-cmp</td>\n      </tr> \n      <tr>\n       <td>.cmx</td>\n       <td>application/x-cmx</td> \n    \n       <td>.cot</td>\n       <td>application/x-cot</td>\n      </tr> \n      <tr>\n       <td>.crl</td>\n       <td>application/pkix-crl</td> \n     \n       <td>.crt</td>\n       <td>application/x-x509-ca-cert</td>\n      </tr> \n      <tr>\n       <td>.csi</td>\n       <td>application/x-csi</td> \n      \n       <td>.css</td>\n       <td>text/css</td>\n      </tr> \n      <tr>\n       <td>.cut</td>\n       <td>application/x-cut</td> \n      \n       <td>.dbf</td>\n       <td>application/x-dbf</td>\n      </tr> \n      <tr>\n       <td>.dbm</td>\n       <td>application/x-dbm</td> \n      \n       <td>.dbx</td>\n       <td>application/x-dbx</td>\n      </tr> \n      <tr>\n       <td>.dcd</td>\n       <td>text/xml</td> \n      \n       <td>.dcx</td>\n       <td>application/x-dcx</td>\n      </tr> \n      <tr>\n       <td>.der</td>\n       <td>application/x-x509-ca-cert</td> \n      \n       <td>.dgn</td>\n       <td>application/x-dgn</td>\n      </tr> \n      <tr>\n       <td>.dib</td>\n       <td>application/x-dib</td> \n   \n       <td>.dll</td>\n       <td>application/x-msdownload</td>\n      </tr> \n      <tr>\n       <td>.doc</td>\n       <td>application/msword</td> \n     \n       <td>.dot</td>\n       <td>application/msword</td>\n      </tr> \n      <tr>\n       <td>.drw</td>\n       <td>application/x-drw</td> \n     \n       <td>.dtd</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.dwf</td>\n       <td>Model/vnd.dwf</td> \n     \n       <td>.dwf</td>\n       <td>application/x-dwf</td>\n      </tr> \n      <tr>\n       <td>.dwg</td>\n       <td>application/x-dwg</td> \n      \n       <td>.dxb</td>\n       <td>application/x-dxb</td>\n      </tr> \n      <tr>\n       <td>.dxf</td>\n       <td>application/x-dxf</td> \n      \n       <td>.edn</td>\n       <td>application/vnd.adobe.edn</td>\n      </tr> \n      <tr>\n       <td>.emf</td>\n       <td>application/x-emf</td> \n     \n       <td>.eml</td>\n       <td>message/rfc822</td>\n      </tr> \n      <tr>\n       <td>.ent</td>\n       <td>text/xml</td> \n      \n       <td>.epi</td>\n       <td>application/x-epi</td>\n      </tr> \n      <tr>\n       <td>.eps</td>\n       <td>application/x-ps</td> \n     \n       <td>.eps</td>\n       <td>application/postscript</td>\n      </tr> \n      <tr>\n       <td>.etd</td>\n       <td>application/x-ebx</td> \n     \n       <td>.exe</td>\n       <td>application/x-msdownload</td>\n      </tr> \n      <tr>\n       <td>.fax</td>\n       <td>image/fax</td> \n      \n       <td>.fdf</td>\n       <td>application/vnd.fdf</td>\n      </tr> \n      <tr>\n       <td>.fif</td>\n       <td>application/fractals</td> \n      \n       <td>.fo</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.frm</td>\n       <td>application/x-frm</td> \n      \n       <td>.g4</td>\n       <td>application/x-g4</td>\n      </tr> \n      <tr>\n       <td>.gbr</td>\n       <td>application/x-gbr</td> \n     \n       <td>.</td>\n       <td>application/x-</td>\n      </tr> \n      <tr>\n       <td>.gif</td>\n       <td>image/gif</td> \n      \n       <td>.gl2</td>\n       <td>application/x-gl2</td>\n      </tr> \n      <tr>\n       <td>.gp4</td>\n       <td>application/x-gp4</td> \n      \n       <td>.hgl</td>\n       <td>application/x-hgl</td>\n      </tr> \n      <tr>\n       <td>.hmr</td>\n       <td>application/x-hmr</td> \n     \n       <td>.hpg</td>\n       <td>application/x-hpgl</td>\n      </tr> \n      <tr>\n       <td>.hpl</td>\n       <td>application/x-hpl</td> \n     \n       <td>.hqx</td>\n       <td>application/mac-binhex40</td>\n      </tr> \n      <tr>\n       <td>.hrf</td>\n       <td>application/x-hrf</td> \n      \n       <td>.hta</td>\n       <td>application/hta</td>\n      </tr> \n      <tr>\n       <td>.htc</td>\n       <td>text/x-component</td> \n      \n       <td>.htm</td>\n       <td>text/html</td>\n      </tr> \n      <tr>\n       <td>.html</td>\n       <td>text/html</td> \n      \n       <td>.htt</td>\n       <td>text/webviewhtml</td>\n      </tr> \n      <tr>\n       <td>.htx</td>\n       <td>text/html</td> \n      \n       <td>.icb</td>\n       <td>application/x-icb</td>\n      </tr> \n      <tr>\n       <td>.ico</td>\n       <td>image/x-icon</td> \n     \n       <td>.ico</td>\n       <td>application/x-ico</td>\n      </tr> \n      <tr>\n       <td>.iff</td>\n       <td>application/x-iff</td> \n      \n       <td>.ig4</td>\n       <td>application/x-g4</td>\n      </tr> \n      <tr>\n       <td>.igs</td>\n       <td>application/x-igs</td> \n      \n       <td>.iii</td>\n       <td>application/x-iphone</td>\n      </tr> \n      <tr>\n       <td>.img</td>\n       <td>application/x-img</td> \n      \n       <td>.ins</td>\n       <td>application/x-internet-signup</td>\n      </tr> \n      <tr>\n       <td>.isp</td>\n       <td>application/x-internet-signup</td> \n      \n       <td>.IVF</td>\n       <td>video/x-ivf</td>\n      </tr> \n      <tr>\n       <td>.java</td>\n       <td>java/*</td> \n      \n       <td>.jfif</td>\n       <td>image/jpeg</td>\n      </tr> \n      <tr>\n       <td>.jpe</td>\n       <td>image/jpeg</td> \n      \n       <td>.jpe</td>\n       <td>application/x-jpe</td>\n      </tr> \n      <tr>\n       <td>.jpeg</td>\n       <td>image/jpeg</td> \n      \n       <td>.jpg</td>\n       <td>image/jpeg</td>\n      </tr> \n      <tr>\n       <td>.jpg</td>\n       <td>application/x-jpg</td> \n      \n       <td>.js</td>\n       <td>application/x-javascript</td>\n      </tr> \n      <tr>\n       <td>.jsp</td>\n       <td>text/html</td> \n      \n       <td>.la1</td>\n       <td>audio/x-liquid-file</td>\n      </tr> \n      <tr>\n       <td>.lar</td>\n       <td>application/x-laplayer-reg</td> \n     \n       <td>.latex</td>\n       <td>application/x-latex</td>\n      </tr> \n      <tr>\n       <td>.lavs</td>\n       <td>audio/x-liquid-secure</td> \n   \n       <td>.lbm</td>\n       <td>application/x-lbm</td>\n      </tr> \n      <tr>\n       <td>.lmsff</td>\n       <td>audio/x-la-lms</td> \n      \n       <td>.ls</td>\n       <td>application/x-javascript</td>\n      </tr> \n      <tr>\n       <td>.ltr</td>\n       <td>application/x-ltr</td> \n     \n       <td>.m1v</td>\n       <td>video/x-mpeg</td>\n      </tr> \n      <tr>\n       <td>.m2v</td>\n       <td>video/x-mpeg</td> \n      \n       <td>.m3u</td>\n       <td>audio/mpegurl</td>\n      </tr> \n      <tr>\n       <td>.m4e</td>\n       <td>video/mpeg4</td> \n     \n       <td>.mac</td>\n       <td>application/x-mac</td>\n      </tr> \n      <tr>\n       <td>.man</td>\n       <td>application/x-troff-man</td> \n     \n       <td>.math</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.mdb</td>\n       <td>application/msaccess</td> \n      \n       <td>.mdb</td>\n       <td>application/x-mdb</td>\n      </tr> \n      <tr>\n       <td>.mfp</td>\n       <td>application/x-shockwave-flash</td> \n     \n       <td>.mht</td>\n       <td>message/rfc822</td>\n      </tr> \n      <tr>\n       <td>.mhtml</td>\n       <td>message/rfc822</td> \n      \n       <td>.mi</td>\n       <td>application/x-mi</td>\n      </tr> \n      <tr>\n       <td>.mid</td>\n       <td>audio/mid</td> \n      \n       <td>.midi</td>\n       <td>audio/mid</td>\n      </tr> \n      <tr>\n       <td>.mil</td>\n       <td>application/x-mil</td> \n    \n       <td>.mml</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.mnd</td>\n       <td>audio/x-musicnet-download</td> \n      \n       <td>.mns</td>\n       <td>audio/x-musicnet-stream</td>\n      </tr> \n      <tr>\n       <td>.mocha</td>\n       <td>application/x-javascript</td> \n     \n       <td>.movie</td>\n       <td>video/x-sgi-movie</td>\n      </tr> \n      <tr>\n       <td>.mp1</td>\n       <td>audio/mp1</td> \n     \n       <td>.mp2</td>\n       <td>audio/mp2</td>\n      </tr> \n      <tr>\n       <td>.mp2v</td>\n       <td>video/mpeg</td> \n      \n       <td>.mp3</td>\n       <td>audio/mp3</td>\n      </tr> \n      <tr>\n       <td>.mp4</td>\n       <td>video/mpeg4</td> \n     \n       <td>.mpa</td>\n       <td>video/x-mpg</td>\n      </tr> \n      <tr>\n       <td>.mpd</td>\n       <td>application/vnd.ms-project</td> \n      \n       <td>.mpe</td>\n       <td>video/x-mpeg</td>\n      </tr> \n      <tr>\n       <td>.mpeg</td>\n       <td>video/mpg</td> \n      \n       <td>.mpg</td>\n       <td>video/mpg</td>\n      </tr> \n      <tr>\n       <td>.mpga</td>\n       <td>audio/rn-mpeg</td> \n      \n       <td>.mpp</td>\n       <td>application/vnd.ms-project</td>\n      </tr> \n      <tr>\n       <td>.mps</td>\n       <td>video/x-mpeg</td> \n      \n       <td>.mpt</td>\n       <td>application/vnd.ms-project</td>\n      </tr> \n      <tr>\n       <td>.mpv</td>\n       <td>video/mpg</td> \n     \n       <td>.mpv2</td>\n       <td>video/mpeg</td>\n      </tr> \n      <tr>\n       <td>.mpw</td>\n       <td>application/vnd.ms-project</td> \n      \n       <td>.mpx</td>\n       <td>application/vnd.ms-project</td>\n      </tr> \n      <tr>\n       <td>.mtx</td>\n       <td>text/xml</td> \n    \n       <td>.mxp</td>\n       <td>application/x-mmxp</td>\n      </tr> \n      <tr>\n       <td>.net</td>\n       <td>image/pnetvue</td> \n      \n       <td>.nrf</td>\n       <td>application/x-nrf</td>\n      </tr> \n      <tr>\n       <td>.nws</td>\n       <td>message/rfc822</td> \n      \n       <td>.odc</td>\n       <td>text/x-ms-odc</td>\n      </tr> \n      <tr>\n       <td>.out</td>\n       <td>application/x-out</td> \n      \n       <td>.p10</td>\n       <td>application/pkcs10</td>\n      </tr> \n      <tr>\n       <td>.p12</td>\n       <td>application/x-pkcs12</td> \n     \n       <td>.p7b</td>\n       <td>application/x-pkcs7-certificates</td>\n      </tr> \n      <tr>\n       <td>.p7c</td>\n       <td>application/pkcs7-mime</td> \n     \n       <td>.p7m</td>\n       <td>application/pkcs7-mime</td>\n      </tr> \n      <tr>\n       <td>.p7r</td>\n       <td>application/x-pkcs7-certreqresp</td> \n     \n       <td>.p7s</td>\n       <td>application/pkcs7-signature</td>\n      </tr> \n      <tr>\n       <td>.pc5</td>\n       <td>application/x-pc5</td> \n      \n       <td>.pci</td>\n       <td>application/x-pci</td>\n      </tr> \n      <tr>\n       <td>.pcl</td>\n       <td>application/x-pcl</td> \n      \n       <td>.pcx</td>\n       <td>application/x-pcx</td>\n      </tr> \n      <tr>\n       <td>.pdf</td>\n       <td>application/pdf</td> \n      \n       <td>.pdf</td>\n       <td>application/pdf</td>\n      </tr> \n      <tr>\n       <td>.pdx</td>\n       <td>application/vnd.adobe.pdx</td> \n      \n       <td>.pfx</td>\n       <td>application/x-pkcs12</td>\n      </tr> \n      <tr>\n       <td>.pgl</td>\n       <td>application/x-pgl</td> \n     \n       <td>.pic</td>\n       <td>application/x-pic</td>\n      </tr> \n      <tr>\n       <td>.pko</td>\n       <td>application/vnd.ms-pki.pko</td> \n     \n       <td>.pl</td>\n       <td>application/x-perl</td>\n      </tr> \n      <tr>\n       <td>.plg</td>\n       <td>text/html</td> \n       <td>.pls</td>\n       <td>audio/scpls</td>\n      </tr> \n      <tr>\n       <td>.plt</td>\n       <td>application/x-plt</td> \n       <td>.png</td>\n       <td>image/png</td>\n      </tr> \n      <tr>\n       <td>.png</td>\n       <td>application/x-png</td> \n       <td>.pot</td>\n       <td>application/vnd.ms-powerpoint</td>\n      </tr> \n      <tr>\n       <td>.ppa</td>\n       <td>application/vnd.ms-powerpoint</td> \n       <td>.ppm</td>\n       <td>application/x-ppm</td>\n      </tr> \n      <tr>\n       <td>.pps</td>\n       <td>application/vnd.ms-powerpoint</td> \n       <td>.ppt</td>\n       <td>application/vnd.ms-powerpoint</td>\n      </tr> \n      <tr>\n       <td>.ppt</td>\n       <td>application/x-ppt</td> \n       <td>.pr</td>\n       <td>application/x-pr</td>\n      </tr> \n      <tr>\n       <td>.prf</td>\n       <td>application/pics-rules</td> \n       <td>.prn</td>\n       <td>application/x-prn</td>\n      </tr> \n      <tr>\n       <td>.prt</td>\n       <td>application/x-prt</td> \n       <td>.ps</td>\n       <td>application/x-ps</td>\n      </tr> \n      <tr>\n       <td>.ps</td>\n       <td>application/postscript</td> \n       <td>.ptn</td>\n       <td>application/x-ptn</td>\n      </tr> \n      <tr>\n       <td>.pwz</td>\n       <td>application/vnd.ms-powerpoint</td> \n       <td>.r3t</td>\n       <td>text/vnd.rn-realtext3d</td>\n      </tr> \n      <tr>\n       <td>.ra</td>\n       <td>audio/vnd.rn-realaudio</td> \n       <td>.ram</td>\n       <td>audio/x-pn-realaudio</td>\n      </tr> \n      <tr>\n       <td>.ras</td>\n       <td>application/x-ras</td> \n       <td>.rat</td>\n       <td>application/rat-file</td>\n      </tr> \n      <tr>\n       <td>.rdf</td>\n       <td>text/xml</td> \n       <td>.rec</td>\n       <td>application/vnd.rn-recording</td>\n      </tr> \n      <tr>\n       <td>.red</td>\n       <td>application/x-red</td> \n       <td>.rgb</td>\n       <td>application/x-rgb</td>\n      </tr> \n      <tr>\n       <td>.rjs</td>\n       <td>application/vnd.rn-realsystem-rjs</td> \n       <td>.rjt</td>\n       <td>application/vnd.rn-realsystem-rjt</td>\n      </tr> \n      <tr>\n       <td>.rlc</td>\n       <td>application/x-rlc</td> \n       <td>.rle</td>\n       <td>application/x-rle</td>\n      </tr> \n      <tr>\n       <td>.rm</td>\n       <td>application/vnd.rn-realmedia</td> \n       <td>.rmf</td>\n       <td>application/vnd.adobe.rmf</td>\n      </tr> \n      <tr>\n       <td>.rmi</td>\n       <td>audio/mid</td> \n       <td>.rmj</td>\n       <td>application/vnd.rn-realsystem-rmj</td>\n      </tr> \n      <tr>\n       <td>.rmm</td>\n       <td>audio/x-pn-realaudio</td> \n       <td>.rmp</td>\n       <td>application/vnd.rn-rn_music_package</td>\n      </tr> \n      <tr>\n       <td>.rms</td>\n       <td>application/vnd.rn-realmedia-secure</td> \n       <td>.rmvb</td>\n       <td>application/vnd.rn-realmedia-vbr</td>\n      </tr> \n      <tr>\n       <td>.rmx</td>\n       <td>application/vnd.rn-realsystem-rmx</td> \n       <td>.rnx</td>\n       <td>application/vnd.rn-realplayer</td>\n      </tr> \n      <tr>\n       <td>.rp</td>\n       <td>image/vnd.rn-realpix</td> \n       <td>.rpm</td>\n       <td>audio/x-pn-realaudio-plugin</td>\n      </tr> \n      <tr>\n       <td>.rsml</td>\n       <td>application/vnd.rn-rsml</td> \n       <td>.rt</td>\n       <td>text/vnd.rn-realtext</td>\n      </tr> \n      <tr>\n       <td>.rtf</td>\n       <td>application/msword</td> \n       <td>.rtf</td>\n       <td>application/x-rtf</td>\n      </tr> \n      <tr>\n       <td>.rv</td>\n       <td>video/vnd.rn-realvideo</td> \n       <td>.sam</td>\n       <td>application/x-sam</td>\n      </tr> \n      <tr>\n       <td>.sat</td>\n       <td>application/x-sat</td> \n       <td>.sdp</td>\n       <td>application/sdp</td>\n      </tr> \n      <tr>\n       <td>.sdw</td>\n       <td>application/x-sdw</td> \n       <td>.sit</td>\n       <td>application/x-stuffit</td>\n      </tr> \n      <tr>\n       <td>.slb</td>\n       <td>application/x-slb</td> \n       <td>.sld</td>\n       <td>application/x-sld</td>\n      </tr> \n      <tr>\n       <td>.slk</td>\n       <td>drawing/x-slk</td> \n       <td>.smi</td>\n       <td>application/smil</td>\n      </tr> \n      <tr>\n       <td>.smil</td>\n       <td>application/smil</td> \n       <td>.smk</td>\n       <td>application/x-smk</td>\n      </tr> \n      <tr>\n       <td>.snd</td>\n       <td>audio/basic</td> \n       <td>.sol</td>\n       <td>text/plain</td>\n      </tr> \n      <tr>\n       <td>.sor</td>\n       <td>text/plain</td> \n       <td>.spc</td>\n       <td>application/x-pkcs7-certificates</td>\n      </tr> \n      <tr>\n       <td>.spl</td>\n       <td>application/futuresplash</td> \n       <td>.spp</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.ssm</td>\n       <td>application/streamingmedia</td> \n       <td>.sst</td>\n       <td>application/vnd.ms-pki.certstore</td>\n      </tr> \n      <tr>\n       <td>.stl</td>\n       <td>application/vnd.ms-pki.stl</td> \n       <td>.stm</td>\n       <td>text/html</td>\n      </tr> \n      <tr>\n       <td>.sty</td>\n       <td>application/x-sty</td> \n       <td>.svg</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.swf</td>\n       <td>application/x-shockwave-flash</td> \n       <td>.tdf</td>\n       <td>application/x-tdf</td>\n      </tr> \n      <tr>\n       <td>.tg4</td>\n       <td>application/x-tg4</td> \n       <td>.tga</td>\n       <td>application/x-tga</td>\n      </tr> \n      <tr>\n       <td>.tif</td>\n       <td>image/tiff</td> \n       <td>.tif</td>\n       <td>application/x-tif</td>\n      </tr> \n      <tr>\n       <td>.tiff</td>\n       <td>image/tiff</td> \n       <td>.tld</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.top</td>\n       <td>drawing/x-top</td> \n       <td>.torrent</td>\n       <td>application/x-bittorrent</td>\n      </tr> \n      <tr>\n       <td>.tsd</td>\n       <td>text/xml</td> \n       <td>.txt</td>\n       <td>text/plain</td>\n      </tr> \n      <tr>\n       <td>.uin</td>\n       <td>application/x-icq</td> \n       <td>.uls</td>\n       <td>text/iuls</td>\n      </tr> \n      <tr>\n       <td>.vcf</td>\n       <td>text/x-vcard</td> \n       <td>.vda</td>\n       <td>application/x-vda</td>\n      </tr> \n      <tr>\n       <td>.vdx</td>\n       <td>application/vnd.visio</td> \n       <td>.vml</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.vpg</td>\n       <td>application/x-vpeg005</td> \n       <td>.vsd</td>\n       <td>application/vnd.visio</td>\n      </tr> \n      <tr>\n       <td>.vsd</td>\n       <td>application/x-vsd</td> \n       <td>.vss</td>\n       <td>application/vnd.visio</td>\n      </tr> \n      <tr>\n       <td>.vst</td>\n       <td>application/vnd.visio</td> \n       <td>.vst</td>\n       <td>application/x-vst</td>\n      </tr> \n      <tr>\n       <td>.vsw</td>\n       <td>application/vnd.visio</td> \n       <td>.vsx</td>\n       <td>application/vnd.visio</td>\n      </tr> \n      <tr>\n       <td>.vtx</td>\n       <td>application/vnd.visio</td> \n       <td>.vxml</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.wav</td>\n       <td>audio/wav</td> \n       <td>.wax</td>\n       <td>audio/x-ms-wax</td>\n      </tr> \n      <tr>\n       <td>.wb1</td>\n       <td>application/x-wb1</td> \n       <td>.wb2</td>\n       <td>application/x-wb2</td>\n      </tr> \n      <tr>\n       <td>.wb3</td>\n       <td>application/x-wb3</td> \n       <td>.wbmp</td>\n       <td>image/vnd.wap.wbmp</td>\n      </tr> \n      <tr>\n       <td>.wiz</td>\n       <td>application/msword</td> \n       <td>.wk3</td>\n       <td>application/x-wk3</td>\n      </tr> \n      <tr>\n       <td>.wk4</td>\n       <td>application/x-wk4</td> \n       <td>.wkq</td>\n       <td>application/x-wkq</td>\n      </tr> \n      <tr>\n       <td>.wks</td>\n       <td>application/x-wks</td> \n       <td>.wm</td>\n       <td>video/x-ms-wm</td>\n      </tr> \n      <tr>\n       <td>.wma</td>\n       <td>audio/x-ms-wma</td> \n       <td>.wmd</td>\n       <td>application/x-ms-wmd</td>\n      </tr> \n      <tr>\n       <td>.wmf</td>\n       <td>application/x-wmf</td> \n       <td>.wml</td>\n       <td>text/vnd.wap.wml</td>\n      </tr> \n      <tr>\n       <td>.wmv</td>\n       <td>video/x-ms-wmv</td> \n       <td>.wmx</td>\n       <td>video/x-ms-wmx</td>\n      </tr> \n      <tr>\n       <td>.wmz</td>\n       <td>application/x-ms-wmz</td> \n       <td>.wp6</td>\n       <td>application/x-wp6</td>\n      </tr> \n      <tr>\n       <td>.wpd</td>\n       <td>application/x-wpd</td> \n       <td>.wpg</td>\n       <td>application/x-wpg</td>\n      </tr> \n      <tr>\n       <td>.wpl</td>\n       <td>application/vnd.ms-wpl</td> \n       <td>.wq1</td>\n       <td>application/x-wq1</td>\n      </tr> \n      <tr>\n       <td>.wr1</td>\n       <td>application/x-wr1</td> \n       <td>.wri</td>\n       <td>application/x-wri</td>\n      </tr> \n      <tr>\n       <td>.wrk</td>\n       <td>application/x-wrk</td> \n       <td>.ws</td>\n       <td>application/x-ws</td>\n      </tr> \n      <tr>\n       <td>.ws2</td>\n       <td>application/x-ws</td> \n       <td>.wsc</td>\n       <td>text/scriptlet</td>\n      </tr> \n      <tr>\n       <td>.wsdl</td>\n       <td>text/xml</td> \n       <td>.wvx</td>\n       <td>video/x-ms-wvx</td>\n      </tr> \n      <tr>\n       <td>.xdp</td>\n       <td>application/vnd.adobe.xdp</td> \n       <td>.xdr</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.xfd</td>\n       <td>application/vnd.adobe.xfd</td> \n       <td>.xfdf</td>\n       <td>application/vnd.adobe.xfdf</td>\n      </tr> \n      <tr>\n       <td>.xhtml</td>\n       <td>text/html</td> \n       <td>.xls</td>\n       <td>application/vnd.ms-excel</td>\n      </tr> \n      <tr>\n       <td>.xls</td>\n       <td>application/x-xls</td> \n       <td>.xlw</td>\n       <td>application/x-xlw</td>\n      </tr> \n      <tr>\n       <td>.xml</td>\n       <td>text/xml</td> \n       <td>.xpl</td>\n       <td>audio/scpls</td>\n      </tr> \n      <tr>\n       <td>.xq</td>\n       <td>text/xml</td> \n       <td>.xql</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.xquery</td>\n       <td>text/xml</td> \n       <td>.xsd</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.xsl</td>\n       <td>text/xml</td> \n       <td>.xslt</td>\n       <td>text/xml</td>\n      </tr> \n      <tr>\n       <td>.xwd</td>\n       <td>application/x-xwd</td> \n       <td>.x_b</td>\n       <td>application/x-x_b</td>\n      </tr>\n\t  <tr>\n       <td>.sis</td>\n       <td>application/vnd.symbian.install</td>\n\t   <td>.sisx</td>\n       <td>application/vnd.symbian.install</td>\n      </tr>\n      <tr>\n       <td>.x_t</td>\n       <td>application/x-x_t</td>\n\t   <td>.ipa</td>\n       <td>application/vnd.iphone</td>\n      </tr> \n\t  <tr>\n       <td>.apk</td>\n       <td>application/vnd.android.package-archive</td>\n\t   <td>.xap</td>\n       <td>application/x-silverlight-app</td>\n      </tr>\n     </tbody>\n    </table>","url":"","summary":"","reference":"MIME类型|https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types\n常见MIME类型|https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types","dot":""}]},{"title":"CORS","fold":false,"list":[{"prefix":"","tag":"Access-Control-Allow-Origin","suffix":"","desc":"服务端：接受的请求源\n`Access-Control-Allow-Origin: *`\n`Access-Control-Allow-Origin: https://developer.mozilla.org`","url":"","summary":"","reference":"参考资料|https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS","dot":""},{"prefix":"","tag":"Access-Control-Expose-Headers","suffix":"","desc":"服务端：可获取的额外响应标头\n`Access-Control-Expose-Headers: <header-name>, <header-name>, ...`\n`Access-Control-Expose-Headers: *`","url":"","summary":"CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个服务器返回的基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。","reference":"参考资料|https://wangdoc.com/javascript/bom/cors.html","dot":""},{"prefix":"jsonp","tag":" ","suffix":"","desc":"script不受同源政策限制，可以跨域请求。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"缓存","barcolor":"","fold":false,"box":[{"title":"Cache-control","fold":false,"list":[{"prefix":"Cache-control:","tag":"no-store","suffix":"","desc":"禁止进行缓存\n缓存中不得存储任何关于客户端请求和服务端响应的内容。\n每次由客户端发起的请求都会下载完整的响应内容。","url":"","summary":"","reference":"MDN|https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ","dot":""},{"prefix":"Cache-Control:","tag":"no-cache","suffix":"","desc":"强制确认缓存\n如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。","url":"","summary":"","reference":"","dot":""},{"prefix":"Cache-Control:","tag":"max-age","suffix":"=31536000","desc":"过期机制中，最重要的指令是 \"max-age=<seconds>\"，表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。","url":"","summary":"","reference":"","dot":""},{"prefix":"Cache-Control:","tag":"public","suffix":"|private","desc":"私有缓存和公共缓存\n\"public\" 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了\"public\"，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。\n而 \"private\" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。","url":"","summary":"","reference":"","dot":""}]},{"title":"Service Worker","fold":false,"list":[{"prefix":"","tag":"service worker","suffix":"","desc":"","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API\n参考资料|https://mp.weixin.qq.com/s/vI2bxaFsFSB5rGC4Bkr8vQ","dot":""},{"prefix":"","tag":"workbox","suffix":"","desc":"","url":"","summary":"","reference":"workbox|https://developers.google.com/web/tools/workbox\n参考资料|https://codelabs.developers.google.com/codelabs/workbox-lab-cn/index.html?index=..%2F..gddchina#0","dot":""}]},{"title":"优化","fold":false,"list":[{"prefix":"RTT","tag":" ","suffix":"","desc":"1RTT,通常1个HTTP数据报在14KB左右.\n同一个域名同时最多建立6个连接","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Cookie","barcolor":"","fold":false,"box":[{"title":"cookie","fold":false,"list":[{"prefix":"navigator","tag":".cookieEnabled","suffix":"","desc":"是否开启cookie（只读）","url":"","summary":"","reference":"","dot":""},{"prefix":"cookie.prop","tag":" ","suffix":"","desc":"+ `Max-Age=3600` 存在的秒数\n+ `Path=/` 路径\n+ `HttpOnly` 仅HTTP头\n+ `domain=.xx.com` 跨子域","url":"","summary":"","reference":"","dot":""}]},{"title":"客户端","fold":false,"list":[{"prefix":"","tag":"Cookie","suffix":"","desc":"请求头 `Cookie:key1=val1;key2=val2`\n浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。","url":"","summary":"","reference":"","dot":""},{"prefix":"document","tag":".cookie","suffix":"","desc":"一次读取全部可读cookie `document.cookie`\n写入一条cookie `document.cookie = \"foo=bar;prop=val\"`\n删除一条cookie `document.cookie = \"foo=bar;Max-Age=0\"`","url":"","summary":"# 同源\n浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享 Cookie（参见《同源政策》一章）。注意，这里不要求协议相同。也就是说，http://example.com设置的 Cookie，可以被https://example.com读取。\n\n# 转义\n写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值），这可以用encodeURIComponent方法达到。\n\n","reference":"","dot":""}]},{"title":"服务端","fold":false,"list":[{"prefix":"","tag":"Set-Cookie","suffix":"","desc":"响应头 `Set-Cookie:key=val;HttpOnly;Max-Age=3600;SameSite=Lax`\n服务端响应多个cookie头","url":"","summary":"","reference":"参考资料|https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies","dot":""},{"prefix":"Set-Cookie:","tag":"key=val;prop","suffix":"","desc":"设置cookie `Set-Cookie:key=val;prop=val`\nHTTP 回应可以包含多个Set-Cookie字段，即在浏览器生成多个 Cookie。\n如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的key、domain、path和secure都匹配。","url":"","summary":"","reference":"","dot":""}]},{"title":"跨域发送","fold":false,"list":[{"prefix":"","tag":"Access-Control-Allow-Credentials","suffix":"","desc":"服务端设置 `Access-Control-Allow-Credentials: true`","url":"","summary":"如果服务器要求浏览器发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。","reference":"参考资料|https://wangdoc.com/javascript/bom/cors.html","dot":""},{"prefix":"xhr","tag":".withCredentials","suffix":"","desc":"客户端设置 `xhr.withCredentials = true`","url":"","summary":"","reference":"","dot":""}]},{"title":"跨域共享","fold":false,"list":[{"prefix":"document","tag":".domain","suffix":"","desc":"浏览器设置方案 `document.domain`","url":"","summary":"","reference":"","dot":""},{"prefix":"domain=.example.com","tag":" ","suffix":"","desc":"服务端设置方案 `domain=.example.com`","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Auth","barcolor":"","fold":false,"box":[{"title":"session","fold":false,"list":[{"prefix":"","tag":"session","suffix":"","desc":"1.接收来自跨子域请求时，需设置cookie的domain属性\n2.使用axios来发起请求时，需额外设置`withCredentials: true`\n3.服务端需设置`Access-Control-Allow-Credentials:true`\n4.Access-Control-Allow-Origin需设为请求域不能为*\n5.本地测试时，需对应绑定域名与证书","url":"","summary":"","reference":"seesion原理|https://zhuanlan.zhihu.com/p/47072519","dot":""},{"prefix":"","tag":"koa-session","suffix":"","desc":"# 设置\n```\napp.keys = ['some secret hurr'];\nconst CONFIG = {\n  key: 'koa:sess',  //需修改\n  maxAge: 86400000, //默认1天\n  renew: false, //是否自动刷新\n};\napp.use(session(CONFIG, app));\n```\n\n# 使用\n```\nlet n = ctx.session.views || 0;\n  ctx.session.views = ++n;\n  ctx.body = n + ' views';\n```","url":"","summary":"","reference":"koa-session|https://www.npmjs.com/package/koa-session","dot":""}]},{"title":"jwt","fold":false,"list":[{"prefix":"","tag":"jwt","suffix":"","desc":"","url":"","summary":"","reference":"入门教程|https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\n参考资料|https://mp.weixin.qq.com/s/Dt1X85geJ01J_ZiaiZibQw","dot":""},{"prefix":"","tag":"jsonwebtoken","suffix":"","desc":"# 生成\n```\nlet token = jwt.sign({\n  foo: 'bar'\n}, 'secret', { expiresIn: '2h' });\n```\n\n# 验证\n```\njwt.verify(token, 'secret', function(err, decoded) {\n  console.log(decoded.foo) // bar\n});\n//过期也会报错\n```","url":"","summary":"","reference":"jsonwebtoken|https://github.com/auth0/node-jsonwebtoken","dot":""}]},{"title":"oAuth","fold":false,"list":[{"prefix":"","tag":"oAuth2.0","suffix":"","desc":"","url":"","summary":"# github\n1. [教程](http://www.ruanyifeng.com/blog/2019/04/github-oauth.html)\n2. [文档](https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/)","reference":"教程1|https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n教程2|https://www.w3cschool.cn/oauth2/ukx21ja1.html\n理解1|https://www.ruanyifeng.com/blog/2019/04/oauth_design.html\n理解2|https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html","dot":""}]}]}]},{"column":[{"title":"WebSocket","barcolor":"","fold":false,"box":[{"title":"客户端","fold":false,"list":[{"prefix":"","tag":"new WebSocket","suffix":"(ws://url)","desc":"新建WebSocket实例","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"readyState","suffix":"","desc":"readyState属性返回实例对象的当前状态，共有四种。\nCONNECTING：值为0，表示正在连接。\nOPEN：值为1，表示连接成功，可以通信了。\nCLOSING：值为2，表示连接正在关闭。\nCLOSED：值为3，表示连接已经关闭，或者打开连接失败。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"binaryType","suffix":"","desc":"指定收到的二进制数据类型","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.","tag":"bufferedAmount","suffix":"","desc":"表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。","url":"","summary":"```\nvar data = new ArrayBuffer(10000000);\nsocket.send(data);\n\nif (socket.bufferedAmount === 0) {\n  // 发送完毕\n} else {\n  // 发送还没结束\n}\n```","reference":"","dot":""},{"prefix":"ws.addEventListener(","tag":"<event>","suffix":",fn)","desc":"+ open 连接成功\n+ close 连接关闭\n+ message 收到服务器数据 \n+ error 发生错误","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".send","suffix":"(data)","desc":"发送数据","url":"","summary":"发送 Blob 对象\n```\nvar file = document\n  .querySelector('input[type=\"file\"]')\n  .files[0];\nws.send(file);\n```\n发送 ArrayBuffer 对象\n```\n// Sending canvas ImageData as ArrayBuffer\nvar img = canvas_context.getImageData(0, 0, 400, 320);\nvar binary = new Uint8Array(img.data.length);\nfor (var i = 0; i < img.data.length; i++) {\n  binary[i] = img.data[i];\n}\nws.send(binary.buffer);\n```","reference":"","dot":""},{"prefix":"ws","tag":".close","suffix":"([code,data])","desc":"code 默认1005。\nreason 关闭原因","url":"","summary":"","reference":"","dot":""}]},{"title":"服务端","fold":false,"list":[{"prefix":"请求头与响应头","tag":" ","suffix":"","desc":"# 请求头\n```\nGET / HTTP/1.1\nConnection: Upgrade\nUpgrade: websocket\nHost: example.com\nOrigin: null\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\nSec-WebSocket-Version: 13\n```\n\n# 响应头\n```\nHTTP/1.1 101 Switching Protocols\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\nSec-WebSocket-Origin: null\nSec-WebSocket-Location: ws://example.com/\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"实现原理","tag":" ","suffix":"","desc":"服务端实现:\n1.根据请求头判断是否为WebSocket请求\n2.校验Sec-WebSocket-Key\n```\nconst GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\nconst key = headers['sec-websocket-key']\nconst hash = crypto.createHash('sha1') // 创建一个签名算法为sha1的哈希对象\nhash.update(`${key}${GUID}`)  // 将key和GUID连接后，更新到hash\nconst result = hash.digest('base64') // 生成base64字符串\n```","url":"","summary":"","reference":"","dot":"","title":"node server"},{"prefix":"","tag":"ws","suffix":"","desc":"","url":"https://github.com/websockets/ws","summary":"","reference":"参考资料1|https://blog.csdn.net/chencl1986/article/details/88411056\n参考资料2|https://juejin.im/post/5e01e10ce51d4557f17fc14a","dot":""},{"prefix":"","tag":"socket.io","suffix":"","desc":"","url":"https://www.w3cschool.cn/socket/socket-1olq2egc.html","summary":"","reference":"Github|https://github.com/socketio/socket.io","dot":""}]}]},{"title":"HTTP","barcolor":"","fold":false,"box":[{"title":"node server","fold":true,"list":[{"prefix":"","tag":"http.STATUS_CODES","suffix":"","desc":"所有标准 HTTP 响应状态码的集合，以及每个状态码的简短描述。\n例如， `http.STATUS_CODES[404] === 'Not Found'`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"http.createServer","suffix":"(fn(req,res))","desc":"创建HTTP服务器\nrequestListener 是一个自动添加到 'request' 事件的函数","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".on","suffix":"(event,fn)","desc":"+ checkContinue 每次收到 HTTP Expect: 100-continue 的请求时都会触发\n+ checkExpectation 每次收到带有 HTTP Expect 请求头的请求时触发，其中值不是 100-continue。 \n+ clientError 如果客户端连接触发 'error' 事件，则会在此处转发。 此事件的监听器负责关闭或销毁底层套接字。\n+ close 当服务器关闭时触发。\n+ connect 每次客户端请求 HTTP CONNECT 方法时触发。 如果未监听此事件，则请求 CONNECT 方法的客户端将关闭其连接。\n+ connection 建立新的 TCP 流时会触发此事件。\n+ request 每次有请求时都会触发。\n+ upgrade 每次客户端请求 HTTP 升级时发出。 ","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".listen","suffix":"(port)","desc":"启动 HTTP 服务器监听连接。","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".close","suffix":"(fn)","desc":"停止服务器接受新连接","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".setTimeout","suffix":"(ms,fn)","desc":"设置套接字的超时值，并在服务器对象上触发 'timeout' 事件，如果发生超时，则将套接字作为参数传入。\n默认情况下，服务器的超时值为 2 分钟，如果超时，套接字会自动销毁。","url":"","summary":"","reference":"","dot":""}]},{"title":"node IncomingMessage","fold":true,"list":[{"prefix":"msg","tag":".on","suffix":"('data',fn)","desc":"IncomingMessage 对象由 http.Server 或 http.ClientRequest 创建，并分别作为第一个参数传给 'request' 和 'response' 事件。 它可用于访问响应状态、消息头、以及数据。继承自: stream.Readable","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".method","suffix":"","desc":"请求方法为字符串。 只读。 示例：'GET'、 'DELETE'。","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".url","suffix":"","desc":"请求的 URL 字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".headers","suffix":"","desc":"消息头的名称和值的键值对。 消息头的名称都是小写的。","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".statusCode","suffix":"","desc":"3 位 HTTP 响应状态码。 例如 404。","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".statusMessage","suffix":"","desc":"HTTP 响应状态消息（原因短语）","url":"","summary":"","reference":"","dot":""},{"prefix":"msg","tag":".complete","suffix":"","desc":"如果已收到并成功解析完整的 HTTP 消息，则 message.complete 属性将为 true。","url":"","summary":"","reference":"","dot":""}]},{"title":"node ServerResponse","fold":true,"list":[{"prefix":"res","tag":".on","suffix":"(event,fn)","desc":"+ close 表明底层的连接已被终止。\n+ finish 响应发送后触发","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".writeHead","suffix":"(code,headers)","desc":"向请求发送响应头。\n```\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain'\n  })\n  .end(body);\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".setHeader","suffix":"(key,val)","desc":"为隐式响应头设置单个响应头的值。\n`response.flushHeaders()` 刷新响应头\n`response.getHeader(name)` 读出已排队但未发送到客户端的响应头。\n`response.getHeaderNames()` 返回一个数组，其中包含当前传出的响应头的唯一名称。 所有响应头名称都是小写的。\n`response.getHeaders()` 返回当前传出的响应头的浅拷贝。\n`response.hasHeader(name)` 如果当前在传出的响应头中设置了由 name 标识的响应头，则返回 true。 响应头名称匹配不区分大小写。\n`response.removeHeader(name)` 移除排队等待中的隐式发送的响应头。","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".statusCode","suffix":"","desc":"响应头发送到客户端后，此属性表示已发送的状态码。","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".statusMessage","suffix":"","desc":"响应头发送到客户端后，此属性表示已发送的状态消息。","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".write","suffix":"(chunk,fn)","desc":"这会发送一块响应主体。 可以多次调用该方法以提供连续的响应主体片段。","url":"","summary":"","reference":"","dot":""},{"prefix":"res","tag":".end","suffix":"([data],fn)","desc":"此方法向服务器发出信号，表明已发送所有响应头和主体，该服务器应该视为此消息已完成。 必须在每个响应上调用此 response.end() 方法。","url":"","summary":"","reference":"","dot":""}]},{"title":"node client","fold":true,"list":[{"prefix":"","tag":"http.get","suffix":"(url,fn(res))","desc":"用于发出get请求,自动调用end方法\n返回http.ClientRequest实例","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"http.request","suffix":"(opt,fn(res))","desc":"可设定具体选项,需要手动end\n返回http.ClientRequest实例","url":"","summary":"```\nconst postData = querystring.stringify({\n  'msg': '你好世界'\n});\n\nconst options = {\n  hostname: 'nodejs.cn',\n  port: 80,\n  path: '/upload',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData)\n  }\n};\n\nconst req = http.request(options, (res) => {\n  console.log(`状态码: ${res.statusCode}`);\n  console.log(`响应头: ${JSON.stringify(res.headers)}`);\n  res.setEncoding('utf8');\n  res.on('data', (chunk) => {\n    console.log(`响应主体: ${chunk}`);\n  });\n  res.on('end', () => {\n    console.log('响应中已无数据');\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`请求遇到问题: ${e.message}`);\n});\n\n// 将数据写入请求主体。\nreq.write(postData);\nreq.end();\n```","reference":"参考资料|http://nodejs.cn/api/http.html#http_http_request_url_options_callback","dot":""}]},{"title":"node ClientRequest","fold":true,"list":[{"prefix":"req","tag":".on","suffix":"(event,fn)","desc":"+ abort 当请求被客户端中止时触发。 此事件仅在第一次调用 abort() 时触发。\n+ connect 每次服务器使用 CONNECT 方法响应请求时都会触发\n+ continue 当服务器发送 100 Continue HTTP 响应时触发\n+ information 服务器发送 1xx 中间响应（不包括 101 Upgrade）时触发\n+ response 当收到此请求的响应时触发。 此事件仅触发一次\n+ socket 此事件保证传入 <net.Socket> 类（<stream.Duplex> 的子类）的实例\n+ timeout 当底层套接字因不活动而超时时触发。 这只会通知套接字已空闲。 必须手动中止请求。\n+ upgrade 每次服务器响应升级请求时发出。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".setHeader","suffix":"(key,val)","desc":"为请求头对象设置单个请求头的值。\n`req.getHeader(key)`读取请求中的一个请求头。 该名称不区分大小写。\n`req.removeHeader(key)`移除已定义到请求头对象中的请求头。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".write","suffix":"(chunk,fn)","desc":"发送一个请求主体的数据块。 通过多次调用此方法，可以将请求主体发送到服务器，在这种情况下，建议在创建请求时使用 ['Transfer-Encoding', 'chunked'] 请求头行。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".end","suffix":"([data],fn)","desc":"完成发送请求。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".abort()","suffix":"","desc":"将请求标记为中止。 调用此方法将导致响应中剩余的数据被丢弃并且套接字被销毁。\nrequest.aborted 如果请求已中止，则 request.aborted 属性将会为 true。","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".<prop>","suffix":"","desc":"request.path 请求的路径","url":"","summary":"","reference":"","dot":""},{"prefix":"req","tag":".<fn>","suffix":"","desc":"`request.setTimeout(timeout[, callback])`\n`request.setNoDelay([noDelay])`\n`request.setSocketKeepAlive([enable][, initialDelay])` ","url":"","summary":"","reference":"","dot":""}]},{"title":"python","fold":true,"list":[{"prefix":"","tag":"requests","suffix":"","desc":"","url":"","summary":"","reference":"urllib|https://www.liaoxuefeng.com/wiki/1016959663602400/1019223241745024\nrequests|https://www.liaoxuefeng.com/wiki/1016959663602400/1183249464292448","dot":""},{"prefix":"","tag":"make_server","suffix":"","desc":"","url":"https://www.liaoxuefeng.com/wiki/1016959663602400/1017805733037760","summary":"","reference":"","dot":""}]},{"title":"framework","fold":false,"list":[{"prefix":"","tag":"koa","suffix":"","desc":"+ ctx.request  请求对象\n+ ctx.response 响应对象\n+ ctx.cookies.get|set(name,[val]) cookie","url":"","summary":"+ ctx.req Node 的 request 对象.\n+ ctx.res Node 的 response 对象.\n+ ctx.params => router :arg\n+ ctx.query => ?get查询参数数据 (axios通过params发送)\n+ ctx.request.body => post提交数据 （axios通过data发送）\n","reference":"参考资料|https://koa.bootcss.com","dot":""},{"prefix":"","tag":"flask","suffix":"","desc":"","url":"https://dormousehole.readthedocs.io/en/latest/quickstart.html#quickstart","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"TCP","barcolor":"","fold":false,"box":[{"title":"node server","fold":false,"list":[{"prefix":"","tag":"net.createServer","suffix":"(fn(socket))","desc":"创建一个 TCP 服务器\n参数 connectionListener 自动给 'connection' 事件创建监听器。\n`const server = new net.Server([options][, connectionListener])`","url":"","summary":"","reference":"","dot":""},{"prefix":"server","tag":".listen","suffix":"(port)","desc":"启动一个服务器来监听连接","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/net.html#net_server_listen","dot":""},{"prefix":"server","tag":".on","suffix":"(event,fn)","desc":"+ connection (socket) : 当一个新的连接建立的时候触发,socket 是一个 net.Socket 实例.\n+ listening  : 当调用 server.listen() 绑定服务器之后触发。\n+ close :当 server 关闭的时候触发。 如果有连接存在，直到所有的连接结束才会触发这个事件。\n+ error (err) : 当错误出现的时候触发.'close' 事件不会在这个事件触发后继续触发，除非 server.close() 是手动调用.","url":"","summary":"","reference":"","dot":""}]},{"title":"node client","fold":false,"list":[{"prefix":"","tag":"net.connect","suffix":"(port,host,fn)","desc":"返回一个新的 'net.Socket'，并连接到指定的地址和端口。\n当 socket 建立的时候，将会触发 'connect' 事件。\n`const client = net.createConnection(options[, connectListener])` 的别名。","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/net.html#net_net_connect","dot":""}]},{"title":"net.Socket","fold":false,"list":[{"prefix":"","tag":"new net.Socket","suffix":"(opt)","desc":"`socket.connect(port[, host][, connectListener])`\n指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。\n\n`socket.connect(path[, connectListener])`\n打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".on","suffix":"(event,fn)","desc":"+ lookup 在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。\n+ connect 成功建立 socket 连接时触发。\n+ ready 套接字准备好使用时触发,'connect' 后立即触发。\n+ **data** 当接收到数据时触发。\n+ end 当 socket 另一端发送 FIN 包时，触发该事件。\n+ timeout 当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。\n+ drain 当写缓存为空得时候触发。可用来控制上传。\n+ error 错误发生时触发。\n+ close 当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".write","suffix":"(data,fn)","desc":"在 socket 上发送数据\n第二个参数指定了字符串的编码，默认是 UTF8 编码。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket.","tag":"<prop>","suffix":"","desc":"+ socket.bufferSize\n该属性显示了要写入缓冲区的字节数。\n\n+ socket.remoteAddress \n远程的 IP 地址字符串，例如：'74.125.127.100' or '2001:4860:a005::68'。\n+ socket.remoteFamily\n远程IP协议族字符串，比如 'IPv4' or 'IPv6'。\n+ socket.remotePort\n远程端口，数字表示，例如：80 or 21。\n\n+ socket.localAddress\n网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听'0.0.0.0'而客户端连接在'192.168.1.1'，这个值就会是 '192.168.1.1'。\n+ socket.localPort\n本地端口地址，数字表示。例如：80 or 21。\n\n+ socket.bytesRead\n接收到得字节数。\n+ socket.bytesWritten\n发送的字节数。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".<fn>","suffix":"","desc":"+ socket.setEncoding([encoding])\n设置编码\n+ socket.write(data[, encoding][, callback])\n在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。\n+ socket.end([data][, encoding])\n半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。\n+ socket.destroy()\n确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。\n+ socket.pause()\n暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。\n+ socket.resume()\n调用 pause() 后想恢复读取数据。\n+ socket.setTimeout(timeout[, callback])\nsocket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。\n+ socket.setNoDelay([noDelay])\n禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。\n+ socket.setKeepAlive([enable][, initialDelay])\n禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.\n+ socket.address()\n操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: 'IPv4', address: '127.0.0.1' }。\n+ socket.unref()\n如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。\n+ socket.ref()\n与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。","url":"","summary":"","reference":"","dot":""}]},{"title":"python socket","fold":false,"list":[{"prefix":"","tag":"socket.socket","suffix":"(socket.AF_INET, socket.SOCK_STREAM)","desc":"导入socket库:\n`import socket`\n创建一个socket:\n`s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`\n\n\n创建Socket时，AF\\_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6","url":"","summary":"","reference":"参考资料|https://www.runoob.com/python3/python3-socket.html","dot":""},{"prefix":"s","tag":".connect","suffix":"((host,port))","desc":"建立连接:\n`s.connect(('www.abc.com', 80))`\n注意参数是一个tuple，包含地址和端口号。","url":"","summary":"","reference":"","dot":""},{"prefix":"s","tag":".send","suffix":"(data)","desc":"发送数据","url":"","summary":"","reference":"","dot":""},{"prefix":"s","tag":".recv","suffix":"(max)","desc":"接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。\n```\n# 接收数据:\nbuffer = []\nwhile True:\n    # 每次最多接收1k字节:\n    d = s.recv(1024)\n    if d:\n        buffer.append(d)\n    else:\n        break\ndata = b''.join(buffer)\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"s.","tag":"close()","suffix":"","desc":"关闭连接","url":"","summary":"","reference":"","dot":""}]},{"title":"python server","fold":false,"list":[{"prefix":"s","tag":".bind","suffix":"((host,port))","desc":"监听端口`s.bind(('127.0.0.1', 9999))`","url":"","summary":"","reference":"","dot":""},{"prefix":"s","tag":".listen","suffix":"(max)","desc":"调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量\n```\ns.listen(5)\nprint('Waiting for connection...')\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"s.","tag":"accept()","suffix":"","desc":"服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:\n```\nwhile True:\n    # 接受一个新连接:\n    sock, addr = s.accept()\n    # 创建新线程来处理TCP连接:\n    t = threading.Thread(target=tcplink, args=(sock, addr))\n    t.start()\n```","url":"","summary":"每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：\n```\ndef tcplink(sock, addr):\n    print('Accept new connection from %s:%s...' % addr)\n    sock.send(b'Welcome!')\n    while True:\n        data = sock.recv(1024)\n        time.sleep(1)\n        if not data or data.decode('utf-8') == 'exit':\n            break\n        sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8'))\n    sock.close()\n    print('Connection from %s:%s closed.' % addr)\n```","reference":"","dot":""}]}]}]},{"column":[{"title":"UDP","barcolor":"","fold":false,"box":[{"title":"node dgram","fold":false,"list":[{"prefix":"","tag":"dgram.createSocket","suffix":"('udp4|6')","desc":"创建一个 dgram.Socket 对象\ncallback <Function> 为 'message' 事件绑定一个监听器。","url":"","summary":"# server\n```\n// 例子：UDP服务端\nvar PORT = 33333;\nvar HOST = '127.0.0.1';\n\nvar dgram = require('dgram');\nvar server = dgram.createSocket('udp4');\n\nserver.on('listening', function () {\n    var address = server.address();\n    console.log('UDP Server listening on ' + address.address + \":\" + address.port);\n});\n\nserver.on('message', function (message, remote) {\n    console.log(remote.address + ':' + remote.port +' - ' + message);\n});\n\nserver.bind(PORT, HOST);\n```\n# 客户端\n```\n// 例子：UDP客户端\nvar PORT = 33333;\nvar HOST = '127.0.0.1';\n\nvar dgram = require('dgram');\nvar message = Buffer.from('My KungFu is Good!');\n\nvar client = dgram.createSocket('udp4');\n\nclient.send(message, PORT, HOST, function(err, bytes) {\n    if (err) throw err;\n    console.log('UDP message sent to ' + HOST +':'+ PORT);\n    client.close();\n});\n```","reference":"","dot":""},{"prefix":"socket","tag":".bind","suffix":"(port)","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".on","suffix":"(event,fn)","desc":"+ listening\n当一个 socket 开始监听数据包信息时， 'listening' 事件将被触发。 该事件会在创建 UDP socket 之后被立即触发。\n+ **message**\n当有新的数据包被 socket 接收时， 'message' 事件会被触发。msg 和 rinfo 会作为参数传递到该事件的处理函数中。\n+ connect\n因 connect() 调用成功而使 socket 与远程地址关联之后，则会触发 'connect' 事件。\n+ close \n'close' 事件将在使用 close() 关闭一个 socket 之后触发。 该事件一旦触发，则这个 socket 上将不会触发新的 'message' 事件。\n+ error\n当有任何错误发生时， 'error' 事件将被触发。 事件发生时，事件处理函数仅会接收到一个 Error 对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".send","suffix":"(msg,[port,host],fn)","desc":"在 socket 上广播一个数据包","url":"","summary":"","reference":"","dot":""},{"prefix":"socket","tag":".setBroadcast","suffix":"(flag)","desc":"设置或清除 SO_BROADCAST socket 选项。 当设置为 true, UDP 包可能会被发送到一个本地接口的广播地址。","url":"","summary":"```\nvar dgram = require('dgram');\nvar client = dgram.createSocket('udp4');\nvar msg = Buffer.from('hello world');\nvar port = 33333;\nvar host = '255.255.255.255';\n\nclient.bind(function(){\n    client.setBroadcast(true);\n    client.send(msg, port, host, function(err){\n        if(err) throw err;\n        console.log('msg has been sent');\n        client.close();\n    });\n});\n```","reference":"参考资料|https://segmentfault.com/a/1190000013092163","dot":""}]},{"title":"python dgram","fold":false,"list":[{"prefix":"","tag":"socket.socket","suffix":"(socket.AF_INET, socket.SOCK_DGRAM)","desc":"`s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)`\n不需要调用listen()方法，而是直接接收来自任何客户端的数据","url":"","summary":"","reference":"参考资料|https://www.liaoxuefeng.com/wiki/1016959663602400/1017790181885952","dot":""},{"prefix":"s","tag":".bind","suffix":"((host,port))","desc":"绑定端口","url":"","summary":"","reference":"","dot":""},{"prefix":"s.","tag":"sendto","suffix":"(data)","desc":"服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端\n客户端也不需要调用connect()，直接通过sendto()给服务器发数据","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"IP","barcolor":"","fold":false,"box":[{"title":"node","fold":false,"list":[{"prefix":"","tag":"net.isIP","suffix":"(val)","desc":"测试输入是否是 IP 地址。\n+ 无效的字符串则返回 0\n+ IPv4 地址则返回 4\n+ IPv6 的地址则返回 6","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"net.isIPv4","suffix":"(val)","desc":"如果输入是 IPv4 地址则返回 true，否则返回 false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"net.isIPv6","suffix":"(val)","desc":"如果输入是 IPv6 地址则返回 true，否则返回 false","url":"","summary":"","reference":"","dot":""}]}]},{"title":"URL","barcolor":"","fold":false,"box":[{"title":"url","fold":false,"list":[{"prefix":"","tag":"new URL","suffix":"(path,base)","desc":"生成URL\nurl.hash\nurl.host\nurl.hostname\nurl.href\nurl.origin\nurl.password\nurl.pathname\nurl.port\nurl.protocol\nurl.search\nurl.searchParams\nurl.username\nurl.toString()","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"new URLSearchParams","suffix":"(val)","desc":"生成字符串查询对象,只读\nurlSearchParams.append(name, value)\nurlSearchParams.delete(name)\nurlSearchParams.entries()\nurlSearchParams.forEach(fn[, thisArg])\nurlSearchParams.get(name)\nurlSearchParams.getAll(name)\nurlSearchParams.has(name)\nurlSearchParams.keys()\nurlSearchParams.set(name, value)\nurlSearchParams.sort()\nurlSearchParams.toString()\nurlSearchParams.values()\nurlSearchParams[Symbol.iterator]()","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"url.domainToASCII","suffix":"(domain)","desc":"域名编码 `url.domainToASCII(domain)`\n域名解码 `url.domainToUnicode(domain)`\n返回 Punycode ASCII 序列化的 domain。 如果 domain 是无效域名，则返回空字符串。\n```\nconsole.log(url.domainToASCII('中文.com'));\n// 打印 xn--fiq228c.com\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"url.pathToFileURL","suffix":"(path)","desc":"文件路径编码 `url.pathToFileURL(path)`\n文件路径解码 `url.fileURLToPath(url)`\n此方法保证百分号编码字符解码结果的正确性，同时也确保绝对路径字符串在不同平台下的有效性。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Spider","barcolor":"","fold":false,"box":[{"title":"python","fold":false,"list":[{"prefix":"","tag":"HTMLParser","suffix":"","desc":"https://www.liaoxuefeng.com/wiki/1016959663602400/1017784593019776","url":"","summary":"","reference":"","dot":""}]}]}]}]}